#!/usr/bin/env python3
"""Summarize tool discovery benchmark CSV output."""

from __future__ import annotations

import argparse
import csv
from collections import Counter, defaultdict
from pathlib import Path


def _pct(n: int, d: int) -> str:
    if d == 0:
        return "0.0%"
    return f"{(100.0 * n / d):.1f}%"


def _split_tools(value: str) -> list[str]:
    return [part for part in value.split("|") if part]


def main() -> int:
    parser = argparse.ArgumentParser(description="Summarize tool discovery results CSV")
    parser.add_argument("csv_path", help="Path to CSV file generated by live benchmark")
    parser.add_argument("--top", type=int, default=10, help="Number of top confusion pairs to print")
    args = parser.parse_args()

    csv_path = Path(args.csv_path)
    if not csv_path.exists():
        print(f"CSV not found: {csv_path}")
        return 2

    rows: list[dict[str, str]] = []
    with csv_path.open("r", encoding="utf-8", newline="") as handle:
        reader = csv.DictReader(handle)
        for row in reader:
            rows.append({k: (v or "") for k, v in row.items()})

    total = len(rows)
    if total == 0:
        print("No rows in CSV.")
        return 1

    status_counter = Counter(row.get("status", "") for row in rows)

    positives = [r for r in rows if r.get("expected_any", "")]
    negatives = [r for r in rows if not r.get("expected_any", "")]
    evaluated = [r for r in positives if r.get("status") != "blocked"]

    top1_hits = 0
    top3_hits = 0
    top5_hits = 0

    for row in evaluated:
        expected = set(_split_tools(row.get("expected_any", "")))
        top1 = row.get("top1", "")
        top3 = set(_split_tools(row.get("top3", "")))
        top5 = set(_split_tools(row.get("top5", "")))

        if top1 in expected:
            top1_hits += 1
        if expected.intersection(top3):
            top3_hits += 1
        if expected.intersection(top5):
            top5_hits += 1

    negative_pass = sum(1 for r in negatives if r.get("status") == "pass")

    # Confusion pairs: expected -> wrong top1 where expected exists in top5
    pair_counter: Counter[tuple[str, str]] = Counter()
    cluster_counter: Counter[str] = Counter()
    blocked_cases: list[dict[str, str]] = []

    for row in rows:
        if row.get("status") == "blocked":
            blocked_cases.append(row)

    for row in evaluated:
        expected_list = _split_tools(row.get("expected_any", ""))
        if not expected_list:
            continue
        expected = set(expected_list)
        top1 = row.get("top1", "")
        top5 = set(_split_tools(row.get("top5", "")))
        cluster = row.get("cluster", "")

        if top1 and top1 not in expected and expected.intersection(top5):
            for exp in expected_list:
                pair_counter[(exp, top1)] += 1
            if cluster:
                cluster_counter[cluster] += 1

    by_category: dict[str, Counter[str]] = defaultdict(Counter)
    for row in rows:
        by_category[row.get("category", "uncategorized")][row.get("status", "")] += 1

    print("Tool Discovery Results")
    print(f"- cases: {total}")
    print(f"- statuses: {dict(status_counter)}")
    print(f"- positive cases: {len(positives)} (evaluated: {len(evaluated)})")
    print(f"- top1: {top1_hits}/{len(evaluated)} ({_pct(top1_hits, len(evaluated))})")
    print(f"- top3: {top3_hits}/{len(evaluated)} ({_pct(top3_hits, len(evaluated))})")
    print(f"- top5: {top5_hits}/{len(evaluated)} ({_pct(top5_hits, len(evaluated))})")
    print(f"- negative pass: {negative_pass}/{len(negatives)} ({_pct(negative_pass, len(negatives))})")

    print("\nBy Category")
    for category in sorted(by_category):
        print(f"- {category}: {dict(by_category[category])}")

    print("\nTop Confused Pairs (expected -> predicted top1, with expected still in top5)")
    if not pair_counter:
        print("- none")
    else:
        for (expected, predicted), count in pair_counter.most_common(args.top):
            print(f"- {expected} -> {predicted}: {count}")

    print("\nConfusion by Cluster")
    if not cluster_counter:
        print("- none")
    else:
        for cluster, count in cluster_counter.most_common(args.top):
            print(f"- {cluster}: {count}")

    if blocked_cases:
        print("\nBlocked Cases (first 10)")
        for row in blocked_cases[:10]:
            print(f"- {row.get('case_id', '')}: {row.get('query', '')}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
