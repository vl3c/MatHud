<!DOCTYPE html>
<!--
MatHud Mathematical Canvas Web Interface

Main HTML template for the interactive mathematical graphing calculator.
Provides AI-powered canvas for geometric shapes, calculations, and mathematical exploration.

Key Components:
    - MathJax: LaTeX mathematical notation rendering
    - Brython: Python-in-browser execution for canvas operations
    - SVG Canvas: Interactive mathematical visualization area
    - Chat Interface: AI communication with model selection and vision toggle
    - Responsive Layout: Dual-pane interface (canvas + chat)

Dependencies:
    - Google Fonts (Inter): Modern typography
    - MathJax 3: Mathematical equation rendering
    - Brython 3.12.5: Python runtime for browser-side logic
    - Flask templates: Dynamic asset URL generation
-->
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>MatHud - Mathematical Canvas</title>
    
    <!-- Google Fonts for modern typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- MathJax configuration for LaTeX mathematical notation rendering -->
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Brython Python runtime and mathematical libraries from CDN (2025 latest versions) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/14.5.2/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/nerdamer.core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Algebra.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Calculus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Solve.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Extra.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.12.5/brython.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.12.5/brython_stdlib.min.js"></script>
    
    <!-- Application styles -->
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">   
</head>
<body onload="initBrython()">
    <div class="container">
        <!-- Mathematical Canvas Area -->
        <div class="math-container" id="math-container">
            <!-- Logout button overlay -->
            <button id="logout-button-overlay" class="logout-overlay-button" style="display: none;" title="Logout">
                Ã—
            </button>
            <!-- SVG canvas for interactive mathematical visualizations -->
            <svg id="math-svg" style="width:100%; height:100%"></svg>
        </div>

        <!-- Draggable separator between canvas and chat areas -->
        <div class="resize-separator" id="resize-separator"></div>

        <!-- AI Chat Interface -->
        <div class="chat-container">
            <!-- AI Model and Vision Configuration -->
            <div class="selection-container">
                <button id="new-conversation-button" title="Save workspace and start a new conversation">New Conversation</button>
                <div class="controls-group">
                    <div class="ai-model-selector">
                        <label for="ai-model-selector">Model:</label>
                        <select id="ai-model-selector">
                            <option value="gpt-5-chat-latest">GPT-5 Chat Latest</option>
                            <option value="gpt-5.2-chat-latest">GPT-5.2 Chat Latest</option>
                            <option value="gpt-5.2" selected>GPT-5.2 (Medium Reasoning)</option>
                            <option value="o3">o3 (Reasoning)</option>
                            <option value="o4-mini">o4-mini (Reasoning)</option>
                            <option value="gpt-4.1">GPT-4.1</option>
                            <option value="gpt-4.1-mini">GPT-4.1 Mini</option>
                            <option value="gpt-4.1-nano">GPT-4.1 Nano</option>
                            <option value="gpt-4o">GPT-4o</option>
                            <option value="gpt-4o-mini">GPT-4o Mini</option>
                            <option value="gpt-5-nano">GPT-5 Nano</option>
                            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                        </select>
                    </div>
                    <div class="vision-toggle">
                        <input type="checkbox" id="vision-toggle">
                        <label for="vision-toggle">Enable Vision</label>
                    </div>
                </div>
            </div>
            
            <!-- Chat History Display -->
            <div class="chat-history" id="chat-history"></div>
            
            <!-- User Input Area -->
            <div class="chat-input-container">
                <input class="chat-input" id="chat-input" type="text" placeholder="Type your message here...">
                <div class="chat-buttons">
                    <button id="send-button">Send</button>
                    <!-- TEMPORARY: Run Tests Button (see documentation/development/removing_run_tests_button.md) -->
                    <button id="run-tests-button" title="Run client-side tests">Run Tests</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Brython initialization and configuration -->
    <script>
    function initBrython() {
        // Configure Brython to use local paths for our modules
        brython({
            debug: 0,
            cache: 'browser',
            static_stdlib_import: true,
            async: true,
            pythonpath: ['{{ url_for("static", filename="client") }}']
        });
    }
    </script>
    
    <!-- Streaming helper using Fetch and NDJSON -->
    <script>
    // Store the current stream's abort controller for cancellation
    window._currentStreamAbortController = null;
    
    // Abort any ongoing stream - call this on timeout
    window.abortCurrentStream = function() {
        if (window._currentStreamAbortController) {
            try {
                window._currentStreamAbortController.abort();
                console.log('[Stream] Aborted current stream');
            } catch (e) {
                console.error('[Stream] Error aborting:', e);
            }
            window._currentStreamAbortController = null;
        }
    };
    
    // Expose a helper for Brython to stream responses
    // onReasoning callback handles reasoning tokens from reasoning models
    window.sendMessageStream = async function(payload, onToken, onFinal, onError, onReasoning) {
        // Abort any existing stream before starting a new one
        window.abortCurrentStream();
        
        // Create new abort controller for this stream
        const abortController = new AbortController();
        window._currentStreamAbortController = abortController;
        
        try {
            const resp = await fetch('/send_message_stream', {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify(payload),
                signal: abortController.signal
            });

            if (!resp.ok || !resp.body) {
                onError('Network error');
                return;
            }

            const reader = resp.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });

                let newlineIndex;
                while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
                    const line = buffer.slice(0, newlineIndex).trim();
                    buffer = buffer.slice(newlineIndex + 1);
                    if (!line) continue;
                    try {
                        const evt = JSON.parse(line);
                        if (evt.type === 'reasoning' && typeof onReasoning === 'function') {
                            onReasoning(evt.text || '');
                        } else if (evt.type === 'token' && typeof onToken === 'function') {
                            onToken(evt.text || '');
                        } else if (evt.type === 'final' && typeof onFinal === 'function') {
                            // Clear abort controller before calling onFinal to prevent
                            // race condition when tool results trigger a new request
                            if (window._currentStreamAbortController === abortController) {
                                window._currentStreamAbortController = null;
                            }
                            onFinal(evt);
                        }
                    } catch (e) {
                        // Ignore malformed lines
                    }
                }
            }
            // Flush any remaining buffered text as token if not empty
            if (buffer.trim()) {
                try {
                    const evt = JSON.parse(buffer.trim());
                    if (evt.type === 'reasoning' && typeof onReasoning === 'function') {
                        onReasoning(evt.text || '');
                    } else if (evt.type === 'token' && typeof onToken === 'function') {
                        onToken(evt.text || '');
                    } else if (evt.type === 'final' && typeof onFinal === 'function') {
                        // Clear abort controller before calling onFinal
                        if (window._currentStreamAbortController === abortController) {
                            window._currentStreamAbortController = null;
                        }
                        onFinal(evt);
                    }
                } catch (e) {
                    // ignore
                }
            }
        } catch (err) {
            // Don't call onError for abort (that's intentional cancellation)
            if (err.name === 'AbortError') {
                console.log('[Stream] Request was aborted');
                return;
            }
            if (typeof onError === 'function') onError(err);
        } finally {
            // Clear the abort controller reference when done
            if (window._currentStreamAbortController === abortController) {
                window._currentStreamAbortController = null;
            }
        }
    }
    </script>

    <!-- Main Brython application entry point -->
    <script type="text/python" src="{{ url_for('static', filename='client/main.py') }}"></script>
    
    <!-- Vision toggle functionality based on AI model capabilities -->
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        var aiModelSelector = document.getElementById("ai-model-selector");
        var visionToggle = document.getElementById("vision-toggle");
        var visionLabel = document.querySelector("label[for='vision-toggle']");
        
        // Ensure vision is unchecked on page load
        visionToggle.checked = false;
        
        /**
         * Updates vision toggle availability based on selected AI model capabilities.
         * Vision features are only available for models with vision support.
         */
        function updateVisionToggle() {
            // Models with vision support
            var modelsWithVision = [
                "gpt-5-chat-latest",
                "gpt-5.2-chat-latest",
                "gpt-5.2",
                "gpt-4.1",
                "gpt-4.1-mini",
                "gpt-4.1-nano",
                "gpt-4o",
                "gpt-4o-mini",
                "gpt-5-nano",
                "o4-mini"  // o4-mini has vision, o3 does not
            ];
            
            if (modelsWithVision.includes(aiModelSelector.value)) {
                visionToggle.disabled = false;
                visionToggle.style.opacity = "1";
                visionLabel.style.color = "";
            } else {
                visionToggle.disabled = true;
                visionToggle.checked = false;
                visionToggle.style.opacity = "0.5";
                visionLabel.style.color = "gray";
            }
        }
        
        // Initialize vision toggle state on page load
        updateVisionToggle();

        // Update vision toggle when AI model selection changes
        aiModelSelector.addEventListener("change", updateVisionToggle);
        
        // ===== LOGOUT FUNCTIONALITY =====
        // Show logout button when authentication is enabled
        function checkAuthRequirement() {
            // Check if we need to show logout button by making a request to auth status endpoint
            fetch('/auth_status')
                .then(response => response.json())
                .then(data => {
                    console.log('Auth status response:', data); // Debug log
                    
                    // Check if authentication is required
                    const authRequired = data && data.data && data.data.auth_required;
                    
                    if (authRequired) {
                        console.log('Authentication required - showing logout button'); // Debug log
                        document.getElementById('logout-button-overlay').style.display = 'flex';
                    } else {
                        console.log('Authentication not required - hiding logout button'); // Debug log
                        document.getElementById('logout-button-overlay').style.display = 'none';
                    }
                })
                .catch((error) => {
                    console.error('Error checking auth status:', error); // Debug log
                    // If there's an error, hide the logout button (safer default)
                    document.getElementById('logout-button-overlay').style.display = 'none';
                });
        }
        
        // Check auth requirement on page load
        checkAuthRequirement();
        
        // Handle logout button click
        document.getElementById('logout-button-overlay').addEventListener('click', function() {
            if (confirm('Are you sure you want to logout?')) {
                window.location.href = '/logout';
            }
        });
        
        // ===== MOBILE KEYBOARD HANDLING =====
        // Detect virtual keyboard opening/closing and adjust UI
        var chatInputContainer = document.querySelector('.chat-input-container');
        var chatInput = document.getElementById('chat-input');
        var chatContainer = document.querySelector('.chat-container');
        var initialViewportHeight = window.innerHeight;
        var isKeyboardOpen = false;
        var originalScrollTop = 0;
        
        /**
         * Detects virtual keyboard state and adjusts UI accordingly
         */
        function handleViewportChange() {
            var currentViewportHeight = window.innerHeight;
            var heightDifference = initialViewportHeight - currentViewportHeight;
            
            // Threshold for detecting keyboard (150px+ indicates keyboard)
            var keyboardThreshold = 150;
            
            if (heightDifference > keyboardThreshold && !isKeyboardOpen) {
                // Keyboard opened
                isKeyboardOpen = true;
                originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                
                chatInputContainer.classList.add('keyboard-open');
                document.body.style.overflow = 'hidden'; // Prevent scrolling
                
                // Ensure input stays visible and centered
                setTimeout(function() {
                    chatInput.focus();
                    // Scroll to top to ensure input is visible
                    window.scrollTo(0, 0);
                }, 100);
                
            } else if (heightDifference <= keyboardThreshold && isKeyboardOpen) {
                // Keyboard closed - restore original state
                isKeyboardOpen = false;
                chatInputContainer.classList.remove('keyboard-open');
                document.body.style.overflow = ''; // Restore scrolling
                
                // Restore original scroll position
                setTimeout(function() {
                    window.scrollTo(0, originalScrollTop);
                }, 100);
            }
        }
        
        /**
         * Handle input focus - prepare for keyboard opening
         */
        function handleInputFocus() {
            // Store current scroll position
            originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            
            // Small delay to detect if keyboard will open
            setTimeout(function() {
                var currentHeight = window.innerHeight;
                if (currentHeight < initialViewportHeight * 0.85) {
                    // Keyboard is opening, ensure input is visible
                    window.scrollTo(0, 0);
                }
            }, 300);
        }
        
        /**
         * Handle input blur - prepare for keyboard closing
         */
        function handleInputBlur() {
            // Small delay to allow keyboard to close
            setTimeout(function() {
                if (!isKeyboardOpen) {
                    // Keyboard has closed, restore state
                    document.body.style.overflow = '';
                    window.scrollTo(0, originalScrollTop);
                }
            }, 300);
        }
        
        // Listen for viewport changes (keyboard open/close)
        window.addEventListener('resize', handleViewportChange);
        window.addEventListener('orientationchange', function() {
            setTimeout(function() {
                initialViewportHeight = window.innerHeight;
                handleViewportChange();
            }, 500);
        });
        
        // Listen for input focus and blur
        chatInput.addEventListener('focus', handleInputFocus);
        chatInput.addEventListener('blur', handleInputBlur);
        
        // Enhanced visual viewport API handling (newer browsers)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', function() {
                var keyboardHeight = window.innerHeight - window.visualViewport.height;
                
                if (keyboardHeight > 150 && !isKeyboardOpen) {
                    isKeyboardOpen = true;
                    originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                    
                    chatInputContainer.classList.add('keyboard-open');
                    document.body.style.overflow = 'hidden';
                    window.scrollTo(0, 0);
                    
                } else if (keyboardHeight <= 150 && isKeyboardOpen) {
                    isKeyboardOpen = false;
                    chatInputContainer.classList.remove('keyboard-open');
                    document.body.style.overflow = '';
                    
                    // Restore scroll position
                    setTimeout(function() {
                        window.scrollTo(0, originalScrollTop);
                    }, 100);
                }
            });
        }
    });
    </script>

    <!-- Resize separator functionality for dragging between canvas and chat -->
    <script>
    (function() {
        var separator = document.getElementById('resize-separator');
        var mathContainer = document.getElementById('math-container');
        var chatContainer = document.querySelector('.chat-container');
        var chatInputContainer = document.querySelector('.chat-input-container');
        var selectionContainer = document.querySelector('.selection-container');

        var isDragging = false;
        var startPos = 0;
        var startMathSize = 0;
        var startChatSize = 0;

        // Threshold widths for responsive stacking
        var NARROW_THRESHOLD = 420;
        var VERY_NARROW_THRESHOLD = 280;

        function isVerticalLayout() {
            return window.innerWidth <= 1024;
        }

        function updateNarrowState() {
            // Only apply narrow state in desktop (horizontal) layout
            if (!isVerticalLayout()) {
                var chatWidth = chatContainer.offsetWidth;
                if (chatWidth < VERY_NARROW_THRESHOLD) {
                    chatInputContainer.classList.add('narrow');
                    chatInputContainer.classList.add('very-narrow');
                    selectionContainer.classList.add('narrow');
                    selectionContainer.classList.add('very-narrow');
                } else if (chatWidth < NARROW_THRESHOLD) {
                    chatInputContainer.classList.add('narrow');
                    chatInputContainer.classList.remove('very-narrow');
                    selectionContainer.classList.add('narrow');
                    selectionContainer.classList.remove('very-narrow');
                } else {
                    chatInputContainer.classList.remove('narrow');
                    chatInputContainer.classList.remove('very-narrow');
                    selectionContainer.classList.remove('narrow');
                    selectionContainer.classList.remove('very-narrow');
                }
            } else {
                // In vertical layout, never use narrow state
                chatInputContainer.classList.remove('narrow');
                chatInputContainer.classList.remove('very-narrow');
                selectionContainer.classList.remove('narrow');
                selectionContainer.classList.remove('very-narrow');
            }
        }

        separator.addEventListener('mousedown', startDrag);
        separator.addEventListener('touchstart', startDrag, { passive: false });

        function startDrag(e) {
            e.preventDefault();
            isDragging = true;
            separator.classList.add('dragging');
            document.body.style.cursor = isVerticalLayout() ? 'row-resize' : 'col-resize';
            document.body.style.userSelect = 'none';

            var pos = e.type.includes('touch') ? e.touches[0] : e;
            startPos = isVerticalLayout() ? pos.clientY : pos.clientX;
            startMathSize = isVerticalLayout() ? mathContainer.offsetHeight : mathContainer.offsetWidth;
            startChatSize = isVerticalLayout() ? chatContainer.offsetHeight : chatContainer.offsetWidth;

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();

            var pos = e.type.includes('touch') ? e.touches[0] : e;
            var currentPos = isVerticalLayout() ? pos.clientY : pos.clientX;
            var delta = currentPos - startPos;

            var minMathSize = 400; // Must match CSS .math-container min-width
            var minChatSize = 200;

            var newMathSize = startMathSize + delta;
            var newChatSize = startChatSize - delta;

            // Don't allow either to go below minimum - just stop
            if (newMathSize < minMathSize || newChatSize < minChatSize) {
                return;
            }

            if (isVerticalLayout()) {
                mathContainer.style.height = newMathSize + 'px';
                mathContainer.style.flex = 'none';
                chatContainer.style.minHeight = newChatSize + 'px';
            } else {
                mathContainer.style.width = newMathSize + 'px';
                mathContainer.style.flex = 'none';
                chatContainer.style.width = newChatSize + 'px';
                chatContainer.style.flexShrink = '0';
            }

            // Update narrow state for button stacking
            updateNarrowState();

            // Redraw canvas with new dimensions (use requestAnimationFrame to ensure layout is computed)
            requestAnimationFrame(function() {
                if (typeof window.redrawMatHudCanvas === 'function') {
                    window.redrawMatHudCanvas();
                }
            });
        }

        function stopDrag() {
            isDragging = false;
            separator.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        // Reset custom sizes on orientation/breakpoint change
        var lastIsVertical = isVerticalLayout();
        window.addEventListener('resize', function() {
            var nowVertical = isVerticalLayout();
            if (nowVertical !== lastIsVertical) {
                mathContainer.style.width = '';
                mathContainer.style.height = '';
                mathContainer.style.flex = '';
                chatContainer.style.width = '';
                chatContainer.style.minHeight = '';
                chatContainer.style.flexShrink = '';
                lastIsVertical = nowVertical;
            }
            // Update narrow state on any resize
            updateNarrowState();
            // Redraw canvas with new dimensions (use requestAnimationFrame to ensure layout is computed)
            requestAnimationFrame(function() {
                if (typeof window.redrawMatHudCanvas === 'function') {
                    window.redrawMatHudCanvas();
                }
            });
        });

        // Initialize narrow state on load
        updateNarrowState();
    })();
    </script>
</body>
</html>