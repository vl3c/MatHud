<!DOCTYPE html>
<!--
MatHud Mathematical Canvas Web Interface

Main HTML template for the interactive mathematical graphing calculator.
Provides AI-powered canvas for geometric shapes, calculations, and mathematical exploration.

Key Components:
    - MathJax: LaTeX mathematical notation rendering
    - Brython: Python-in-browser execution for canvas operations
    - SVG Canvas: Interactive mathematical visualization area
    - Chat Interface: AI communication with model selection and vision toggle
    - Responsive Layout: Dual-pane interface (canvas + chat)

Dependencies:
    - Google Fonts (Inter): Modern typography
    - MathJax 3: Mathematical equation rendering
    - Brython 3.12.5: Python runtime for browser-side logic
    - Flask templates: Dynamic asset URL generation
-->
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>MatHud - Mathematical Canvas</title>
    
    <!-- Google Fonts for modern typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- MathJax configuration for LaTeX mathematical notation rendering -->
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Brython Python runtime and mathematical libraries from CDN (2025 latest versions) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/14.5.2/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/nerdamer.core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Algebra.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Calculus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Solve.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Extra.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.12.5/brython.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.12.5/brython_stdlib.min.js"></script>
    
    <!-- Application styles -->
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">

    <!-- Loading spinner for model preloading -->
    <style>
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #ddd;
            border-top-color: #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .model-loading-message {
            background-color: #f5f5f5;
            border-left: 3px solid #666;
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body onload="initBrython()">
    <div class="container">
        <!-- Mathematical Canvas Area -->
        <div class="math-container" id="math-container">
            <!-- Logout button overlay -->
            <button id="logout-button-overlay" class="logout-overlay-button" style="display: none;" title="Logout">
                Ã—
            </button>
            <!-- SVG canvas for interactive mathematical visualizations -->
            <svg id="math-svg" style="width:100%; height:100%"></svg>
        </div>

        <!-- Draggable separator between canvas and chat areas -->
        <div class="resize-separator" id="resize-separator"></div>

        <!-- AI Chat Interface -->
        <div class="chat-container">
            <!-- AI Model and Vision Configuration -->
            <div class="selection-container">
                <button id="new-conversation-button" title="Save workspace and start a new conversation">New Conversation</button>
                <div class="controls-group">
                    <div class="ai-model-selector">
                        <label for="ai-model-selector">Model:</label>
                        <select id="ai-model-selector">
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    <div class="vision-toggle">
                        <input type="checkbox" id="vision-toggle">
                        <label for="vision-toggle">Enable Vision</label>
                    </div>
                </div>
            </div>
            
            <!-- Chat History Display -->
            <div class="chat-history" id="chat-history"></div>
            
            <!-- User Input Area -->
            <div class="chat-input-container">
                <!-- Hidden file input for image attachment -->
                <input type="file" id="image-attach-input" accept="image/*" multiple style="display: none;">
                <!-- Image preview area (shown when images are attached) -->
                <div id="image-preview-area" class="image-preview-area" style="display: none;"></div>
                <!-- Input row with attach button -->
                <div class="chat-input-row">
                    <button id="attach-button" class="attach-button" title="Attach image">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
                        </svg>
                    </button>
                    <input class="chat-input" id="chat-input" type="text" placeholder="Type your message here...">
                </div>
                <div class="chat-buttons">
                    <button id="send-button">Send</button>
                    <!-- TEMPORARY: Run Tests Button (see documentation/development/removing_run_tests_button.md) -->
                    <button id="run-tests-button" title="Run client-side tests">Run Tests</button>
                </div>
            </div>

            <!-- Image modal for full-size viewing -->
            <div id="image-modal" class="image-modal" style="display: none;">
                <span class="image-modal-close">&times;</span>
                <img id="image-modal-img" class="image-modal-content" src="" alt="Full size image">
            </div>
        </div>
    </div>
    
    <!-- Brython initialization and configuration -->
    <script>
    function initBrython() {
        // Configure Brython to use local paths for our modules
        brython({
            debug: 0,
            cache: 'browser',
            static_stdlib_import: true,
            async: true,
            pythonpath: ['{{ url_for("static", filename="client") }}']
        });
    }
    </script>
    
    <!-- Streaming helper using Fetch and NDJSON -->
    <script>
    // Store the current stream's abort controller for cancellation
    window._currentStreamAbortController = null;
    
    // Abort any ongoing stream - call this on timeout
    window.abortCurrentStream = function() {
        if (window._currentStreamAbortController) {
            try {
                window._currentStreamAbortController.abort();
                console.log('[Stream] Aborted current stream');
            } catch (e) {
                console.error('[Stream] Error aborting:', e);
            }
            window._currentStreamAbortController = null;
        }
    };
    
    // Expose a helper for Brython to stream responses
    // onReasoning callback handles reasoning tokens from reasoning models
    // onLog callback handles server log events forwarded to the browser console
    window.sendMessageStream = async function(payload, onToken, onFinal, onError, onReasoning, onLog) {
        // Abort any existing stream before starting a new one
        window.abortCurrentStream();
        
        // Create new abort controller for this stream
        const abortController = new AbortController();
        window._currentStreamAbortController = abortController;
        
        try {
            const resp = await fetch('/send_message_stream', {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify(payload),
                signal: abortController.signal
            });

            if (!resp.ok || !resp.body) {
                onError('Network error');
                return;
            }

            const reader = resp.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let buffer = '';
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });

                let newlineIndex;
                while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
                    const line = buffer.slice(0, newlineIndex).trim();
                    buffer = buffer.slice(newlineIndex + 1);
                    if (!line) continue;
                    try {
                        const evt = JSON.parse(line);
                        if (evt.type === 'log' && typeof onLog === 'function') {
                            onLog(evt);
                        } else if (evt.type === 'reasoning' && typeof onReasoning === 'function') {
                            onReasoning(evt.text || '');
                        } else if (evt.type === 'token' && typeof onToken === 'function') {
                            onToken(evt.text || '');
                        } else if (evt.type === 'final' && typeof onFinal === 'function') {
                            // Clear abort controller before calling onFinal to prevent
                            // race condition when tool results trigger a new request
                            if (window._currentStreamAbortController === abortController) {
                                window._currentStreamAbortController = null;
                            }
                            onFinal(evt);
                        }
                    } catch (e) {
                        // Ignore malformed lines
                    }
                }
            }
            // Flush any remaining buffered text as token if not empty
            if (buffer.trim()) {
                try {
                    const evt = JSON.parse(buffer.trim());
                    if (evt.type === 'log' && typeof onLog === 'function') {
                        onLog(evt);
                    } else if (evt.type === 'reasoning' && typeof onReasoning === 'function') {
                        onReasoning(evt.text || '');
                    } else if (evt.type === 'token' && typeof onToken === 'function') {
                        onToken(evt.text || '');
                    } else if (evt.type === 'final' && typeof onFinal === 'function') {
                        // Clear abort controller before calling onFinal
                        if (window._currentStreamAbortController === abortController) {
                            window._currentStreamAbortController = null;
                        }
                        onFinal(evt);
                    }
                } catch (e) {
                    // ignore
                }
            }
        } catch (err) {
            // Don't call onError for abort (that's intentional cancellation)
            if (err.name === 'AbortError') {
                console.log('[Stream] Request was aborted');
                return;
            }
            if (typeof onError === 'function') onError(err);
        } finally {
            // Clear the abort controller reference when done
            if (window._currentStreamAbortController === abortController) {
                window._currentStreamAbortController = null;
            }
        }
    }
    </script>

    <!-- Main Brython application entry point -->
    <script type="text/python" src="{{ url_for('static', filename='client/main.py') }}"></script>
    
    <!-- Vision toggle functionality based on AI model capabilities -->
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        var aiModelSelector = document.getElementById("ai-model-selector");
        var visionToggle = document.getElementById("vision-toggle");
        var visionLabel = document.querySelector("label[for='vision-toggle']");

        // Ensure vision is unchecked on page load
        visionToggle.checked = false;

        // Vision models list, populated dynamically from API
        var VISION_MODELS = [];
        // Expose on window so Brython slash commands can check vision support
        window.VISION_MODELS = VISION_MODELS;

        // Ollama models list, populated dynamically from API
        var OLLAMA_MODELS = [];
        // Track currently loading model
        var modelLoadingInProgress = false;

        var attachButton = document.getElementById("attach-button");
        var visionContainer = visionToggle.parentElement;

        /**
         * Updates vision toggle and attach button visibility based on selected AI model.
         * Vision features and image attachment are hidden for models without vision support.
         */
        function updateVisionToggle() {
            var hasVision = VISION_MODELS.includes(aiModelSelector.value);
            if (hasVision) {
                visionContainer.style.display = "";
                attachButton.style.display = "";
            } else {
                visionToggle.checked = false;
                visionContainer.style.display = "none";
                attachButton.style.display = "none";
            }
        }

        // Fetch available models from server and populate dropdown
        fetch('/api/available_models')
            .then(function(response) { return response.json(); })
            .then(function(models) {
                aiModelSelector.innerHTML = '';
                VISION_MODELS = [];
                OLLAMA_MODELS = [];

                var groups = [
                    { key: 'openai', label: 'OpenAI' },
                    { key: 'anthropic', label: 'Anthropic' },
                    { key: 'openrouter_paid', label: 'OpenRouter (Paid)' },
                    { key: 'openrouter_free', label: 'OpenRouter (Free)' },
                    { key: 'ollama', label: 'Ollama (Local)' }
                ];

                var hasModels = false;
                var defaultModel = 'gpt-5.2';
                var defaultFound = false;

                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var groupModels = models[group.key];
                    if (groupModels && groupModels.length > 0) {
                        hasModels = true;
                        var optgroup = document.createElement('optgroup');
                        optgroup.label = group.label;
                        for (var j = 0; j < groupModels.length; j++) {
                            var model = groupModels[j];
                            var option = document.createElement('option');
                            option.value = model.id;
                            var label = model.display_name || model.id;
                            option.textContent = model.has_vision ? label : label + ' (text only)';
                            if (model.id === defaultModel) {
                                option.selected = true;
                                defaultFound = true;
                            }
                            optgroup.appendChild(option);
                            if (model.has_vision) {
                                VISION_MODELS.push(model.id);
                            }
                            // Track Ollama models
                            if (group.key === 'ollama') {
                                OLLAMA_MODELS.push(model.id);
                            }
                        }
                        aiModelSelector.appendChild(optgroup);
                    }
                }

                if (!hasModels) {
                    aiModelSelector.innerHTML = '<option value="">No API keys configured</option>';
                } else if (!defaultFound) {
                    // Select first available model if default not found
                    aiModelSelector.selectedIndex = 0;
                }

                // Update window reference for Brython slash commands
                window.VISION_MODELS = VISION_MODELS;
                window.OLLAMA_MODELS = OLLAMA_MODELS;
                updateVisionToggle();
            })
            .catch(function(error) {
                console.error('Failed to fetch available models:', error);
                aiModelSelector.innerHTML = '<option value="">Failed to load models</option>';
            });

        /**
         * Shows a loading message in the chat history
         * @param {string} message - The loading message to display
         * @returns {HTMLElement} The loading message element (for later removal)
         */
        function showModelLoadingMessage(message) {
            var chatHistory = document.getElementById('chat-history');
            var loadingDiv = document.createElement('div');
            loadingDiv.className = 'assistant-message model-loading-message';
            loadingDiv.innerHTML = '<span class="loading-spinner"></span> ' + message;
            loadingDiv.style.cssText = 'color: #666; font-style: italic; display: flex; align-items: center; gap: 8px;';
            chatHistory.appendChild(loadingDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;
            return loadingDiv;
        }

        /**
         * Preload an Ollama model when selected
         * @param {string} modelId - The model ID to preload
         */
        function preloadOllamaModel(modelId) {
            if (modelLoadingInProgress) {
                console.log('Model loading already in progress, skipping');
                return;
            }

            modelLoadingInProgress = true;
            aiModelSelector.disabled = true;

            var loadingMsg = showModelLoadingMessage('Loading model ' + modelId + '... (this may take a moment)');

            fetch('/api/preload_model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model_id: modelId })
            })
            .then(function(response) { return response.json(); })
            .then(function(result) {
                // Remove loading message
                if (loadingMsg && loadingMsg.parentNode) {
                    loadingMsg.parentNode.removeChild(loadingMsg);
                }

                // Show result message
                var chatHistory = document.getElementById('chat-history');
                var resultDiv = document.createElement('div');
                resultDiv.className = 'assistant-message';

                if (result.status === 'success') {
                    if (result.data && result.data.already_loaded) {
                        resultDiv.innerHTML = '<em>Model ' + modelId + ' is ready.</em>';
                    } else {
                        resultDiv.innerHTML = '<em>Model ' + modelId + ' loaded successfully.</em>';
                    }
                    resultDiv.style.color = '#4a9';
                } else {
                    resultDiv.innerHTML = '<em>Warning: ' + (result.message || 'Failed to load model') + '</em>';
                    resultDiv.style.color = '#a94';
                }
                resultDiv.style.fontStyle = 'italic';
                chatHistory.appendChild(resultDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;

                // Auto-remove the message after 5 seconds
                setTimeout(function() {
                    if (resultDiv && resultDiv.parentNode) {
                        resultDiv.style.transition = 'opacity 0.5s';
                        resultDiv.style.opacity = '0';
                        setTimeout(function() {
                            if (resultDiv && resultDiv.parentNode) {
                                resultDiv.parentNode.removeChild(resultDiv);
                            }
                        }, 500);
                    }
                }, 5000);
            })
            .catch(function(error) {
                console.error('Failed to preload model:', error);
                if (loadingMsg && loadingMsg.parentNode) {
                    loadingMsg.parentNode.removeChild(loadingMsg);
                }
            })
            .finally(function() {
                modelLoadingInProgress = false;
                aiModelSelector.disabled = false;
            });
        }

        /**
         * Handle model selection change - updates vision toggle and preloads Ollama models
         */
        function handleModelChange() {
            updateVisionToggle();

            var selectedModel = aiModelSelector.value;
            if (OLLAMA_MODELS.includes(selectedModel)) {
                preloadOllamaModel(selectedModel);
            }
        }

        // Update vision toggle and preload when AI model selection changes
        aiModelSelector.addEventListener("change", handleModelChange);
        
        // ===== LOGOUT FUNCTIONALITY =====
        // Show logout button when authentication is enabled
        function checkAuthRequirement() {
            // Check if we need to show logout button by making a request to auth status endpoint
            fetch('/auth_status')
                .then(response => response.json())
                .then(data => {
                    console.log('Auth status response:', data); // Debug log
                    
                    // Check if authentication is required
                    const authRequired = data && data.data && data.data.auth_required;
                    
                    if (authRequired) {
                        console.log('Authentication required - showing logout button'); // Debug log
                        document.getElementById('logout-button-overlay').style.display = 'flex';
                    } else {
                        console.log('Authentication not required - hiding logout button'); // Debug log
                        document.getElementById('logout-button-overlay').style.display = 'none';
                    }
                })
                .catch((error) => {
                    console.error('Error checking auth status:', error); // Debug log
                    // If there's an error, hide the logout button (safer default)
                    document.getElementById('logout-button-overlay').style.display = 'none';
                });
        }
        
        // Check auth requirement on page load
        checkAuthRequirement();
        
        // Handle logout button click
        document.getElementById('logout-button-overlay').addEventListener('click', function() {
            if (confirm('Are you sure you want to logout?')) {
                window.location.href = '/logout';
            }
        });
        
        // ===== MOBILE KEYBOARD HANDLING =====
        // Detect virtual keyboard opening/closing and adjust UI
        var chatInputContainer = document.querySelector('.chat-input-container');
        var chatInput = document.getElementById('chat-input');
        var chatContainer = document.querySelector('.chat-container');
        var initialViewportHeight = window.innerHeight;
        var isKeyboardOpen = false;
        var originalScrollTop = 0;
        
        /**
         * Detects virtual keyboard state and adjusts UI accordingly
         */
        function handleViewportChange() {
            var currentViewportHeight = window.innerHeight;
            var heightDifference = initialViewportHeight - currentViewportHeight;
            
            // Threshold for detecting keyboard (150px+ indicates keyboard)
            var keyboardThreshold = 150;
            
            if (heightDifference > keyboardThreshold && !isKeyboardOpen) {
                // Keyboard opened
                isKeyboardOpen = true;
                originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                
                chatInputContainer.classList.add('keyboard-open');
                document.body.style.overflow = 'hidden'; // Prevent scrolling
                
                // Ensure input stays visible and centered
                setTimeout(function() {
                    chatInput.focus();
                    // Scroll to top to ensure input is visible
                    window.scrollTo(0, 0);
                }, 100);
                
            } else if (heightDifference <= keyboardThreshold && isKeyboardOpen) {
                // Keyboard closed - restore original state
                isKeyboardOpen = false;
                chatInputContainer.classList.remove('keyboard-open');
                document.body.style.overflow = ''; // Restore scrolling
                
                // Restore original scroll position
                setTimeout(function() {
                    window.scrollTo(0, originalScrollTop);
                }, 100);
            }
        }
        
        /**
         * Handle input focus - prepare for keyboard opening
         */
        function handleInputFocus() {
            // Store current scroll position
            originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            
            // Small delay to detect if keyboard will open
            setTimeout(function() {
                var currentHeight = window.innerHeight;
                if (currentHeight < initialViewportHeight * 0.85) {
                    // Keyboard is opening, ensure input is visible
                    window.scrollTo(0, 0);
                }
            }, 300);
        }
        
        /**
         * Handle input blur - prepare for keyboard closing
         */
        function handleInputBlur() {
            // Small delay to allow keyboard to close
            setTimeout(function() {
                if (!isKeyboardOpen) {
                    // Keyboard has closed, restore state
                    document.body.style.overflow = '';
                    window.scrollTo(0, originalScrollTop);
                }
            }, 300);
        }
        
        // Listen for viewport changes (keyboard open/close)
        window.addEventListener('resize', handleViewportChange);
        window.addEventListener('orientationchange', function() {
            setTimeout(function() {
                initialViewportHeight = window.innerHeight;
                handleViewportChange();
            }, 500);
        });
        
        // Listen for input focus and blur
        chatInput.addEventListener('focus', handleInputFocus);
        chatInput.addEventListener('blur', handleInputBlur);
        
        // Enhanced visual viewport API handling (newer browsers)
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', function() {
                var keyboardHeight = window.innerHeight - window.visualViewport.height;
                
                if (keyboardHeight > 150 && !isKeyboardOpen) {
                    isKeyboardOpen = true;
                    originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                    
                    chatInputContainer.classList.add('keyboard-open');
                    document.body.style.overflow = 'hidden';
                    window.scrollTo(0, 0);
                    
                } else if (keyboardHeight <= 150 && isKeyboardOpen) {
                    isKeyboardOpen = false;
                    chatInputContainer.classList.remove('keyboard-open');
                    document.body.style.overflow = '';
                    
                    // Restore scroll position
                    setTimeout(function() {
                        window.scrollTo(0, originalScrollTop);
                    }, 100);
                }
            });
        }
    });
    </script>

    <!-- Resize separator functionality for dragging between canvas and chat -->
    <script>
    (function() {
        var separator = document.getElementById('resize-separator');
        var mathContainer = document.getElementById('math-container');
        var chatContainer = document.querySelector('.chat-container');
        var chatInputContainer = document.querySelector('.chat-input-container');
        var selectionContainer = document.querySelector('.selection-container');

        var isDragging = false;
        var startPos = 0;
        var startMathSize = 0;
        var startChatSize = 0;

        // Threshold width for very-narrow (vertical button stacking)
        var VERY_NARROW_THRESHOLD = 280;

        function isVerticalLayout() {
            return window.innerWidth <= 1024;
        }

        function updateNarrowState() {
            // Only apply narrow state in desktop (horizontal) layout
            if (!isVerticalLayout()) {
                var chatWidth = chatContainer.offsetWidth;
                // Use chat-input-row if it exists (new structure), otherwise fall back to chat-input
                var chatInputRow = chatInputContainer.querySelector('.chat-input-row') || chatInputContainer.querySelector('.chat-input');
                var chatButtons = chatInputContainer.querySelector('.chat-buttons');

                // Temporarily remove narrow to check natural wrap state
                chatInputContainer.classList.remove('narrow');
                chatInputContainer.classList.remove('very-narrow');

                // Check if buttons have wrapped to a new line
                var buttonsWrapped = chatButtons.offsetTop > chatInputRow.offsetTop;

                if (chatWidth < VERY_NARROW_THRESHOLD) {
                    chatInputContainer.classList.add('narrow');
                    chatInputContainer.classList.add('very-narrow');
                    selectionContainer.classList.add('narrow');
                    selectionContainer.classList.add('very-narrow');
                } else if (buttonsWrapped) {
                    chatInputContainer.classList.add('narrow');
                    selectionContainer.classList.add('narrow');
                    selectionContainer.classList.remove('very-narrow');
                } else {
                    selectionContainer.classList.remove('narrow');
                    selectionContainer.classList.remove('very-narrow');
                }
            } else {
                // In vertical layout, never use narrow state
                chatInputContainer.classList.remove('narrow');
                chatInputContainer.classList.remove('very-narrow');
                selectionContainer.classList.remove('narrow');
                selectionContainer.classList.remove('very-narrow');
            }
        }

        separator.addEventListener('mousedown', startDrag);
        separator.addEventListener('touchstart', startDrag, { passive: false });

        function startDrag(e) {
            e.preventDefault();
            isDragging = true;
            separator.classList.add('dragging');
            document.body.style.cursor = isVerticalLayout() ? 'row-resize' : 'col-resize';
            document.body.style.userSelect = 'none';

            var pos = e.type.includes('touch') ? e.touches[0] : e;
            startPos = isVerticalLayout() ? pos.clientY : pos.clientX;
            startMathSize = isVerticalLayout() ? mathContainer.offsetHeight : mathContainer.offsetWidth;
            startChatSize = isVerticalLayout() ? chatContainer.offsetHeight : chatContainer.offsetWidth;

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();

            var pos = e.type.includes('touch') ? e.touches[0] : e;
            var currentPos = isVerticalLayout() ? pos.clientY : pos.clientX;
            var delta = currentPos - startPos;

            var minMathSize = 400; // Must match CSS .math-container min-width
            var minChatSize = 200;

            var newMathSize = startMathSize + delta;
            var newChatSize = startChatSize - delta;

            // Don't allow either to go below minimum - just stop
            if (newMathSize < minMathSize || newChatSize < minChatSize) {
                return;
            }

            if (isVerticalLayout()) {
                mathContainer.style.height = newMathSize + 'px';
                mathContainer.style.flex = 'none';
                chatContainer.style.minHeight = newChatSize + 'px';
            } else {
                mathContainer.style.width = newMathSize + 'px';
                mathContainer.style.flex = 'none';
                chatContainer.style.width = newChatSize + 'px';
                chatContainer.style.flexShrink = '0';
            }

            // Update narrow state for button stacking
            updateNarrowState();

            // Redraw canvas with new dimensions (use requestAnimationFrame to ensure layout is computed)
            requestAnimationFrame(function() {
                if (typeof window.redrawMatHudCanvas === 'function') {
                    window.redrawMatHudCanvas();
                }
            });
        }

        function stopDrag() {
            isDragging = false;
            separator.classList.remove('dragging');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        // Reset custom sizes on orientation/breakpoint change
        var lastIsVertical = isVerticalLayout();
        window.addEventListener('resize', function() {
            var nowVertical = isVerticalLayout();
            if (nowVertical !== lastIsVertical) {
                mathContainer.style.width = '';
                mathContainer.style.height = '';
                mathContainer.style.flex = '';
                chatContainer.style.width = '';
                chatContainer.style.minHeight = '';
                chatContainer.style.flexShrink = '';
                lastIsVertical = nowVertical;
            }
            // Update narrow state on any resize
            updateNarrowState();
            // Redraw canvas with new dimensions (use requestAnimationFrame to ensure layout is computed)
            requestAnimationFrame(function() {
                if (typeof window.redrawMatHudCanvas === 'function') {
                    window.redrawMatHudCanvas();
                }
            });
        });

        // Initialize narrow state on load
        updateNarrowState();
    })();
    </script>
</body>
</html>