# MatHud - Mathematical Heads-Up Display

MathHud is an interactive mathematical visualization tool that combines a drawing canvas with an AI assistant to help understand and solve real-world mathematical problems. It serves as a heads-up display system for mathematical analysis, allowing users to visualize, analyze, and solve problems in real-time.

## Key Features
- Interactive SVG-based drawing canvas
- AI-powered mathematical assistant
- Real-time geometric visualization and analysis
- Support for mathematical expressions and calculations
- Visual problem-solving with multimodal AI
- Real-world problem analysis and modeling
- Workspace management for saving and loading states
- Rich text chat interface with with comprehensive markdown support and LaTeX mathematical notation rendering

## Mathematical Functions
- Basic Arithmetic: addition, subtraction, multiplication, division, exponents, roots
- Trigonometric Functions: sin, cos, tan, arcsin, arccos, arctan
- Logarithmic Functions: natural log, log base 10, log with custom base
- Statistical Functions: mean, median, mode, standard deviation, variance
- Calculus Operations: derivatives, integrals, limits
- Complex Numbers: operations with real and imaginary components
- Graphing Functions: plot functions, parametric equations, polar coordinates
- Geometric Calculations: distance, angle, area, volume, intersections
- Equation Solving: linear equations, quadratic equations, systems of equations
- Advanced Operations: 40+ AI tool definitions available in `static/functions_definitions.py` including canvas operations, geometric shape creation/deletion, mathematical operations, transformations, and workspace management

## Geometric Shape Management
- Points: create, delete, translate points with coordinates and labels
- Segments: create line segments between points, calculate length and midpoint
- Vectors: create vectors with origin and tip, support for vector operations
- Triangles: create from three points, calculate area, centroid, and angles
- Rectangles: create from diagonal points, validate right angles, calculate area
- Circles: create with center and radius, calculate area and circumference
- Ellipses: create with center and radii, support rotation and transformation
- Angles: create from three points (vertex and two defining points), calculate measure, and display arcs.

## Drawing and Visualization
- Interactive SVG Canvas: real-time drawing and manipulation
- Coordinate System: automatic scaling and axis management
- Shape Transformations: translate, rotate, and scale geometric objects
- Function Plotting: adaptive resolution based on zoom level
- Visual Feedback: color-coded shapes and labels
- Undo/Redo: track and reverse drawing operations
- Workspace Management: save and load canvas states with metadata

## Multi-Step Calculations
- Expressions: evaluate mathematical expressions and functions
- Step-by-Step Problem Solving: break down complex problems
- Intermediate Results: display partial calculations
- Expression Validation: check mathematical syntax and semantics
- Unit Conversions: support for various measurement units
- State Management: track calculation history and dependencies
- Error Handling: graceful recovery from invalid operations

## Vision Mechanism
The application includes a visual understanding system that allows the AI to analyze both drawn elements and real-world mathematical scenarios through:
- Real-time canvas state monitoring
- Interpretation of mathematical drawings and diagrams
- Analysis of imported real-world problem images
- Context-aware mathematical reasoning

## Chat Interface and Markdown Support
The application features a sophisticated chat interface with comprehensive markdown rendering capabilities:

### Markdown Features
- **Headers**: H1-H6 support using `#` through `######` syntax
- **Text Formatting**: 
  - Bold text using `**bold**` or `__bold__` syntax
  - Italic text using `*italic*` or `_italic_` syntax
  - Strikethrough text using `~~strikethrough~~` syntax
- **Code**: Inline code with backticks and code blocks with triple backticks
- **Lists**: 
  - Ordered and unordered lists with proper nesting support
  - Checkbox lists with `- [x]` (checked) and `- [ ]` (unchecked) syntax
- **Tables**: Full markdown table support with headers and styling
- **Links**: Standard `[text](url)` link syntax
- **Mathematical Expressions**: 
  - Inline LaTeX using `\(expression\)` syntax
  - Block LaTeX using `$$expression$$` syntax
  - Powered by MathJax 3.0 for professional mathematical notation rendering
- **Other Elements**: Blockquotes, horizontal rules, and mixed content support

### Technical Implementation
- **Dedicated Parser**: `markdown_parser.py` module with `MarkdownParser` class
- **LaTeX Rendering**: MathJax 3.0 integration for real-time mathematical expression rendering
- **Smart Processing**: Two-phase parsing to avoid infinite loops and conflicts
- **CSS Integration**: Comprehensive styling for all markdown elements
- **Real-time Updates**: Automatic rendering of new chat messages with full markdown support

---

# Project File Structure

## Root Directory
```
MatHud/
├── app.py                              # Main Flask application entry point
├── requirements.txt                    # Python dependencies (Flask, OpenAI, Selenium, etc.)
├── README.md                          # Project documentation and setup instructions
├── run_server_tests.py                # Server-side test runner script
├── .gitignore                         # Git ignore patterns
├── LICENSE                            # Project license
├── Documentation/                     # Project documentation folder
│   ├── Project Architecture.txt       # Comprehensive technical documentation (this file)
│   ├── Reference Manual.txt           # Detailed reference manual
│   ├── Example Prompts.txt            # Sample AI prompts for testing
│   └── todo.txt                       # Development tasks and improvements
├── logs/                              # Application log files (session-based)
├── workspaces/                        # Saved workspace JSON files
├── CanvasSnapshots/                   # Vision system canvas screenshots
├── server_tests/                       # Server-side test files
├── templates/                         # HTML templates
├── static/                            # Backend Python modules and frontend assets
├── venv/                              # Python virtual environment
└── .vscode/                           # VS Code configuration
```

## Backend Structure (`static/`)
```
static/
├── app_manager.py                     # Flask application configuration and initialization
├── routes.py                          # All Flask route definitions (/send_message, /save_workspace, etc.)
├── openai_api.py                      # OpenAI API integration and chat completions
├── webdriver_manager.py               # Selenium WebDriver management for vision system
├── workspace_manager.py               # Server-side workspace file operations
├── log_manager.py                     # Application logging system
├── functions_definitions.py           # 42 AI function/tool definitions
├── ai_model.py                        # AI model configuration utilities
├── tool_call_processor.py             # Tool call processing utilities
├── style.css                          # Frontend CSS styling
└── python/                           # Custom Python modules for Brython (moved from Brython-3.11.3/Lib/site-packages/)
    # Note: Brython core (3.12.5), Math.js (14.5.2), and Nerdamer (1.1.13) now loaded from CDN
```

## Frontend Structure (`templates/` and Brython Client-Side)
```
templates/
└── index.html                         # Main HTML template with canvas and chat interface

static/python/
├── main.py                            # Brython initialization and entry point
├── ai_interface.py                    # AI communication and UI management
├── markdown_parser.py                 # Comprehensive markdown parser with LaTeX support
├── canvas_event_handler.py            # Mouse/keyboard event handling with extensive error handling
├── canvas.py                          # Core SVG canvas management
├── workspace_manager.py               # Client-side workspace operations
├── function_registry.py               # Available function mapping and registration
├── process_function_calls.py          # Function call facade pattern implementation
├── result_processor.py                # Function call execution engine
├── expression_evaluator.py            # Mathematical expression evaluation
├── expression_validator.py            # Expression syntax validation
├── result_validator.py                # Result validation utilities
├── cartesian_system_2axis.py          # 2D coordinate system management
├── test_runner.py                     # Client-side test execution framework
├── constants.py                       # Application constants
├── geometry.py                        # Geometric utility functions
├── drawables/                         # Drawable object implementations
│   ├── drawable.py                    # Base drawable class
│   ├── point.py                       # Point geometric object
│   ├── segment.py                     # Line segment object
│   ├── vector.py                      # Vector object
│   ├── triangle.py                    # Triangle object
│   ├── rectangle.py                   # Rectangle object
│   ├── circle.py                      # Circle object
│   ├── ellipse.py                     # Ellipse object
│   ├── angle.py                       # Angle object
│   ├── function.py                    # Function plotting object
│   ├── colored_area.py                # Colored area object
│   ├── functions_bounded_colored_area.py        # Function-bounded areas
│   ├── function_segment_bounded_colored_area.py # Mixed boundary areas
│   ├── segments_bounded_colored_area.py         # Segment-bounded areas
│   ├── rotatable_polygon.py           # Rotatable polygon base class
│   └── position.py                    # Position utility class
├── managers/                          # Specialized object managers
│   ├── drawable_manager.py            # Central drawable orchestrator
│   ├── drawable_manager_proxy.py      # Initialization dependency management
│   ├── drawables_container.py         # Drawable storage and organization
│   ├── drawable_dependency_manager.py # Object dependency tracking
│   ├── undo_redo_manager.py           # Undo/redo functionality
│   ├── transformations_manager.py     # Geometric transformations
│   ├── point_manager.py               # Point creation/management
│   ├── segment_manager.py             # Segment operations
│   ├── vector_manager.py              # Vector operations
│   ├── triangle_manager.py            # Triangle operations
│   ├── rectangle_manager.py           # Rectangle operations
│   ├── circle_manager.py              # Circle operations
│   ├── ellipse_manager.py             # Ellipse operations
│   ├── angle_manager.py               # Angle operations
│   ├── function_manager.py            # Function plotting management
│   └── colored_area_manager.py        # Colored area management
├── utils/                             # Utility modules
│   ├── math_utils.py                  # Mathematical utility functions
│   ├── computation_utils.py           # Computational helper functions
│   ├── geometry_utils.py              # Geometric utility functions
│   └── style_utils.py                 # Style and UI utility functions
├── name_generator/                    # Automatic name generation for objects
│   ├── base.py                        # Base name generator class
│   ├── drawable.py                    # General drawable object name generation
│   ├── point.py                       # Point-specific name generation
│   └── function.py                    # Function name generation
└── client_tests/                       # Brython-based client-side tests
    ├── tests.py                       # Test suite orchestrator
    ├── test_canvas.py                 # Canvas functionality tests
    ├── test_math_functions.py         # Mathematical operation tests
    ├── test_function_calling.py       # Function call system tests
    ├── test_angle_manager.py          # Angle management tests
    ├── test_angle.py                  # Angle object tests
    ├── test_drawable_dependency_manager.py  # Dependency system tests
    ├── test_drawables_container.py    # Container tests
    ├── test_custom_drawable_names.py  # Name generation tests
    ├── test_drawable_name_generator.py # Name generator tests
    ├── test_cartesian.py              # Coordinate system tests
    ├── test_event_handler.py          # Event handling tests
    ├── test_expression_validator.py   # Expression validation tests
    ├── test_function.py               # Function object tests
    ├── test_[shape].py                # Individual shape tests (point, segment, etc.)
    ├── ai_result_formatter.py         # Test result formatting for AI
    ├── brython_io.py                  # Brython I/O utilities
    └── simple_mock.py                 # Testing mock utilities
```

## Server-Side Tests (`server_tests/`)
```
server_tests/
├── __init__.py                        # Test package initialization
├── python_path_setup.py               # Test environment configuration
├── test_mocks.py                      # Server-side test mocking utilities
├── test_workspace_management.py       # Workspace operations tests
└── test_routes.py                     # Flask route testing
```

## Key Configuration Files
- **`requirements.txt`**: Contains 5 dependencies: openai, flask, python-dotenv, selenium, geckodriver-autoinstaller
- **`.env`**: Environment variables (OpenAI API key) - created by user in parent directory
- **`app.py`**: Main entry point including threaded server startup and graceful shutdown handling
- **`static/functions_definitions.py`**: Defines 42 AI functions with full JSON schema
- **`templates/index.html`**: Main HTML template with canvas, chat interface, AI model selector, and vision toggle

## Data Directories
- **`logs/`**: Session-based application logs with timestamps
- **`workspaces/`**: JSON files containing saved canvas states and metadata
- **`CanvasSnapshots/`**: PNG screenshots captured by WebDriver for vision processing
- **`__pycache__/`**: Python bytecode cache directories throughout the project

## Architecture Notes
- **Brython Integration**: Extensive use of Python in the browser via Brython 3.12.5 framework (CDN)
- **Facade Pattern**: `ProcessFunctionCalls` acts as facade for `ResultProcessor`, `ExpressionEvaluator`, `ResultValidator`
- **Manager Pattern**: Specialized managers for each geometric shape type with centralized coordination
- **Error Handling**: Comprehensive try-catch blocks throughout client-side code
- **Testing**: Dual testing system with server-side pytest and client-side Brython unittest
- **Vision System**: Server-side Selenium WebDriver captures canvas screenshots for AI vision analysis

---

# Technical Architecture

## Frontend Chat Interface (index.html in `templates/` and `static/python/main.py`)
- Simple HTML structure with chat history div, input field, and send button (ID: `send-button`).
- Chat interface bound to both button click and Enter key events.
- Vision toggle checkbox for canvas image capture control.
- AI model selector with options: GPT-4.1, GPT-4.1 Mini, GPT-4.1 Nano, GPT-4o, GPT-4o Mini, GPT-3.5 Turbo etc.
- Uses Brython (Python in the browser) for frontend logic, initialized by `main.py`.
- **MathJax 3.0 Integration**: Automatic LaTeX rendering for mathematical expressions in chat messages.
- **Comprehensive Markdown Support**: Real-time rendering of headers, lists, tables, code blocks, and formatted text.
- `static/python/canvas_event_handler.py` manages user interactions with the canvas.

## AI Interface Layer (`static/python/ai_interface.py`)
- Core class `AIInterface` manages Brython-side communication between UI and backend.
- Instantiated in `main.py` and receives events from `CanvasEventHandler`.
- Initializes client-side `WorkspaceManager` (from `static/python/workspace_manager.py`) and `FunctionRegistry`.
- **Markdown Integration**: Initializes `MarkdownParser` for comprehensive text formatting and LaTeX rendering.
- Maintains dictionary of available functions for math operations and canvas manipulation (via `FunctionRegistry`).
- Handles function call results and maintains state between interactions.
- **UI Element References**: References `send-button` for button control, `chat-input` for input field, `vision-toggle` for vision checkbox, and `ai-model-selector` for model selection.
- Key methods:
  - `interact_with_ai`: Entry point for user interactions from UI.
  - `_send_prompt_to_ai`: Prepares JSON prompt (with canvas state, user message, tool results, vision settings from `document["vision-toggle"]`, AI model from `document["ai-model-selector"]`) and sends AJAX POST request to `/send_message` Flask endpoint.
  - `_process_ai_response`: Processes AI responses from backend. If tool calls are present, uses `ProcessFunctionCalls.get_results` and then sends results back to AI via `_send_prompt_to_ai`.
  - `_parse_markdown_to_html`: Converts markdown text to HTML using the dedicated `MarkdownParser`.
  - `_render_math`: Triggers MathJax rendering for newly added mathematical expressions.
  - `_create_message_element`: Creates styled message elements with markdown support for chat display.
  - (Workspace operations like `save_workspace` are invoked via function calls processed by `ProcessFunctionCalls` which then use the client-side `WorkspaceManager` instance).

## Client-Side Brython Managers (in `static/python/managers/`)
- A suite of manager classes, running in the Brython environment, handle the detailed logic for canvas objects and operations.
- **`DrawableManager`**: Central orchestrator for all drawable objects. It coordinates the specialized managers listed below. Instantiated by `Canvas`.
- **Specialized Drawable Managers**:
  - `PointManager`: Manages point objects.
  - `SegmentManager`: Manages line segment objects.
  - `VectorManager`: Manages vector objects.
  - `TriangleManager`: Manages triangle objects.
  - `RectangleManager`: Manages rectangle objects.
  - `CircleManager`: Manages circle objects.
  - `EllipseManager`: Manages ellipse objects.
  - `AngleManager`: Manages angle objects.
  - `FunctionManager`: Manages plotted functions.
  - `ColoredAreaManager`: Manages colored areas.
- **Supporting Managers**:
  - `UndoRedoManager`: Manages undo and redo operations for canvas actions.
  - `TransformationsManager`: Manages geometric transformations of objects.
  - `DrawableDependencyManager`: Tracks dependencies between drawable objects.
  - `DrawableManagerProxy`: A proxy to help manage initialization dependencies for `DrawableManager`.
  - `DrawablesContainer`: A data structure used by `DrawableManager` to hold drawable instances.
- These managers are responsible for creating, deleting, updating, and querying drawable objects on the canvas, and are used by `ProcessFunctionCalls` when executing drawing-related function calls.

## Workspace Management
- **Client-Side Workspace Interactions (`static/python/workspace_manager.py`)**:
  - A `WorkspaceManager` class, instantiated by `AIInterface` and running in Brython.
  - Provides methods (`save_workspace`, `load_workspace`, `list_workspaces`, `delete_workspace`) that make synchronous AJAX calls to the respective Flask backend endpoints (e.g., `/save_workspace`, `/load_workspace`).
  - For `load_workspace`, it receives canvas state from the backend and uses methods like `_restore_workspace_state` to repopulate the Brython-managed canvas by calling appropriate `Canvas` methods.
- **Server-Side Workspace Management (`static/workspace_manager.py`)**:
  - A `WorkspaceManager` class (used by `app.py`) that handles actual workspace file operations on the server.
  - Responds to AJAX calls from the client-side `WorkspaceManager` via Flask routes.
  - Saves canvas states (received from client) with metadata and timestamps to JSON files in the `workspaces/` directory.
  - Supports named workspaces and timestamped unnamed saves (e.g., `current_workspace_YYYYMMDD_HHMMSS.json`).
  - Performs file system operations, path validation (ensuring operations are within the `workspaces/` directory), and manages directory structure.
  - Handles loading workspace data from JSON files and sending it to the client.
  - Provides logic for listing and safely deleting workspace files.
  - Key features: JSON-based storage, automatic timestamping, metadata tracking, directory management, safe file operations.

## Backend API (`app.py`, `static/app_manager.py`, `static/routes.py`, `static/openai_api.py`, `static/webdriver_manager.py`, `static/log_manager.py`)
- **Flask Application Core (`app.py`, `static/app_manager.py`, `static/routes.py`)**:
  - `app.py`: Main entry point for the Flask server. Initializes the application using `AppManager` and starts the server. Handles graceful shutdown (e.g., cleaning up `WebDriverManager`).
  - `static/app_manager.py`: Contains `AppManager` class responsible for creating and configuring the Flask `app` object. Initializes server-side managers (like `LogManager`, `OpenAIChatCompletionsAPI`, server-side `WorkspaceManager`, and `WebDriverManager`).
  - `static/routes.py`: Defines all Flask routes (e.g., `/`, `/send_message`, `/save_workspace`, `/load_workspace`, `/list_workspaces`, `/delete_workspace`, `/init_webdriver`). Imported and registered by `AppManager`.
- **AI Communication (`static/openai_api.py`)**:
  - `OpenAIChatCompletionsAPI` class manages all interactions with the OpenAI API.
  - Initializes with API key, model details, and available tools/functions (from `static.functions_definitions`).
  - `create_chat_completion` method constructs the payload and sends requests to OpenAI. Handles conversation history.
  - If vision is enabled (based on image data being prepared by `routes.py`), it includes the image data in the request to OpenAI's vision-capable models.
- **Vision Image Capture (`static/webdriver_manager.py`)**:
  - `WebDriverManager` class uses Selenium WebDriver (headless Firefox) to capture canvas images.
  - Instantiated by `AppManager` (initialization triggered via `/init_webdriver` route if needed).
  - `capture_svg_state` method: Receives SVG content and dimensions from the client (via `routes.py`), loads this into the headless browser, and takes a screenshot, saving it to `CanvasSnapshots/canvas.png`.
  - Handles WebDriver setup, page configuration, and cleanup.
- **Server-Side Logging (`static/log_manager.py`)**:
  - `LogManager` class handles application logging on the server.
  - Configures session-based log files with timestamped entries in the `logs/` directory.

## Function Call Processing (`static/python/process_function_calls.py`)
- `ProcessFunctionCalls` class (Brython client-side) acts as a **facade pattern** for executing function calls requested by the AI.
- It is invoked by `AIInterface`'s `_process_ai_response` method.
- Key static methods:
  - `get_results`: Delegates to `ResultProcessor` (in `static/python/result_processor.py`) to iterate through tool calls, execute them using the `available_functions` map (from `FunctionRegistry`), and collect results. `ResultProcessor` interacts with `DrawableManager`, specific drawable managers, `Canvas`, client-side `WorkspaceManager`, etc., to perform actions.
  - `evaluate_expression`: Delegates to `ExpressionEvaluator` (in `static/python/expression_evaluator.py`).
- `validate_results` and `is_successful_result`: Delegate to `ResultValidator` (in `static/python/result_validator.py`).
- Execution of drawing operations, canvas manipulations, and client-side workspace calls are routed through this system.
- Undo/redo capabilities are coordinated by `ResultProcessor` potentially interacting with `UndoRedoManager` and `Canvas.archive()`.

## Canvas System
- Uses SVG for rendering mathematical objects and functions, manipulated via Brython.
- The client-side `Canvas` class (in `static/python/canvas.py`) is the core for drawing.
- It instantiates and uses `DrawableManager` (from `static/python/managers/drawable_manager.py`) to manage all visual elements.
- `DrawableManager` coordinates specialized managers (e.g., `PointManager`, `SegmentManager`) for creating, updating, and deleting specific geometric shapes and functions.
- Supports zooming, panning, and coordinate system transformations (handled by `Canvas` and `cartesian_system_2axis.py`).
- Object state for undo/redo is managed by `UndoRedoManager` in conjunction with `DrawableManager` and `Canvas` (e.g., `Canvas.archive()` for saving states).
- Handles real-time updates and user interactions via `CanvasEventHandler` which dispatches to `AIInterface` or `Canvas` methods.
- Provides canvas state serialization (`Canvas.get_canvas_state()`) for workspace saving and for sending to the backend for vision processing.

## Geometric Shape Management (Client-Side Brython)
- Handled on the client-side (Brython) by a suite of specialized manager classes within `static/python/managers/`, coordinated by `DrawableManager`.
- **Drawable Objects**: Actual drawable classes are defined in `static/python/drawables/` including:
  - `Point`, `Segment`, `Vector`, `Triangle`, `Rectangle`, `Circle`, `Ellipse`, `Angle`, `Function`, `ColoredArea`
  - Additional specialized classes like `FunctionsBoundedColoredArea`, `FunctionSegmentBoundedColoredArea`, `SegmentsBoundedColoredArea`
- **Points**: Managed by `PointManager`. Create, delete, translate points with coordinates and labels.
- **Segments**: Managed by `SegmentManager`. Create line segments between points, calculate length and midpoint.
- **Vectors**: Managed by `VectorManager`. Create vectors with origin and tip, support for vector operations.
- **Triangles**: Managed by `TriangleManager`. Create from three points, calculate area, centroid, and angles.
- **Rectangles**: Managed by `RectangleManager`. Create from diagonal points, validate right angles, calculate area.
- **Circles**: Managed by `CircleManager`. Create with center and radius, calculate area and circumference.
- **Ellipses**: Managed by `EllipseManager`. Create with center and radii, support rotation and transformation.
- **Angles**: Managed by `AngleManager`. Create from three points (vertex and two other points defining the rays), calculate measure in degrees or radians, and visually represent with an arc.
- **Functions**: Plotted functions are managed by `FunctionManager`.
- **Colored Areas**: Managed by `ColoredAreaManager`.
- Dependencies between shapes (e.g., a segment depends on its points) are tracked by `DrawableDependencyManager`.

## Error Handling and Logging
- **Client-Side (Brython)**: Extensive error handling with try-catch blocks throughout the codebase, particularly in:
  - `CanvasEventHandler`: Every method includes comprehensive error handling for user interactions
  - `AIInterface`: Error handling for AJAX requests, function call processing, and UI state management
  - `WorkspaceManager`: Error handling for workspace operations and AJAX calls
  - Error messages from function calls or AJAX requests are displayed in the chat interface. JavaScript console logs for Brython-specific issues.
- **Server-Side (Flask)**:
  - `static/log_manager.py` (`LogManager` class) provides comprehensive logging for debugging and session tracking.
  - Session-based log files with timestamped entries are created in the `logs/` directory.
  - Flask's built-in error handling for HTTP errors. API responses use a consistent JSON structure (`AppManager.make_response`) to report success or errors.
- Graceful fallbacks for vision system failures (e.g., if `WebDriverManager` fails to capture image, vision process might be skipped or an error reported).

## Vision Integration
- **Client Trigger**: `AIInterface` (Brython client-side) checks the vision toggle status and includes a `use_vision: true/false` flag and the current `svg_state` (content and dimensions) in the JSON payload to the `/send_message` backend endpoint.
- **Server-Side Image Capture**: 
  - The Flask `/send_message` route (in `static/routes.py`) receives the request.
  - If `use_vision` is true and `svg_state` is provided:
    1. It ensures `WebDriverManager` is initialized.
    2. It calls `app.webdriver_manager.capture_svg_state(svg_state)`.
    3. `WebDriverManager` uses Selenium to launch a headless Firefox browser, injects the received `svg_state` (content, dimensions, viewBox, transform) into the `math-svg` element of the application's page loaded in the headless browser, and adjusts container styles.
    4. A screenshot of the relevant math container div is taken and saved as `CanvasSnapshots/canvas.png`.
- **AI Processing**: 
  - `OpenAIChatCompletionsAPI` (server-side), when preparing the call to OpenAI and if vision is active for the request, reads `CanvasSnapshots/canvas.png`, encodes it (e.g., base64), and includes it in the multimodal prompt to the OpenAI API.
- **Contextual Analysis**: The AI then analyzes both the textual prompt (user message, previous calculations from canvas state) and the visual context from the canvas image.
- **Error Handling**: If image capture fails, the vision step might be skipped, and the AI would proceed with text-only context, or an error is reported.

## Function Call Flow
1. User sends message via UI → `CanvasEventHandler` captures event, calls `AIInterface.interact_with_ai`.
2. `AIInterface._print_user_message_in_chat` updates UI.
3. `AIInterface._send_prompt_to_ai` bundles `user_message`, `canvas_state` (from `Canvas.get_canvas_state()`), `use_vision` flag, and current `ai_model` into a JSON prompt.
4. `AIInterface` sends AJAX POST request to Flask backend (`/send_message`) with this JSON prompt and, if `use_vision` is false or SVG state is not needed immediately by backend, also sends `svg_state` (SVG content & dimensions from `document["math-svg"]`).
5. Flask backend (`static/routes.py` - `/send_message`):
   a. Receives JSON prompt and `svg_state`.
   b. If `use_vision` is true:
      i. Ensures `WebDriverManager` is initialized.
      ii. Calls `app.webdriver_manager.capture_svg_state(svg_state)` to save `CanvasSnapshots/canvas.png`.
   c. Calls `app.ai_api.create_chat_completion` (from `static/openai_api.py`) with the user message, (path to) image if vision, and conversation history.
   d. `OpenAIChatCompletionsAPI` makes a call to OpenAI.
   e. OpenAI response (text, and/or tool_calls) is returned to `routes.py`.
   f. `routes.py` sends response back to client `AIInterface` (as JSON containing `ai_message`, `ai_tool_calls`, `finish_reason`).
6. Client `AIInterface._on_complete` receives response.
7. `AIInterface._process_ai_response`:
   a. If `finish_reason` is "stop" or "error": `_print_ai_message_in_chat`.
   b. If `finish_reason` is "tool_calls":
      i. `ProcessFunctionCalls.get_results` is called with `ai_tool_calls`, `available_functions` (from `FunctionRegistry`), `undoable_functions`, and `canvas`.
      ii. `ProcessFunctionCalls` delegates to `ResultProcessor`, which executes each function. Functions can be:
          - Canvas operations (e.g., `create_point`) that call methods on `DrawableManager` or specific drawable managers.
          - Math evaluations (`ExpressionEvaluator`).
          - Client-side workspace operations (e.g., `save_workspace`) that call methods on the client `WorkspaceManager`, which then makes further AJAX calls.
      iii. Results from `ProcessFunctionCalls.get_results` are collected.
      iv. `AIInterface._store_results_in_canvas_state` updates canvas computations.
      v. `AIInterface._send_prompt_to_ai` is called again, this time with `tool_call_results` (and no `user_message`), looping back to step 4 (backend forwards tool results to OpenAI).
8. Canvas is updated by the managers if drawing functions were called. Results are displayed in chat.

## Workspace Flow
1. **Save Workspace**:
   a. User requests save (e.g., via AI prompt "save workspace my_work").
   b. AI responds with a tool call: `{"function_name": "save_workspace", "arguments": {"name": "my_work"}}`.
   c. Client `AIInterface` processes this via `ProcessFunctionCalls.get_results`.
   d. `ProcessFunctionCalls` calls the registered `save_workspace` function, which is a method of the client-side `WorkspaceManager` instance.
   e. Client `WorkspaceManager.save_workspace(name="my_work")`:
      i. Gets current canvas state: `self.canvas.get_canvas_state()`.
      ii. Makes a **synchronous** AJAX POST to `/save_workspace` Flask endpoint with `{"state": <canvas_state>, "name": "my_work"}`.
   f. Server (`static/routes.py` - `/save_workspace`):
      i. Calls server-side `WorkspaceManager.save_workspace(state, name)`.
      ii. Server `WorkspaceManager` creates JSON file (e.g., `workspaces/my_work.json`) with state and metadata (timestamp).
      iii. Returns success/error status to client.
   g. Client `WorkspaceManager` method returns result string (e.g., "Workspace 'my_work' saved.").
   h. This result becomes part of `tool_call_results` sent back to AI.
2. **Load Workspace**:
   a. User requests load (e.g., "load workspace my_work").
   b. Tool call: `{"function_name": "load_workspace", "arguments": {"name": "my_work"}}`.
   c. Client `ProcessFunctionCalls` calls client `WorkspaceManager.load_workspace(name="my_work")`.
   d. Client `WorkspaceManager.load_workspace()`:
      i. Makes **synchronous** AJAX GET to `/load_workspace?name=my_work`.
   e. Server (`static/routes.py` - `/load_workspace`):
      i. Calls server-side `WorkspaceManager.load_workspace(name)`.
      ii. Server `WorkspaceManager` reads `workspaces/my_work.json`, extracts state.
      iii. Returns `{"state": <canvas_state>}` to client.
   f. Client `WorkspaceManager` receives state. Calls `self._restore_workspace_state(state)`:
      i. Clears current canvas.
      ii. Recreates drawables (points, segments etc.) using `Canvas` methods, which in turn use `DrawableManager` and its sub-managers.
      iii. Restores computations to `Canvas`.
   g. Returns result string (e.g., "Workspace 'my_work' loaded.").
3. **List Workspaces**:
   a. Tool call: `{"function_name": "list_workspaces", "arguments": {}}`.
   b. Client `ProcessFunctionCalls` calls client `WorkspaceManager.list_workspaces()`.
   c. Client `WorkspaceManager` makes **synchronous** AJAX GET to `/list_workspaces`.
   d. Server (`static/routes.py` - `/list_workspaces`):
      i. Calls server-side `WorkspaceManager.list_workspaces()`.
      ii. Returns list of workspace names.
   e. Client `WorkspaceManager` returns comma-separated string of names.
4. **Delete Workspace**:
   a. Tool call: `{"function_name": "delete_workspace", "arguments": {"name": "my_work"}}`.
   b. Client `ProcessFunctionCalls` calls client `WorkspaceManager.delete_workspace(name="my_work")`.
   c. Client `WorkspaceManager` makes **synchronous** AJAX GET to `/delete_workspace?name=my_work`.
   d. Server (`static/routes.py` - `/delete_workspace`):
      i. Calls server-side `WorkspaceManager.delete_workspace(name)`.
      ii. Server `WorkspaceManager` deletes file.
      iii. Returns success/error.
   e. Client `WorkspaceManager` returns result string.