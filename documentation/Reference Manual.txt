# MatHud Project Documentation

## Complete Reference Manual

This documentation serves as a **complete reference manual** for:
- **System Architecture Understanding**: Comprehensive overview of design patterns and component relationships
- **Developer Onboarding**: Complete guide for new developers joining the project
- **API Reference**: Detailed documentation of all available methods and interfaces
- **Mathematical Implementation**: Deep dive into mathematical computation and visualization capabilities
- **AI Integration**: Complete guide to AI interface and function call processing
- **State Management**: Comprehensive coverage of undo/redo and workspace persistence

This document contains comprehensive documentation extracted from all files in the MatHud project, including file headers and method documentation.

## Static Typing Guidelines

- Type checking uses `mypy` with configuration in `mypy.ini`; install dependencies via `pip install -r requirements.txt`.
- Run targeted checks with `python -m mypy`; the current config scopes analysis to `app.py`, `static/app_manager.py`, and `static/workspace_manager.py` while skipping deep import traversal.
- New modules should enable postponed evaluation by adding `from __future__ import annotations` directly beneath the module docstring.
- Prefer precise return types and explicit `-> None` annotations; replace dynamic dicts with `TypedDict`, `Protocol`, or dataclasses where practical.
- When Brython-only modules require stubs, place them in `static/client/typing/` (create if missing) and register via `mypy_path` before widening the rollout.
- Attach MatHud-specific attributes to subclasses such as `MatHudFlask` rather than mutating `Flask` directly, keeping mypy aware of injected services.

## Table of Contents

### Core Application Files
1. Flask entry point (`app.py`)
2. Brython entry point (`main.py`)
3. Canvas System (`canvas.py`)
4. Canvas Event Handler (`canvas_event_handler.py`)
5. AI Interface (`ai_interface.py`)
6. Result Processor (`result_processor.py`)
7. Test Runner (`test_runner.py`)
8. Client-Side Workspace Manager (`workspace_manager.py`)
9. Cartesian System (`cartesian_system_2axis.py`)
10. Expression Validator (`expression_validator.py`)
11. Markdown Parser (`markdown_parser.py`)

### Drawable Classes
1. Base Drawable (`drawables/drawable.py`)
2. Position (`drawables/position.py`)
3. Point (`drawables/point.py`)
4. Segment (`drawables/segment.py`)
5. Vector (`drawables/vector.py`)
6. Triangle (`drawables/triangle.py`)
7. Rectangle (`drawables/rectangle.py`)
8. Circle (`drawables/circle.py`)
9. Ellipse (`drawables/ellipse.py`)
10. Angle (`drawables/angle.py`)
11. Function (`drawables/function.py`)
12. Colored Area (`drawables/colored_area.py`)
13. Functions Bounded Colored Area (`drawables/functions_bounded_colored_area.py`)
14. Segments Bounded Colored Area (`drawables/segments_bounded_colored_area.py`)
15. Function Segment Bounded Colored Area (`drawables/function_segment_bounded_colored_area.py`)
16. Rotatable Polygon (`drawables/rotatable_polygon.py`)

Note: All drawables are math-only. They do not hold screen-space coordinates and do not reference `Canvas`. Rendering is performed by the renderer using `CoordinateMapper`.

### Management Classes
1. Drawable Manager (`managers/drawable_manager.py`)
2. Drawable Manager Proxy (`managers/drawable_manager_proxy.py`)
3. Drawables Container (`managers/drawables_container.py`)
4. Drawable Dependency Manager (`managers/drawable_dependency_manager.py`)
5. Undo Redo Manager (`managers/undo_redo_manager.py`)
6. Transformations Manager (`managers/transformations_manager.py`)

### Specialized Managers
1. Point Manager (`managers/point_manager.py`)
2. Segment Manager (`managers/segment_manager.py`)
3. Vector Manager (`managers/vector_manager.py`)
5. Polygon Manager (`managers/polygon_manager.py`)
6. Circle Manager (`managers/circle_manager.py`)
7. Ellipse Manager (`managers/ellipse_manager.py`)
8. Function Manager (`managers/function_manager.py`)
9. Colored Area Manager (`managers/colored_area_manager.py`)
10. Angle Manager (`managers/angle_manager.py`)

### Utility Modules
1. Math Utils (`utils/math_utils.py`)
2. Style Utils (`utils/style_utils.py`)
3. Geometry Utils (`utils/geometry_utils.py`)
4. Computation Utils (`utils/computation_utils.py`)
5. Linear Algebra Utils (`utils/linear_algebra_utils.py`)
   - Regenerate test fixtures with `python scripts/linear_algebra_expected_values.py`

### Name Generators
1. Base Name Generator (`name_generator/base.py`)
2. Drawable Name Generator (`name_generator/drawable.py`)
3. Point Name Generator (`name_generator/point.py`)
4. Function Name Generator (`name_generator/function.py`)

### Supporting Files
1. Expression Evaluator (`expression_evaluator.py`)
2. Function Registry (`function_registry.py`)
3. Process Function Calls (`process_function_calls.py`)
4. Constants (`constants.py`)
5. Geometry (`geometry.py`)
6. Result Validator (`result_validator.py`)
7. HTML Template (`templates/index.html`)
8. CSS Stylesheet (`static/style.css`)

### Server-Side Components
1. Server-Side Workspace Manager (`static/workspace_manager.py`)
2. OpenAI API Integration (`static/openai_api.py`)
3. AI Function Definitions (`static/functions_definitions.py`)
4. Flask Application Manager (`static/app_manager.py`)
5. Flask Route Definitions (`static/routes.py`)
6. Application Logging System (`static/log_manager.py`)
7. Selenium WebDriver Manager (`static/webdriver_manager.py`)
8. AI Model Configuration (`static/ai_model.py`)
9. Tool Call Processing Utilities (`static/tool_call_processor.py`)

### Testing and Quality Assurance
1. Client-Side Testing (`client_tests/` and `test_runner.py`)
2. Server-Side Testing (`server_tests/` and `run_server_tests.py`)
3. Renderer Performance Harness (`static/client/performance/renderer_performance.py`): deterministic workload runner invoked from the browser console to record draw/pan/zoom timings, DOM node counts, and telemetry. Baseline captures from 2025-11-08/09 report Canvas2D averages (draw 71 ms, pan 155.5 ms, zoom 160 ms) and SVG averages (draw 78 ms, pan 84 ms, zoom 90 ms) using `run_renderer_performance(iterations=2)`.

### Graph and Tree Tools
1. Graph and tree tools overview (generate, delete, analyze)
2. `generate_graph`: Create a graph/tree/DAG with optional layout and weights
3. `delete_graph`: Remove a graph/tree and its associated drawables
4. `analyze_graph`: Run graph and tree analysis operations (shortest path, MST, topological sort, BFS/DFS, etc.)

---

## Detailed Documentation

### Core Application Files

#### Main Application (`app.py`)

**File Header:**
```
MatHud Flask Application Entry Point

Main application launcher that initializes the Flask server, manages graceful shutdown,
and coordinates the WebDriver for vision system functionality.

Dependencies:
    - static.app_manager: Application configuration and initialization
    - Flask: Web framework (initialized via AppManager)
    - Selenium WebDriver: Vision system image capture (lazy-loaded)
    - Threading: Concurrent server execution
```

**Key Components:**
- **Signal Handling**: Graceful shutdown management with WebDriver cleanup
- **Flask Threading**: Daemon thread execution for non-blocking server startup
- **WebDriver Initialization**: Lazy loading of vision system components
- **Application Factory**: Integration with AppManager for dependency injection

**Key Functions:**
- `signal_handler(sig, frame)`: Handle graceful shutdown on interrupt signal with WebDriver cleanup
- `__main__`: Main execution block that starts Flask server in daemon thread and initializes WebDriver

**Execution Flow:**
1. **App Creation**: Creates Flask application using AppManager factory pattern
2. **Signal Registration**: Sets up interrupt handlers for graceful shutdown
3. **Threaded Server**: Starts Flask server in daemon thread for responsive main thread
4. **WebDriver Setup**: Initializes vision system after Flask startup delay
5. **Main Loop**: Maintains responsive main thread for interrupt handling

**Key Features:**
- **Graceful Shutdown**: Proper cleanup of WebDriver resources on application exit
- **Non-Blocking Startup**: Daemon thread prevents blocking main thread execution
- **Vision System Integration**: Automatic WebDriver initialization for AI vision capabilities
- **Debug Configuration**: Production-ready settings with debug and reloader disabled

#### Main (`main.py`)

**File Header:**
```
MatHud Client-Side Application Entry Point

Initializes the browser-based Python environment for mathematical canvas operations.
Sets up the SVG canvas, AI communication interface, and event handling system.

Components Initialized:
    - Canvas: mathematical visualization system backed by the renderer factory (Canvas2D by default with SVG/WebGL fallbacks)
    - AIInterface: Communication bridge to backend AI services  
    - CanvasEventHandler: User interaction and input processing

Dependencies:
    - Brython: Python-in-browser runtime environment
    - browser.document: DOM access for SVG manipulation
    - Custom modules: canvas, ai_interface, canvas_event_handler
```

**Key Functions:**
- `main()`: Initialize the MatHud client-side application by creating the mathematical canvas, AI interface, and event handling system

#### Canvas System (`canvas.py`)

**File Header:**
```
MatHud Mathematical Canvas System

Core SVG-based canvas for interactive mathematical visualization and geometric construction.
Serves as the central coordinator for all drawable objects, coordinate systems, and user interactions.

Key Features:
    - SVG viewport management with zoom/pan capabilities
    - Geometric object creation (points, segments, vectors, shapes, functions)
    - Coordinate system with Cartesian grid visualization
    - Undo/redo state management for user actions
    - Mathematical computation history tracking
    - Colored area visualization between objects
    - Angle measurement and display
    - Object transformations (translate, rotate)

Architecture:
    - Canvas: Central coordinator and state manager
    - DrawableManager: Handles all geometric object lifecycle
    - UndoRedoManager: Provides state archiving and restoration
    - TransformationsManager: Manages object positioning and rotation
    - Cartesian2Axis: Coordinate system visualization

Dependencies:
    - CoordinateMapper: centralized math-to-screen conversion
    - rendering.factory: runtime selection between Canvas2D, SVG, and WebGL renderers
    - geometry: Geometric object definitions (Point, Position, etc.)
    - cartesian_system_2axis: Coordinate grid system
    - utils.*: Mathematical, styling, and geometry utilities
    - managers.*: Specialized management components
```

_Note: The legacy docstring refers to an SVG canvas, but the live code delegates drawing to the renderer selected by `rendering.factory.create_renderer` (Canvas2D first, then SVG, then WebGL)._

**Class Documentation:**
```
Central mathematical visualization canvas coordinating all drawable objects and interactions.

Manages the SVG viewport, coordinate system, geometric objects, and user interactions.
Provides the main interface for creating, manipulating, and visualizing mathematical content.

Attributes:
    width (float): Canvas viewport width in pixels
    height (float): Canvas viewport height in pixels
    center (Position): Current viewport center point
    scale_factor (float): Current zoom level (1.0 = normal)
    computations (list): History of mathematical computations performed
    cartesian2axis (Cartesian2Axis): Coordinate grid system
    drawable_manager (DrawableManager): Manages all geometric objects
    undo_redo_manager (UndoRedoManager): Handles state archiving/restoration
    transformations_manager (TransformationsManager): Manages object transformations
```

**Key Methods:**
- `__init__(width, height, draw_enabled=True)`: Initialize the mathematical canvas with specified dimensions. Sets up the coordinate system, managers, and initial state for mathematical visualization.
- `add_drawable(drawable)`: Add a drawable object to the canvas
- `draw(apply_zoom=False)`: Draw all canvas content including coordinate system and drawable objects
- `clear()`: Clear all drawables from the canvas
- `reset()`: Reset the canvas to its initial state
- `archive()`: Archive the current state for undo functionality
- `undo()`: Restores the last archived state from the undo stack
- `redo()`: Restores the last undone state from the redo stack
- `get_drawables()`: Get all drawables as a flat list
- `create_point(x, y, name="", extra_graphics=True)`: Create a point at the specified coordinates
- `delete_point(x, y)`: Delete a point at the specified coordinates
- `create_segment(x1, y1, x2, y2, name="", extra_graphics=True)`: Create a line segment between two points
- `create_vector(origin_x, origin_y, tip_x, tip_y, name="", extra_graphics=True)`: Create a vector from origin to tip
- `create_polygon(vertices, polygon_type="triangle", name="", extra_graphics=True)`: Create a triangle from three points
- `create_polygon(vertices, polygon_type="rectangle", name="", extra_graphics=True)`: Create a rectangle from canonicalized vertices (use `canonicalize_rectangle` for diagonal pairs)
- `create_circle(center_x, center_y, radius, name="", extra_graphics=True)`: Create a circle with specified center and radius
- `create_circle_arc(point1_x, point1_y, point2_x, point2_y, point3_x=None, point3_y=None, center_point_choice=None, circle_name=None, center_x=None, center_y=None, radius=None, arc_name=None, use_major_arc=False, extra_graphics=True)`: Create a circle arc between two points. When supplying explicit center/radius values or referencing an existing circle, all provided endpoints (new or existing) are projected onto that circle before the arc is created. Alternatively, provide three points plus `center_point_choice` (point1/point2/point3) to treat that point as the center and derive the circle automatically.
- `delete_circle_arc(name)`: Remove a circle arc by name without deleting its endpoints.
- `update_circle_arc(name, new_color=None, use_major_arc=None)`: Update arc styling or switch between the minor and major arc sweep.
- `create_ellipse(center_x, center_y, radius_x, radius_y, rotation_angle=0, name="", extra_graphics=True)`: Create an ellipse with specified parameters
- `draw_function(function_string, name, left_bound=None, right_bound=None)`: Draw a mathematical function on the canvas
- `zoom_to_bounds(left_bound, right_bound, top_bound, bottom_bound)`: Fit the viewport so the specified math-space rectangle is entirely visible while preserving aspect ratio
- `create_colored_area(drawable1_name, drawable2_name=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3)`: Create a colored area between two objects
- `translate_object(name, x_offset, y_offset)`: Translates a drawable object by the specified offset
- `rotate_object(name, angle)`: Rotates a drawable object by the specified angle
- `create_angle(vx, vy, p1x, p1y, p2x, p2y, color=None, angle_name=None, is_reflex=False)`: Create an angle from three points

#### Canvas Event Handler (`canvas_event_handler.py`)

**File Header:**
```
MatHud Canvas Event Management System

Handles all user interactions with the mathematical canvas including mouse events, keyboard input,
and coordinate system navigation. Provides smooth zoom, pan, and click detection capabilities.

Key Features:
    - Mouse wheel zooming with dynamic zoom point tracking
    - Canvas panning via mouse drag operations
    - Double-click coordinate capture for precise input
    - Throttled mouse movement for performance optimization
    - Chat interface keyboard shortcuts (Enter key)
    - Error handling for robust user experience

Event Types:
    - Wheel: Zoom in/out with scale factor adjustments
    - Mouse down/up: Drag initialization and termination
    - Mouse move: Canvas panning and coordinate tracking
    - Key press: Chat input shortcuts and navigation
    - Double-click: Coordinate capture for mathematical input

Dependencies:
    - browser: DOM event handling and element access
    - constants: Timing thresholds and scaling factors
    - geometry: Position calculations for coordinate systems
```

**Class Documentation:**
```
Manages all user interaction events for the mathematical canvas interface.

Coordinates mouse and keyboard events to provide intuitive navigation, input capture,
and canvas manipulation capabilities. Implements performance optimizations through
event throttling and efficient coordinate calculations.

Attributes:
    canvas (Canvas): Mathematical canvas for visualization and state updates
    ai_interface (AIInterface): Communication interface for user input processing
    last_click_timestamp (float): Timestamp of last click for double-click detection
    current_mouse_position (Position): Current mouse coordinates for drag calculations
```

**Key Methods:**
- `__init__(canvas, ai_interface)`: Initialize event handler with canvas and AI interface integration
- `bind_events()`: Bind all event handlers with error handling
- `check_enter(event)`: Handle enter key press in chat input
- `handle_wheel(event)`: Handle mouse wheel events for zooming
- `handle_mousedown(event)`: Handle mouse down events for drag initialization and double-click detection
- `handle_mouseup(event)`: Handle mouse up events for drag termination
- `handle_mousemove(event)`: Handle mouse move events for canvas panning and coordinate tracking
- `get_decimal_places(value)`: Calculate appropriate decimal places for coordinate display
- `throttle(wait_ms)`: Decorator factory for throttling function calls

#### AI Interface (`ai_interface.py`)

**File Header:**
```
MatHud AI Communication Interface

Handles bidirectional communication between the client-side canvas and backend AI services.
Manages user interactions, function call processing, and visual presentation of AI responses.

Key Features:
    - AJAX-based communication with backend AI API
    - Function call execution and result aggregation
    - Markdown parsing and MathJax rendering for AI responses
    - Chat interface management with styled messages
    - SVG state transmission for AI vision capabilities
    - Computation history integration with canvas state
    - Testing framework integration

Communication Flow:
    1. User input → JSON payload creation with canvas state
    2. Backend AI processing with function calls
    3. Function execution and result collection
    4. Response rendering with markdown and math support
    5. Canvas state updates with computation results

Dependencies:
    - browser: DOM manipulation and AJAX requests
    - function_registry: Available AI function mappings
    - process_function_calls: Function execution coordination
    - workspace_manager: File persistence operations
    - markdown_parser: Rich text formatting support
```

**Class Documentation:**
```
Communication bridge between the mathematical canvas and backend AI services.

Orchestrates the complete interaction cycle from user input to AI response processing,
including function call execution, state management, and visual presentation.

Attributes:
    canvas (Canvas): Mathematical canvas for visualization and state management
    workspace_manager (WorkspaceManager): Handles workspace persistence operations
    is_processing (bool): Tracks whether an AI request is currently being processed
    available_functions (dict): Registry of all functions available to the AI
    undoable_functions (tuple): Functions that support undo/redo operations
    markdown_parser (MarkdownParser): Converts markdown text to HTML for rich formatting
```

**Key Methods:**
- `__init__(canvas)`: Initialize the AI interface with canvas integration and function registry
- `run_tests()`: Run unit tests for the AIInterface class and return results to the AI
- `interact_with_ai(event)`: Main entry point for user interactions with the AI system
- `_create_message_element(sender, message, message_type="normal")`: Create a styled message element with markdown support
- `_parse_markdown_to_html(text)`: Parse markdown text to HTML using the dedicated markdown parser
- `_render_math()`: Trigger MathJax rendering for newly added content
- `_store_results_in_canvas_state(call_results)`: Store valid function call results in the canvas state
- `_send_prompt_to_ai(user_message=None, tool_call_results=None)`: Send request to AI backend with canvas state
- `_create_request_payload(prompt, include_svg=True)`: Create JSON payload for AI requests
- `_disable_send_controls()`: Disable send functionality while processing
- `_enable_send_controls()`: Enable send functionality after processing

#### Result Processor (`result_processor.py`)

**File Header:**
```
MatHud Function Call Result Processing

Handles execution of AI function calls and aggregation of their results.
Manages state archiving, computation tracking, and error handling for function execution.

Key Features:
    - Function call validation and execution
    - Result formatting and type consistency
    - State archiving for undoable operations
    - Computation history integration
    - Error handling and exception management
    - Expression evaluation result processing

Processing Flow:
    1. Input validation for function calls and available functions
    2. State archiving for undoable operations
    3. Individual function call execution with error handling
    4. Result formatting and key generation
    5. Computation history integration (for mathematical operations)
    6. Result aggregation into structured dictionary

Dependencies:
    - constants: Success message definitions for result formatting
```

**Class Documentation:**
```
Handles the processing of function calls and their results.

Executes AI function calls, manages state for undoable operations, and aggregates
results with proper formatting and error handling. Integrates with canvas
computation history for mathematical operations.
```

**Key Methods:**
- `get_results(calls, available_functions, undoable_functions, canvas)`: Process function calls and collect their results
- `_validate_inputs(calls, available_functions, undoable_functions)`: Validate the input parameters
- `_prepare_helper_variables(undoable_functions)`: Prepare helper variables needed for processing
- `_process_function_call(call, available_functions, non_computation_functions, unformattable_functions, canvas, results)`: Process a single function call and update results
- `_is_function_available(function_name, available_functions, results)`: Check if the function exists and update results if not
- `_execute_function(function_name, args, available_functions)`: Execute the function with the provided arguments
- `_generate_result_key(function_name, args)`: Generate a consistent key format for the results dictionary
- `_process_result(function_name, args, result, key, unformattable_functions, non_computation_functions, canvas, results)`: Process the result based on function type
- `_handle_exception(exception, function_name, results)`: Handle exceptions during function calls
- `_add_computation_if_needed(result, function_name, non_computation_functions, expression, canvas)`: Add computation to canvas if needed

#### Test Runner (`test_runner.py`)

**File Header:**
```
MatHud Testing Framework Runner

Executes test suites for mathematical functions and canvas operations.
Provides formatted test results for AI analysis and validation of system functionality.

Testing Categories:
    - Graphics drawing capabilities and geometric object creation
    - Mathematical function evaluation and computation accuracy
    - Canvas state management and object interactions
    - Error handling and edge case validation

Key Features:
    - Automated test execution with result aggregation
    - AI-formatted output for integration testing
    - Function call validation using real canvas operations
    - Error tracking and debugging information
    - State isolation between test runs

Dependencies:
    - process_function_calls: Function execution framework for testing
```

**Class Documentation:**
```
Executes test suites and formats results for AI analysis and validation.

Provides comprehensive testing capabilities for mathematical functions, canvas operations,
and system integration. Manages test execution state and result formatting for both
human and AI consumption.

Attributes:
    canvas (Canvas): Canvas instance for testing geometric operations
    available_functions (dict): Function registry for validation testing
    undoable_functions (tuple): Functions that support undo/redo testing
    test_results: Aggregated results from test execution
    internal_failures (list): Collection of test failures for debugging
    internal_errors (list): Collection of test errors for analysis
    internal_tests_run (int): Counter of executed test cases
```

**Key Methods:**
- `__init__(canvas, available_functions, undoable_functions)`: Initialize test runner with canvas and function registry access
- `run_tests()`: Execute all test suites and return formatted results
- `get_test_results()`: Get the current test results
- `format_results_for_ai(results)`: Format test results for AI analysis and consumption
- `_test_graphics_drawing()`: Run tests for graphics drawing capabilities
- `_test_undoable_functions()`: Test that all undoable functions are available
- `_get_graphics_test_function_calls()`: Return the list of function calls for graphics drawing tests
- `_validate_undoable_functions()`: Validate that all undoable functions are in the available functions list
- `_run_client_tests()`: Execute client-side test modules
- `_merge_test_results(client_results)`: Merge internal and client test results
- `_add_internal_failure(test_name, error_message)`: Add a failure to the internal failures list
- `_add_internal_error(test_name, error_message)`: Add an error to the internal errors list

#### Client-Side Workspace Manager (`workspace_manager.py`)

**File Header:**
```
MatHud Client-Side Workspace Persistence and State Management System

Client-side workspace manager that runs in the browser using Brython. Manages workspace 
operations including saving, loading, listing and deleting workspaces through AJAX 
communication with the Flask backend server.

Key Features:
    - Canvas state serialization with complete object preservation
    - AJAX-based communication with backend workspace API
    - Incremental object restoration with dependency resolution
    - Error handling and validation for workspace operations
    - Support for all drawable object types and relationships
    - Computation history preservation and restoration

Workspace Operations:
    - Save: Serializes current canvas state and sends to server via AJAX
    - Load: Requests workspace data from server and restores canvas state
    - List: Retrieves available workspace names from server storage
    - Delete: Removes workspace files from server persistent storage

Object Restoration:
    - Points: Coordinate-based geometric primitives
    - Segments: Line segments with endpoint dependency resolution
    - Vectors: Directed segments with origin/tip point relationships
    - Triangles: Three-vertex polygons with automatic edge detection
    - Rectangles: Four-corner polygons with diagonal point calculation and segment reuse
    - Circles: Circular objects with center point dependencies
    - Ellipses: Elliptical objects with center and rotation parameters
    - Functions: Mathematical function expressions with domain settings
    - Colored Areas: Bounded regions with drawable object relationships
    - Angles: Angular measurements with vertex and arm dependencies

Dependencies:
    - browser: AJAX communication for backend workspace operations
    - utils.math_utils: Geometric calculations for object restoration
    - json: State serialization and deserialization
```

**Class Documentation:**
```
Client-side workspace manager that handles workspace operations via AJAX communication.

This class handles all workspace-related operations and their associated error handling.
It works with the canvas to save and restore workspace states, including all geometric
objects and computations. Runs in the browser using Brython.

Args:
    canvas: The canvas instance to manage workspaces for.
```

**Key Methods:**
- `__init__(canvas)`: Initialize workspace manager with canvas reference
- `save_workspace(name=None)`: Save the current workspace state to server via AJAX
- `load_workspace(name=None)`: Load and restore workspace state from server
- `list_workspaces()`: Retrieve list of available workspace names from server
- `delete_workspace(name)`: Remove workspace from server persistent storage
- `_create_points(state)`: Create points from workspace state during restoration
- `_create_segments(state)`: Create segments from workspace state with endpoint validation
- `_create_vectors(state)`: Create vectors from workspace state with origin/tip resolution
- `_create_triangles(state)`: Create triangles from workspace state using the polygon manager
- `_create_rectangles(state)`: Recreate rectangles from workspace state using polygon canonicalization
- `_create_circles(state)`: Create circles from workspace state with center point dependencies
- `_create_ellipses(state)`: Create ellipses from workspace state with parameter restoration
- `_create_functions(state)`: Create mathematical functions from workspace state
- `_create_colored_areas(state)`: Create colored areas from workspace state with boundary resolution
- `_create_angles(state)`: Create angles from workspace state with vertex/arm dependencies
- `_restore_computations(state)`: Restore computation history from workspace state
- `_restore_workspace_state(state)`: Main restoration orchestrator for complete workspace state
- `_find_rectangle_segments(points)`: Find existing segments that form a rectangle
- `_get_properly_oriented_rectangle_segments(segments, points)`: Arrange segments in proper rectangle order

#### Cartesian System (`cartesian_system_2axis.py`)

**File Header:**
```
MatHud Two-Axis Cartesian Coordinate System

Implements a complete Cartesian coordinate system with grid visualization, axis rendering,
and coordinate transformations. Provides the mathematical foundation for geometric object
positioning and user interaction coordinate mapping.

Key Features:
    - Dynamic grid scaling with zoom-adaptive tick spacing
    - Axis rendering with numerical labels and origin marking
    - Coordinate transformation between screen and mathematical space
    - Viewport boundary calculations for efficient rendering
    - Grid line visualization with customizable spacing
    - Origin point management and positioning

Visual Components:
    - X and Y axes with customizable colors and thickness
    - Tick marks with automatic spacing calculation
    - Numerical labels with mathematical formatting
    - Grid lines for visual coordinate reference
    - Origin marker ('O') at coordinate system center

Coordinate Transformations:
    - Screen to mathematical coordinate conversion
    - Mathematical to screen coordinate conversion
    - Zoom and pan transformation support
    - Viewport boundary calculations
    - Visible area determination for rendering optimization

Dependencies:
    - browser.document: DOM manipulation for SVG rendering
    - geometry: Drawable base class and Position utilities
    - constants: Default styling and configuration values
    - utils.math_utils: Mathematical calculations and number formatting
```

**Class Documentation:**
```
Two-axis Cartesian coordinate system with dynamic scaling and grid visualization.

Inherits from Drawable to provide complete coordinate system rendering with
automatic scaling, tick spacing calculation, and viewport management.

Attributes:
    width (float): Canvas width for coordinate system bounds
    height (float): Canvas height for coordinate system bounds
    origin (Position): Current origin position in screen coordinates
    default_tick_spacing (float): Base tick spacing for coordinate labels
    current_tick_spacing (float): Current tick spacing adjusted for zoom level
    max_ticks (int): Maximum number of ticks to display
    tick_size (int): Visual size of tick marks in pixels
    tick_color (str): Color for axis lines and tick marks
    tick_label_color (str): Color for numerical coordinate labels
    tick_label_font_size (int): Font size for coordinate labels
    grid_color (str): Color for grid lines
```

**Key Methods:**
- `__init__(canvas, color=default_color)`: Initialize Cartesian coordinate system with canvas
- `reset()`: Reset coordinate system to initial state with centered origin
- `get_class_name()`: Return the class name 'Cartesian2Axis'
- `get_visible_left_bound()`: Calculate visible left boundary in mathematical coordinates
- `get_visible_right_bound()`: Calculate visible right boundary in mathematical coordinates
- `get_visible_top_bound()`: Calculate visible top boundary in mathematical coordinates
- `get_visible_bottom_bound()`: Calculate visible bottom boundary in mathematical coordinates
- `get_relative_width()`: Get canvas width adjusted for current scale factor
- `get_relative_height()`: Get canvas height adjusted for current scale factor
- `draw()`: Render complete coordinate system including axes, ticks, labels, and grid
- `zoom()`: Update coordinate system for zoom operations with dynamic tick spacing
- `pan()`: Update coordinate system for pan operations
- `get_state()`: Serialize coordinate system state for persistence
- `_draw_axes()`: Render X and Y axis lines
- `_draw_ticks(step)`: Draw tick marks and numerical labels on both axes
- `_draw_grid(step)`: Render grid lines for visual coordinate reference
- `_calculate_tick_spacing()`: Calculate appropriate tick spacing for current zoom level

#### Expression Validator (`expression_validator.py`)

**File Header:**
```
MatHud Mathematical Expression Validation and Evaluation System

Secure mathematical expression parser and evaluator that validates and processes user input
for function plotting and mathematical computation. Provides safe expression evaluation
with comprehensive mathematical function support and syntax validation.

Key Features:
    - AST-based expression validation for security
    - Safe mathematical function evaluation
    - Expression syntax correction and normalization
    - Mathematical notation conversion (degrees, symbols, operators)
    - Comprehensive mathematical function library support
    - Python and Math.js compatibility modes

Security Features:
    - Restricted execution environment using AST parsing
    - Whitelist-based function and operator validation
    - Prevention of dangerous operations (imports, assignments, etc.)
    - Input sanitization and validation
    - Safe evaluation with controlled variable scope

Mathematical Support:
    - Standard arithmetic operations (+, -, *, /, ^, **)
    - Trigonometric functions (sin, cos, tan, asin, acos, atan)
    - Hyperbolic functions (sinh, cosh, tanh)
    - Logarithmic functions (log, log10, log2, ln)
    - Advanced functions (sqrt, exp, abs, factorial, arrangements, permutations, combinations)
    - Statistical functions (mean, median, mode, variance, stdev)
    - Mathematical constants (pi, e)
    - Calculus operations (derivative, integral, limit)
    - Algebraic operations (simplify, expand, factor, solve)

Expression Processing:
    - Automatic syntax correction and normalization
    - Mathematical notation conversion (√, °, π, !)
    - Implicit multiplication insertion (2x → 2*x)
    - Power operator conversion (^ ↔ **)
    - Function name standardization

Dependencies:
    - ast: Abstract syntax tree parsing for security
    - math: Standard mathematical functions
    - random: Random number generation
    - re: Regular expression pattern matching
    - utils.math_utils: Advanced mathematical operations
```

**Class Documentation:**
```
Secure mathematical expression validator and evaluator using AST parsing.

Validates mathematical expressions against a whitelist of allowed operations
and functions, then provides safe evaluation capabilities. Uses abstract
syntax tree (AST) parsing to ensure security by preventing dangerous
operations like imports, assignments, and arbitrary code execution.

Security Model:
    - AST-based validation prevents code injection
    - Whitelist approach for allowed functions and operations
    - Controlled variable scope during evaluation
    - Prevention of dangerous Python operations

Mathematical Capabilities:
    - Full arithmetic operation support
    - Comprehensive mathematical function library
    - Advanced mathematical operations (calculus, algebra)
    - Statistical analysis functions
    - Mathematical constant access

Attributes:
    ALLOWED_NODES (set): Whitelist of permitted AST node types
    ALLOWED_FUNCTIONS (set): Whitelist of permitted mathematical functions
```

**Key Methods:**
- `_is_allowed_node_type(node)`: Check if AST node type is in allowed whitelist
- `visit(node)`: Visit AST node and validate against security constraints
- `visit_Call(node)`: Visit function call nodes and validate against allowed functions
- `validate_expression_tree(expression)`: Validate mathematical expression using AST parsing
- `evaluate_expression(expression, x=0)`: Safely evaluate mathematical expression with controlled scope
- `fix_math_expression(expression, python_compatible=False)`: Automatically correct and normalize expression syntax
- `parse_function_string(function_string, use_mathjs=False)`: Parse function string into callable function object
- `_convert_degrees(expression)`: Convert degree symbols and text to radians
- `_handle_special_symbols(expression, python_compatible)`: Handle square roots, absolute values, and factorials
- `_replace_function_names(expression)`: Replace common mathematical function names with Python equivalents
- `_handle_power_and_imaginary(expression, python_compatible)`: Handle power operators and imaginary numbers
- `_insert_multiplication_operators(expression, python_compatible)`: Insert multiplication operators for implicit multiplication

#### Markdown Parser (`markdown_parser.py`)

**File Header:**
```
Markdown Parser for MatHud Chat Interface

A comprehensive markdown parser that supports:
- Headers (H1-H6: # ## ### #### ######)
- Bold text (**bold** or __bold__)
- Italic text (*italic* or _italic_)
- Strikethrough text (~~strikethrough~~)
- Inline and block code (` and ```)
- Links and images
- Ordered and unordered lists with nesting
- Checkboxes (- [x] and - [ ])
- Tables
- Blockquotes
- Horizontal rules
- Mathematical expressions (LaTeX: \(...\) for inline, $$...$$ for block)
```

**Class Documentation:**
```
Custom markdown parser optimized for chat interface display.

Provides comprehensive markdown parsing capabilities specifically designed
for the MatHud chat interface, with special support for mathematical
expressions and complex formatting structures.

Key Features:
    - Complete markdown syntax support
    - Mathematical expression rendering (LaTeX)
    - Nested list handling with proper indentation
    - Table parsing and formatting
    - Checkbox support for task lists
    - Inline formatting (bold, italic, strikethrough)
    - Code block and inline code support
    - Link and image processing
    - Blockquote and horizontal rule support

Mathematical Integration:
    - Inline math expressions using \(...\)
    - Block math expressions using $$...$$
    - Integration with MathJax for rendering
    - Proper escaping and formatting

Advanced Features:
    - Smart line break handling
    - Proper list nesting with indentation levels
    - Table structure detection and HTML generation
    - Error handling with graceful fallbacks
    - Performance optimization for chat interfaces
```

**Key Methods:**
- `parse(text)`: Parse markdown text to HTML with error handling
- `_simple_markdown_parse(text)`: Main markdown parsing logic using string operations
- `_process_tables(text)`: Process markdown tables into HTML table structures
- `_build_table_html(table_lines)`: Build HTML table from markdown table lines
- `_is_list_item(line)`: Check if line is a list item (ordered, unordered, or checkbox)
- `_process_list_item(line)`: Process list item and determine type and indentation
- `_join_lines_with_smart_breaks(lines)`: Join lines with intelligent line break handling
- `_wrap_list_items_improved(html)`: Wrap list items with proper <ul>/<ol> tags and nesting
- `_extract_data_attr(line, attr_name)`: Extract data attribute values from HTML
- `_build_nested_list_html(list_items)`: Build properly nested HTML from list items
- `_process_inline_markdown(text)`: Process inline markdown elements (bold, italic, code)
- `_process_math_expressions(text)`: Process LaTeX mathematical expressions for rendering

### Drawable Classes

#### Base Drawable (`drawables/drawable.py`)

**File Header:**
```
MatHud Base Drawable Class

Abstract base class for all mathematical objects that can be visualized on the canvas.
Defines the core interface for geometric objects including drawing, state management, and transformations.

Key Features:
    - SVG element creation and management
    - Color and naming system
    - Canvas integration for coordinate transformations
    - State serialization for persistence
    - Abstract interface for zoom, pan, and draw operations

Core Interface:
    - draw(): Render the object to SVG canvas
    - zoom(): Update object for scale factor changes
    - pan(): Update object for viewport translation
    - get_state(): Serialize object state for persistence
    - rotate(): Apply rotation transformation

Dependencies:
    - browser: DOM manipulation for SVG rendering
    - constants: Default styling values
```

**Class Documentation:**
```
Abstract base class for all mathematical objects that can be visualized on the canvas.

Provides the fundamental interface and common functionality for geometric objects,
including SVG rendering capabilities, state management, and coordinate system integration.

Attributes:
    name (str): Unique identifier for the object within the canvas
    color (str): CSS color value for object visualization
    canvas (Canvas): Reference to the parent canvas for coordinate transformations
```

**Key Methods:**
- `__init__(name="", color=default_color)`: Initialize a drawable object with basic properties
- `get_class_name()`: Abstract method to return the class name (implemented by subclasses)
- `get_name()`: Return the object's name
- `draw()`: Abstract method for rendering (implemented by subclasses)
- `get_state()`: Abstract method for state serialization (implemented by subclasses)
- `zoom()`: Abstract method to update object for zoom operations (implemented by subclasses)
- `pan()`: Abstract method to update object for pan operations (implemented by subclasses)
- `rotate(angle)`: Abstract method to rotate object by specified angle (implemented by subclasses)
- `reset()`: Reset the object to its initial state
- `create_svg_element(element_name, **attributes)`: Create SVG elements with text content support

#### Position (`drawables/position.py`)

**File Header:**
```
MatHud Geometric Position Container

Fundamental coordinate representation for all mathematical objects in the canvas system.
Provides simple x, y coordinate storage with state serialization capabilities.

Key Features:
    - Immutable coordinate pair storage
    - State serialization for persistence and undo/redo
    - String representation for debugging and display

Dependencies:
    - None (pure data container)
```

**Class Documentation:**
```
Represents a 2D coordinate position in the mathematical coordinate system.

Fundamental building block for all geometric objects, providing x,y coordinate
storage with serialization capabilities for state management.

Attributes:
    x (float): X-coordinate in the mathematical coordinate system
    y (float): Y-coordinate in the mathematical coordinate system
```

**Key Methods:**
- `__init__(x, y)`: Initialize a position with x and y coordinates
- `__str__()`: String representation for debugging
- `get_state()`: Serialize position state for persistence

#### Point (`drawables/point.py`)

**File Header:**
```
MatHud Point Geometric Object

Fundamental geometric building block representing a point in 2D mathematical space.
Provides coordinate tracking, labeling, and serves as endpoints for other geometric objects.

Key Features:
    - Original and screen coordinate tracking
    - Automatic label display with coordinates
    - Scale factor and viewport transformation support
    - Translation operations for object manipulation
    - Visibility checking based on canvas bounds

Coordinate Systems:
    - original_position: Mathematical coordinates (unchanged by zoom/pan)
    - x, y: Screen coordinates (updated by zoom/pan transformations)

Dependencies:
    - constants: Point sizing and labeling configuration
    - drawables.drawable: Base class interface
    - drawables.position: Coordinate container
    - utils.math_utils: Mathematical operations
```

**Class Documentation:**
```
Represents a point in 2D mathematical space with coordinate tracking and labeling.

Fundamental building block for all geometric constructions, maintaining both original
mathematical coordinates and transformed screen coordinates for proper rendering.

Attributes:
    original_position (Position): Mathematical coordinates (unaffected by zoom/pan)
    x (float): Current screen x-coordinate (affected by transformations)
    y (float): Current screen y-coordinate (affected by transformations)
```

**Key Methods:**
- `__init__(x, y, name="", color=default_color)`: Initialize a point with mathematical coordinates
- `get_class_name()`: Return the class name 'Point'
- `draw()`: Render the point to the SVG canvas with label
- `zoom()`: Update point for zoom operations
- `pan()`: Update point screen coordinates for pan operations
- `translate(x_offset, y_offset)`: Move point by translating original position
- `rotate(angle)`: Rotate point (placeholder implementation)
- `get_state()`: Serialize point state for persistence
- `is_visible()`: Check if the point is within the canvas visible area
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality
- `__eq__(other)`: Check if two points are equal based on coordinates within tolerance
- `__hash__()`: Compute hash based on rounded coordinates

#### Segment (`drawables/segment.py`)

**File Header:**
```
MatHud Line Segment Geometric Object

Represents a line segment between two points in 2D mathematical space.
Provides line equation calculation, visibility detection, and rotation capabilities.

Key Features:
    - Two-endpoint line segment representation
    - Automatic line equation calculation (ax + by + c = 0)
    - Visibility detection based on canvas viewport intersection
    - Translation and rotation transformations
    - Midpoint-based rotation around segment center

Mathematical Properties:
    - line_formula: Algebraic line equation coefficients
    - Endpoint coordinate tracking through Point objects
    - Visibility optimization for performance

Dependencies:
    - constants: Default styling values
    - drawables.drawable: Base class interface
    - drawables.position: Coordinate calculations
    - utils.math_utils: Line equation and intersection calculations
```

**Class Documentation:**
```
Represents a line segment between two points with mathematical line properties.

Maintains references to two Point objects and calculates line equation properties
for mathematical operations and geometric intersections.

Attributes:
    point1 (Point): First endpoint of the segment
    point2 (Point): Second endpoint of the segment
    line_formula (dict): Algebraic line equation coefficients (a, b, c for ax + by + c = 0)
```

**Key Methods:**
- `__init__(p1, p2, color=default_color)`: Initialize a line segment between two points
- `get_class_name()`: Return the class name 'Segment'
- `draw()`: Render the segment as SVG line between endpoints
- `zoom()`: Update segment for zoom operations (handled by endpoints)
- `pan()`: Update segment for pan operations (handled by endpoints)
- `translate(x_offset, y_offset)`: Move segment by translating both endpoints
- `rotate(angle)`: Rotate the segment around its midpoint by the given angle in degrees
- `get_state()`: Serialize segment state for persistence
- `is_visible()`: Check if any part of the segment is visible in the canvas area
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality
- `__eq__(other)`: Check if two segments are equal based on their endpoints
- `__hash__()`: Compute hash based on endpoint hashes

#### Vector (`drawables/vector.py`)

**File Header:**
```
MatHud Vector Geometric Object

Represents a directed line segment (vector) with origin and tip points, displayed with an arrow tip.
Built on top of the Segment class with additional directional visualization.

Key Features:
    - Directed line segment with origin and tip designation
    - Automatic arrow head calculation and rendering
    - Translation and rotation operations maintaining direction
    - Integration with segment properties for mathematical operations

Visual Elements:
    - Line segment: Rendered using underlying Segment object
    - Arrow tip: Triangular polygon calculated from direction and size
    - Directional properties: Origin and tip point distinction

Dependencies:
    - constants: Default styling and arrow sizing
    - drawables.drawable: Base class interface
    - drawables.point: Endpoint objects
    - drawables.segment: Underlying line representation
    - utils.math_utils: Angle and geometric calculations
```

**Class Documentation:**
```
Represents a directed line segment (vector) with origin, tip, and arrow head visualization.

Extends the concept of a line segment to include directionality, displayed with
an arrow head at the tip to indicate vector direction and magnitude.

Attributes:
    segment (Segment): Underlying line segment providing mathematical properties
    origin (Point): Starting point of the vector (property access to segment.point1)
    tip (Point): Ending point of the vector (property access to segment.point2)
```

**Key Methods:**
- `__init__(origin, tip, color=default_color)`: Initialize a vector with origin and tip points
- `get_class_name()`: Return the class name 'Vector'
- `draw()`: Render the vector (line + arrow tip)
- `translate(x_offset, y_offset)`: Translate origin and tip
- `rotate(angle)`: Rotate vector around origin
- `get_state()`: Serialize vector state
- `__deepcopy__(memo)`: Deep copy

#### Triangle (`drawables/triangle.py`)

**File Header:**
```
MatHud Triangle Geometric Object

Represents a triangle formed by three connected line segments in 2D mathematical space.
Extends RotatablePolygon to provide rotation capabilities around the triangle's center.

Key Features:
    - Three-segment triangle validation and construction
    - Automatic vertex naming from segment endpoints
    - Rotation around geometric center
    - Translation operations for all vertices
    - Segment connectivity validation

Geometric Properties:
    - Three segments forming a closed triangle
    - Unique vertex identification and naming
    - Center-based rotation capabilities
    - Vertex set management for transformations

Dependencies:
    - constants: Default styling values
    - drawables.drawable: Base class interface
    - drawables.rotatable_polygon: Rotation capabilities
    - utils.math_utils: Geometric validation
```

**Class Documentation:**
```
Represents a triangle formed by three connected line segments.

Validates that three segments form a proper triangle and provides rotation
capabilities around the triangle's geometric center.

Attributes:
    segment1 (Segment): First side of the triangle
    segment2 (Segment): Second side of the triangle  
    segment3 (Segment): Third side of the triangle
```

**Key Methods:**
- `__init__(segment1, segment2, segment3, color=default_color)`: Initialize a triangle from three connected line segments
- `get_class_name()`: Return the class name 'Triangle'
- `draw()`: Render the triangle (drawing is done by the canvas for the segments)
- `zoom()`: Update triangle for zoom operations (handled by segment points)
- `pan()`: Update triangle for pan operations (handled by segment points)
- `translate(x_offset, y_offset)`: Move triangle by translating all unique vertices
- `get_state()`: Serialize triangle state for persistence
- `get_vertices()`: Return the set of unique vertices of the triangle
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality

#### Rectangle (`drawables/rectangle.py`)

**File Header:**
```
MatHud Rectangle Geometric Object

Represents a rectangle formed by four connected line segments in 2D mathematical space.
Extends RotatablePolygon to provide rotation capabilities around the rectangle's center.

Key Features:
    - Four-segment rectangle validation and construction
    - Right angle and parallel side verification
    - Rotation around geometric center
    - Translation operations for all vertices
    - Segment connectivity and geometric validation

Geometric Properties:
    - Four segments forming a closed rectangle
    - Right angles at all vertices
    - Parallel opposite sides
    - Center-based rotation capabilities

Dependencies:
    - constants: Default styling values
    - drawables.drawable: Base class interface
    - drawables.rotatable_polygon: Rotation capabilities
    - utils.math_utils: Rectangle validation and geometric calculations
```

**Class Documentation:**
```
Represents a rectangle formed by four connected line segments.

Validates that four segments form a proper rectangle with right angles and
provides rotation capabilities around the rectangle's geometric center.

Attributes:
    segment1 (Segment): First side of the rectangle
    segment2 (Segment): Second side of the rectangle
    segment3 (Segment): Third side of the rectangle
    segment4 (Segment): Fourth side of the rectangle
```

**Key Methods:**
- `__init__(segment1, segment2, segment3, segment4, color=default_color)`: Initialize a rectangle from four connected line segments
- `get_class_name()`: Return the class name 'Rectangle'
- `draw()`: Render the rectangle (drawing is done by the canvas for the segments)
- `zoom()`: Update rectangle for zoom operations (handled by segment points)
- `pan()`: Update rectangle for pan operations (handled by segment points)
- `translate(x_offset, y_offset)`: Move rectangle by translating all segments
- `get_state()`: Serialize rectangle state for persistence
- `get_vertices()`: Return the set of unique vertices of the rectangle
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality

#### Circle (`drawables/circle.py`)

**File Header:**
```
MatHud Circle Geometric Object

Represents a circle defined by a center point and radius in 2D mathematical space.
Provides algebraic equation calculation and scale-aware rendering.

Key Features:
    - Center point and radius definition
    - Automatic circle equation calculation ((x-h)² + (y-k)² = r²)
    - Scale factor adaptation for zoom operations
    - Mathematical formula generation for geometric operations

Mathematical Properties:
    - circle_formula: Algebraic equation coefficients
    - Center point tracking through Point object
    - Radius scaling for viewport transformations

Dependencies:
    - constants: Default styling values
    - drawables.drawable: Base class interface
    - utils.math_utils: Circle equation calculations
```

**Class Documentation:**
```
Represents a circle with center point and radius, including mathematical properties.

Maintains a center Point object and radius value, calculating circle equation
properties for mathematical operations and geometric intersections.

Attributes:
    center (Point): Center point of the circle
    radius (float): Radius in mathematical coordinate units
    circle_formula (dict): Algebraic circle equation coefficients
    drawn_radius (float): Current screen radius (affected by scale factor)
```

**Key Methods:**
- `__init__(center_point, radius, color=default_color)`: Initialize a circle with center point and radius
- `get_class_name()`: Return the class name 'Circle'
- `draw()`: Render the circle to the SVG canvas
- `zoom()`: Update circle radius for zoom operations
- `pan()`: Update circle for pan operations (handled by center point)
- `translate(x_offset, y_offset)`: Move circle by translating center point
- `rotate(angle)`: Rotate circle (placeholder implementation)
- `get_state()`: Serialize circle state for persistence
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality

#### Ellipse (`drawables/ellipse.py`)

**File Header:**
```
MatHud Ellipse Geometric Object

Represents an ellipse defined by center point, radii, and rotation angle in 2D mathematical space.
Provides algebraic equation calculation and rotation transformation capabilities.

Key Features:
    - Center point and dual radius definition (rx, ry)
    - Rotation angle support for arbitrary ellipse orientation
    - Automatic ellipse equation calculation
    - Scale factor adaptation for zoom operations
    - SVG rotation transformation for rendering

Mathematical Properties:
    - ellipse_formula: Algebraic equation coefficients
    - Center point tracking through Point object
    - Dual radius scaling for viewport transformations
    - Rotation angle preservation and application

Dependencies:
    - constants: Default styling values
    - drawables.drawable: Base class interface
    - utils.math_utils: Ellipse equation calculations
```

**Class Documentation:**
```
Represents an ellipse with center point, dual radii, and rotation angle.

Maintains center Point object, x/y radius values, and rotation angle,
calculating ellipse equation properties for mathematical operations.

Attributes:
    center (Point): Center point of the ellipse
    radius_x (float): Horizontal radius in mathematical coordinate units
    radius_y (float): Vertical radius in mathematical coordinate units
    rotation_angle (float): Rotation angle in degrees for ellipse orientation
    ellipse_formula (dict): Algebraic ellipse equation coefficients
    drawn_radius_x (float): Current screen x-radius (affected by scale factor)
    drawn_radius_y (float): Current screen y-radius (affected by scale factor)
```

**Key Methods:**
- `__init__(center_point, radius_x, radius_y, rotation_angle=0, color=default_color)`: Initialize an ellipse with center point, radii, and rotation
- `get_class_name()`: Return the class name 'Ellipse'
- `draw()`: Render the ellipse to the SVG canvas with rotation transformation
- `zoom()`: Update ellipse radii for zoom operations
- `pan()`: Update ellipse for pan operations (handled by center point)
- `translate(x_offset, y_offset)`: Move ellipse by translating center point
- `rotate(angle)`: Rotate ellipse around its center by the given angle in degrees
- `get_state()`: Serialize ellipse state for persistence including rotation
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality

#### Angle (`drawables/angle.py`)

**File Header:**
```
MatHud Angle Geometric Object

Represents an angle formed by two intersecting line segments with arc and label visualization.
Provides angle measurement, arc rendering, and support for both standard and reflex angles.

Key Features:
    - Two-segment angle construction and validation
    - Angle measurement in degrees with arc visualization
    - Support for standard (0-180°) and reflex (180-360°) angles
    - Automatic arc radius calculation and SVG path generation
    - Dynamic text labeling with angle values

Geometric Properties:
    - Vertex point identification from segment intersection
    - Arm point extraction for angle calculation
    - Arc radius adaptation for screen display
    - Angle sweep calculation for proper arc rendering

Dependencies:
    - constants: Default angle styling and sizing values
    - drawables.drawable: Base class interface
    - utils.math_utils: Angle calculation and geometric validation
```

**Class Documentation:**
```
Represents an angle formed by two intersecting line segments with arc visualization.

Validates that two segments form a proper angle and provides arc rendering
with angle measurement display for both standard and reflex angles.

Attributes:
    segment1 (Segment): First segment forming the angle
    segment2 (Segment): Second segment forming the angle
    is_reflex (bool): Whether to display the reflex (outer) angle
    vertex_point (Point): Common vertex where segments intersect
    arm1_point (Point): End point of first segment arm
    arm2_point (Point): End point of second segment arm
    raw_angle_degrees (float): Fundamental angle measurement (0-360°)
    angle_degrees (float): Display angle (small or reflex based on is_reflex)
    drawn_arc_radius (float): Screen radius for arc rendering
```

**Key Methods:**
- `__init__(segment1, segment2, color=DEFAULT_ANGLE_COLOR, is_reflex=False)`: Initialize an angle from two intersecting line segments
- `get_class_name()`: Return the class name 'Angle'
- `draw()`: Render the angle arc and label to the SVG canvas
- `zoom()`: Update angle for zoom operations (arc radius is fixed on screen)
- `pan()`: Update angle for pan operations (handled by underlying points)
- `get_state()`: Serialize angle state for persistence
- `from_state(state_data, canvas)`: Create an Angle instance from a state dictionary (class method)
- `update_points_based_on_segments()`: Re-evaluate vertex and arm points if segments have changed
- `reset()`: Reset the angle to its initial state based on its segments
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality

#### Function (`drawables/function.py`)

**File Header:**
```
MatHud Mathematical Function Object

Represents a mathematical function plot with expression evaluation and curve rendering.
Provides function plotting, domain management, and mathematical analysis capabilities.

Key Features:
    - Mathematical expression parsing and evaluation
    - Smooth curve rendering with adaptive point sampling
    - Domain boundary management (left/right bounds)
    - Asymptote and discontinuity detection
    - Function expression validation and correction
    - Performance optimized path caching

Mathematical Properties:
    - Function expression in string format
    - Domain boundaries for plotting range
    - Point sampling for curve smoothness
    - Asymptote calculations (vertical and horizontal)
    - Discontinuity analysis and handling

Visual Optimization:
    - Adaptive step size calculation based on function type
    - Path caching for performance optimization
    - Intelligent path regeneration on zoom/pan
    - Boundary clipping for efficient rendering

Dependencies:
    - expression_validator: Mathematical expression parsing and validation
    - constants: Plotting parameters and styling
    - drawables.drawable: Base class interface
    - drawables.position: Coordinate calculations
```

**Class Documentation:**
```
Represents a mathematical function with expression evaluation and curve plotting.

Manages function expressions, evaluates them over specified domains, and renders
smooth curves with proper handling of asymptotes and discontinuities.

Attributes:
    function_string (str): Mathematical function expression (e.g., "sin(x)", "x^2")
    function (callable): Parsed function object for evaluation
    left_bound (float): Left boundary of the function domain
    right_bound (float): Right boundary of the function domain
    step (float): Sampling step size for curve generation
    vertical_asymptotes (list): List of vertical asymptote x-coordinates
    horizontal_asymptotes (list): List of horizontal asymptote equations
    point_discontinuities (list): Point discontinuities in the function
```

**Key Methods:**
- `__init__(function_string, name, step=default_point_size, color=default_color, left_bound=None, right_bound=None, vertical_asymptotes=None, horizontal_asymptotes=None, point_discontinuities=None)`: Initialize function with expression and domain
- `get_class_name()`: Return the class name 'Function'
- `draw()`: Render the function curve to the SVG canvas with path optimization
- `zoom()`: Update function plotting for zoom operations (handled by path regeneration)
- `pan()`: Update function for pan operations (handled by path regeneration)
- `translate(x_offset, y_offset)`: Translation not applicable for functions
- `rotate(angle)`: Rotation not applicable for functions
- `get_state()`: Serialize function state for persistence
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality
- `_generate_paths()`: Generate optimized SVG paths for function curve rendering
- `_calculate_asymptotes_and_discontinuities()`: Calculate mathematical function properties

#### Colored Area (`drawables/colored_area.py`)

**File Header:**
```
MatHud Colored Area Base Class

Abstract base class for all colored area visualizations between geometric objects.
Provides SVG path creation and common area rendering functionality.

Key Features:
    - SVG path generation from boundary points
    - Color and opacity customization
    - Forward and reverse path construction for closed areas
    - Base state management for all area types

Area Types Supported:
    - Functions bounded areas (between two functions)
    - Segment bounded areas (between segments and axes)
    - Function-segment bounded areas (between function and segment)

Dependencies:
    - drawables.drawable: Base class interface
    - constants: Default styling values
```

**Class Documentation:**
```
Abstract base class for all colored area visualizations between geometric objects.

Provides the foundation for area fill operations with SVG path generation
and common styling capabilities for opacity and color.

Attributes:
    opacity (float): Fill opacity value between 0.0 and 1.0
    color (str): CSS color value for area fill
```

**Key Methods:**
- `__init__(name, color="lightblue", opacity=0.3)`: Initialize a colored area with basic properties
- `get_class_name()`: Return the class name 'ColoredArea'
- `draw()`: Abstract method for rendering (implemented by subclasses)
- `zoom()`: Update area for zoom operations (handled by boundary objects)
- `pan()`: Update area for pan operations (handled by boundary objects)
- `get_state()`: Serialize colored area state for persistence
- `__deepcopy__(memo)`: Abstract method for deep copy (implemented by subclasses)
- `_create_svg_path(forward_points, reverse_points)`: Create SVG path from boundary points

#### Functions Bounded Colored Area (`drawables/functions_bounded_colored_area.py`)

**File Header:**
```
MatHud Functions Bounded Colored Area

Represents a colored area bounded by mathematical functions with asymptote handling.
Provides area visualization between two functions or between a function and the x-axis.

Key Features:
    - Two-function or function-to-axis area visualization
    - Support for function objects, constants, and x-axis boundaries
    - Asymptote and discontinuity aware path generation
    - Boundary detection and coordinate transformation

Dependencies:
    - drawables.colored_area: Base class for area visualization
    - drawables.function: Function objects for boundary definitions
    - copy: Deep copying capabilities for state management
```

**Class Documentation:**
```
Creates a colored area bounded by mathematical functions with asymptote handling.

This class creates a visual representation of the area between two functions
or between a function and the x-axis. Supports Function objects, constants, and None (x-axis).

Attributes:
    func1 (Function, None, or number): The first bounding function
    func2 (Function, None, or number): The second bounding function
    left_bound (float): Left boundary of the colored area
    right_bound (float): Right boundary of the colored area
    num_sample_points (int): Number of points for path generation
```

**Key Methods:**
- `__init__(func1, func2=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3, num_sample_points=100)`: Initialize functions bounded colored area
- `get_class_name()`: Return the class name 'FunctionsBoundedColoredArea'
- `draw()`: Draw the colored area between the functions on the canvas
- `get_state()`: Serialize functions bounded area state for persistence
- `__deepcopy__(memo)`: Create a deep copy for undo/redo functionality
- `_validate_parameters(func1, func2, left_bound, right_bound, num_sample_points)`: Validate input parameters for function bounded area creation
- `_generate_name(func1, func2)`: Generate a descriptive name for the colored area
- `_get_function_y_at_x(func, x)`: Get y value for a given x, handling different function types

#### Segments Bounded Colored Area (`drawables/segments_bounded_colored_area.py`)

**File Header:**
```
MatHud Segments Bounded Colored Area

Represents a colored area bounded by line segments with overlap detection and linear interpolation.
Provides area visualization between two segments or between a segment and the x-axis.

Key Features:
    - Two-segment or segment-to-axis area visualization
    - Overlap region detection and calculation
    - Linear interpolation for boundary generation
    - Geometric validation and path optimization

Dependencies:
    - drawables.colored_area: Base class for area visualization
    - drawables.segment: Segment objects for boundary definitions
    - copy: Deep copying capabilities for state management
```

**Class Documentation:**
```
Creates a colored area bounded by line segments with geometric overlap detection.

This class creates a visual representation of the area between two line segments
or between a segment and the x-axis, using linear interpolation for smooth boundaries.

Attributes:
    segment1 (Segment): The first bounding segment
    segment2 (Segment or None): The second bounding segment (None means x-axis)
```

**Key Methods:**
- `__init__(segment1, segment2=None, color="lightblue", opacity=0.3)`: Initialize segments bounded colored area
- `get_class_name()`: Return the class name 'SegmentsBoundedColoredArea'
- `draw()`: Render the colored area with segment boundary interpolation
- `get_state()`: Serialize segments bounded area state for persistence
- `__deepcopy__(memo)`: Create deep copy for undo/redo functionality
- `_generate_name(segment1, segment2)`: Generate descriptive name based on segment names
- `uses_segment(segment)`: Check if this colored area uses a specific segment

#### Function Segment Bounded Colored Area (`drawables/function_segment_bounded_colored_area.py`)

**File Header:**
```
MatHud Function Segment Bounded Colored Area

Represents a colored area bounded by a mathematical function and a line segment.
Provides area visualization between a function and a segment with coordinate transformation.

Key Features:
    - Function-to-segment area visualization
    - Support for function objects, constants, and x-axis boundaries
    - Coordinate transformation between canvas and mathematical space
    - Boundary intersection calculation

Dependencies:
    - drawables.colored_area: Base class for area visualization
    - drawables.function: Function objects for boundary definitions
```

**Class Documentation:**
```
Creates a colored area bounded by a mathematical function and a line segment.

This class creates a visual representation of the area between a function
and a segment with coordinate transformation support.

Attributes:
    func (Function, None, or number): The bounding function
    segment (Segment): The bounding line segment
```

**Key Methods:**
- `__init__(func, segment, color="lightblue", opacity=0.3)`: Initialize a function segment bounded colored area
- `get_class_name()`: Return the class name 'FunctionSegmentBoundedColoredArea'
- `draw()`: Draw the colored area between the function and segment on the canvas
- `get_state()`: Serialize function segment bounded area state for persistence
- `__deepcopy__(memo)`: Create a deep copy for undo/redo functionality
- `_generate_name(func, segment)`: Generate a descriptive name for the colored area
- `_get_function_y_at_x(x)`: Get y value for a given x from the function
- `uses_segment(segment)`: Check if this colored area uses a specific segment

#### Closed Shape Colored Area (`drawables/closed_shape_colored_area.py`)

**File Header:**
```
MatHud Closed Shape Colored Area

Fills the interior of polygons, circles, ellipses, or round-shape segments.
```

**Class Documentation:**
```
Represents any colored area whose boundaries come from existing closed shapes.

Supports:
    - `triangle_name` / `rectangle_name` (reuses their stored segments)
    - `polygon_segment_names` (validated via GeometryUtils closed-loop helpers)
    - Full `circle_name` / `ellipse_name` fills
    - `circle_name` + `chord_segment_name` or `ellipse_name` + `chord_segment_name`

Sampling is handled by MathUtils arc helpers, then rendered through ClosedShapeAreaRenderable.
```

**Key Methods:**
- `__init__(shape_type, segments=None, circle=None, ellipse=None, chord_segment=None, arc_clockwise=False, resolution=96, color="lightblue", opacity=0.3)`: Capture the geometry references plus rendering resolution.
- `_generate_name()`: Builds a readable identifier based on the supplied boundary.
- `uses_segment/uses_circle/uses_ellipse(...)`: Helper predicates for dependency lookups.
- `get_geometry_spec()`: Returns the math-space references consumed by renderers.
- `get_state()`: Serializes shape type, referenced names, and sampling config for persistence.

**Creation Entry Point:**
- `canvas.create_closed_shape_colored_area` / `create_closed_shape_colored_area` tool:
    - Validates colors/opacities
    - Resolves drawables through `ColoredAreaManager`
    - Archives undo state and registers dependencies so removal cascades cleanly

#### Rotatable Polygon (`drawables/rotatable_polygon.py`)

**File Header:**
```
MatHud Rotatable Polygon Base Class

Abstract base class for polygonal shapes that support rotation around their geometric center.
Provides common rotation functionality for triangles, rectangles, and other multi-vertex shapes.

Key Features:
    - Center point calculation from vertex coordinates
    - Point rotation around arbitrary center using rotation matrices
    - Abstract vertex management interface
    - Mathematical coordinate preservation during transformations

Rotation Mathematics:
    - Uses standard 2D rotation matrix: [cos θ -sin θ; sin θ cos θ]
    - Rotates around calculated geometric center of shape
    - Preserves original mathematical coordinates during transformation

Dependencies:
    - drawables.drawable: Base class interface
    - math: Trigonometric functions for rotation calculations
```

**Class Documentation:**
```
Abstract base class for polygons that can be rotated around their geometric center.

Provides rotation capabilities for multi-vertex shapes using center-based rotation
with mathematical coordinate transformations.

Subclasses must implement:
    get_vertices(): Returns set of vertex Point objects for the polygon
```

**Key Methods:**
- `_get_shape_center(points)`: Calculate center point of a shape given its vertices
- `_rotate_point_around_center(point, center_x, center_y, angle_rad)`: Rotate a single point around a center by given angle in radians
- `get_vertices()`: Abstract method to be implemented by subclasses to return their vertices
- `rotate(angle)`: Rotate the polygon around its center by the given angle in degrees

### Management Classes

#### Drawable Manager (`managers/drawable_manager.py`)

**File Header:**
```
MatHud Drawable Management System

Central orchestration hub for all drawable objects in the mathematical visualization system.
Coordinates specialized managers for each drawable type and handles object lifecycle management.

Core Architecture:
    - Proxy Pattern: Uses DrawableManagerProxy to resolve circular dependencies during initialization
    - Specialized Managers: Delegates type-specific operations to dedicated manager classes
    - Dependency Tracking: Maintains hierarchical relationships between geometric objects
    - Container Management: Organizes drawables by type with efficient access patterns
    - Name Generation: Automatic naming system for drawable objects

Manager Hierarchy:
    - PointManager: Point creation, retrieval, and deletion operations
    - SegmentManager: Line segment operations with endpoint validation
    - VectorManager: Vector operations with origin and tip management
    - PolygonManager: Polygon operations with canonicalization for triangles, quadrilaterals (rectangles, squares), pentagons, and hexagons
    - CircleManager: Circle operations with center and radius validation
    - EllipseManager: Ellipse operations with center, radii, and rotation
    - AngleManager: Angle operations with vertex and arm management
    - FunctionManager: Mathematical function plotting and analysis
    - ColoredAreaManager: Bounded area creation with function/segment boundaries

Dependency System:
    - DrawableDependencyManager: Tracks parent-child relationships between objects
    - Propagates changes through dependency chains (e.g., moving a point updates dependent segments)
    - Handles cascading deletions while preserving object integrity

Storage Organization:
    - DrawablesContainer: Type-based storage with property access patterns
    - Layered rendering support (colored areas behind geometric objects)
    - State serialization for undo/redo functionality

Integration Points:
    - Canvas drawing system for visual representation
    - UndoRedoManager for state persistence
    - TransformationsManager for geometric transformations
    - Mathematical computation engine for geometric analysis
```

**Class Documentation:**
```
Manages drawable objects for a Canvas.

This class coordinates specialized managers for each drawable type:
- Points
- Segments
- Vectors
- Triangles
- Functions
- Circles
- Ellipses
- Rectangles
- Colored Areas
```

**Key Methods:**
- `__init__(canvas)`: Initialize the DrawableManager with canvas
- `get_drawables()`: Get all drawables as a flat list, with colored areas first (behind other elements)
- `get_point(x, y)`: Get a point at the specified coordinates
- `get_point_by_name(name)`: Get a point by its name
- `create_point(x, y, name="", extra_graphics=True)`: Create a new point at the specified coordinates. Handles collision detection, name generation, extra graphics, and dependency management.
- `delete_point(x, y)`: Delete a point at the specified coordinates
- `delete_point_by_name(name)`: Delete a point by its name
- `get_segment_by_coordinates(x1, y1, x2, y2)`: Get a segment by its endpoint coordinates
- `get_segment_by_name(name)`: Get a segment by its name
- `get_segment_by_points(p1, p2)`: Get a segment by its endpoint points
- `create_segment(x1, y1, x2, y2, name="", extra_graphics=True)`: Create a new segment between the specified points
- `delete_segment(x1, y1, x2, y2, delete_children=True, delete_parents=False)`: Delete a segment at the specified coordinates
- `delete_segment_by_name(name, delete_children=True, delete_parents=False)`: Delete a segment by its name
- `update_segment(name, new_color=None)`: Update a segment's color
- `get_vector(origin_x, origin_y, tip_x, tip_y)`: Get a vector by its origin and tip coordinates
- `create_vector(origin_x, origin_y, tip_x, tip_y, name="", extra_graphics=True)`: Create a vector from origin to tip
- `delete_vector(origin_x, origin_y, tip_x, tip_y)`: Delete a vector by its coordinates
- `update_vector(name, new_color=None)`: Update a vector's color
- `get_polygon_by_vertices(vertices, polygon_type="triangle")`: Get a triangle by its vertex coordinates
- `create_polygon(vertices, polygon_type="triangle", name="", extra_graphics=True)`: Create a triangle from three points
- `delete_polygon(polygon_type="triangle", vertices=[...])`: Delete a triangle by its vertex coordinates
- `update_polygon(name, polygon_type="triangle", new_color=None)`: Update a triangle's color
- `get_function(name)`: Get a function by its name
- `draw_function(function_string, name, left_bound=None, right_bound=None)`: Draw a function on the canvas
- `delete_function(name)`: Delete a function by its name
- `update_function(name, new_color=None, new_left_bound=None, new_right_bound=None)`: Update a function's color or bounds
- `get_circle(center_x, center_y, radius)`: Get a circle by its center coordinates and radius
- `get_circle_by_name(name)`: Get a circle by its name
- `create_circle(center_x, center_y, radius, name="", extra_graphics=True)`: Create a circle with specified center and radius
- `delete_circle(name)`: Delete a circle by its name
- `update_circle(name, new_color=None, new_center_x=None, new_center_y=None)`: Update a circle's color or move its center (center moves require both coordinates and an isolated center point)
- `create_ellipse(center_x, center_y, radius_x, radius_y, rotation_angle=0, name="", extra_graphics=True)`: Create an ellipse with specified parameters
- `delete_ellipse(name)`: Delete an ellipse by its name
- `update_ellipse(name, new_color=None, new_radius_x=None, new_radius_y=None, new_rotation_angle=None, new_center_x=None, new_center_y=None)`: Update ellipse styling or geometry (solitary ellipses only; center moves require complete coordinate pairs)
- `get_polygon_by_vertices(vertices, polygon_type="rectangle")`: Get a rectangle by canonicalized vertices
- `get_polygon_by_name(name, polygon_type="rectangle")`: Get a rectangle by its name
- `create_polygon(vertices, polygon_type="rectangle", name="", extra_graphics=True)`: Create a rectangle from canonicalized vertices (use `canonicalize_rectangle` for diagonal pairs)
- `delete_polygon(polygon_type="rectangle", name)`: Delete a rectangle by name via the polygon API
- `update_rectangle(name, new_color=None)`: Update a rectangle's color
- `create_label(x, y, text, name="", color=None, font_size=None, rotation_degrees=None)`: Create a label anchored at math-space coordinates
- `delete_label(name)`: Delete a label by its name
- `update_label(name, new_text=None, new_x=None, new_y=None, new_color=None, new_font_size=None, new_rotation_degrees=None)`: Update label text, style, or position
- `create_colored_area(drawable1_name, drawable2_name=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3)`: Creates a colored area between objects
- `delete_colored_area(name)`: Delete a colored area by its name
- `update_colored_area(name, new_color=None, new_opacity=None, new_left_bound=None, new_right_bound=None)`: Update colored area styling; bounds apply to function-bounded areas only
- `delete_colored_areas_for_function(func)`: Delete colored areas for a function
- `delete_colored_areas_for_segment(segment)`: Delete colored areas for a segment
- `get_colored_areas_for_drawable(drawable)`: Get colored areas for a drawable
- `create_drawables_from_new_connections()`: Create drawables from new connections
- `create_angle(vx, vy, p1x, p1y, p2x, p2y, label=None, color=None, angle_name=None)`: Create an angle by points
- `delete_angle(name)`: Delete an angle by name
- `update_angle(name, new_color=None)`: Update angle properties

#### Drawable Manager Proxy (`managers/drawable_manager_proxy.py`)

**File Header:**
```
MatHud Drawable Manager Proxy System

Resolves circular dependencies during manager initialization using the Proxy Pattern.
Enables specialized managers to access each other through the main DrawableManager without 
creating dependency cycles during object construction.

Design Pattern:
    - Proxy Pattern: Defers attribute resolution until runtime access
    - Dependency Injection: Provides access to DrawableManager functionality
    - Circular Dependency Resolution: Breaks initialization order constraints

Use Cases:
    - SegmentManager accessing PointManager functionality
    - Any manager needing to call methods on other managers

Implementation:
    - __getattr__ magic method forwards all attribute access to real manager
    - Lazy evaluation ensures managers are fully initialized before access
    - Transparent proxy - specialized managers treat it as the real DrawableManager

Architecture Benefits:
    - Clean initialization order independence
    - Maintains strong typing and IDE support
    - No performance overhead after initialization
    - Enables complex inter-manager operations
```

**Class Documentation:**
```
A proxy for the DrawableManager that forwards all attribute access to the real manager.

This breaks circular dependencies during initialization by deferring attribute resolution
until runtime access. Specialized managers can access other managers through this proxy
without creating initialization order constraints.
```

**Key Methods:**
- `__init__(real_manager)`: Initialize the proxy with a reference to the real manager
- `__getattr__(name)`: Delegate attribute access to the real manager. This is called when an attribute doesn't exist on the proxy.

#### Drawables Container (`managers/drawables_container.py`)

**File Header:**
```
MatHud Drawable Storage and Organization System

Centralized container for all drawable objects with type-based organization and efficient access patterns.
Provides clean separation of storage concerns from Canvas operations and supports layered rendering.

Storage Architecture:
    - Type-Based Organization: Groups drawables by class name for efficient access
    - Property Access: Convenient attribute-style access to drawable collections
    - Dictionary Interface: Supports both object-oriented and dictionary-style access
    - Layered Storage: Separates colored areas from geometric objects for proper z-ordering

Supported Drawable Types:
    - Points: Coordinate-based geometric primitives
    - Segments: Line segments connecting two points
    - Vectors: Directed line segments with origin and tip
    - Triangles: Three-sided polygons with vertex tracking
    - Rectangles: Four-sided polygons with diagonal point definition
    - Circles: Circular objects with center and radius
    - Ellipses: Elliptical objects with center, radii, and rotation
    - Functions: Mathematical function plots and curves
    - Angles: Angular measurements between line segments
    - ColoredAreas: Various bounded colored regions

Rendering Support:
    - Z-Order Management: Colored areas rendered behind geometric objects
    - Layered Access: get_all_with_layering() provides proper rendering order
    - Background/Foreground Separation: Efficient separation for rendering pipeline

State Management:
    - State Serialization: get_state() for undo/redo functionality
    - Clear Operations: Bulk removal for canvas reset
    - Container Introspection: Type checking and content validation

Access Patterns:
    - Property Style: container.Points, container.Segments
    - Dictionary Style: container['Point'], container['Segment']
    - Bulk Operations: get_all(), get_colored_areas(), get_non_colored_areas()
```

**Canvas Reference Removal:**
All drawable classes do not contain a `canvas` attribute, nor accept `canvas` in constructors or deepcopy. Methods such as `_initialize`, `_translate`, model-level `zoom`/`pan`, and `from_state` (where applicable) are not part of the math-only model API. Models expose only math-space state and `get_state()`.

**Key Methods:**
- `__init__()`: Initialize an empty drawables container
- `add(drawable)`: Add a drawable to the container
- `remove(drawable)`: Remove a drawable from the container
- `get_by_class_name(class_name)`: Get all drawables of a specific class name (private method)
- `get_all()`: Get all drawables as a flat list
- `get_colored_areas()`: Get all colored area drawables (for background rendering)
- `get_non_colored_areas()`: Get all non-colored area drawables (for foreground rendering)
- `get_all_with_layering()`: Get all drawables with proper layering (colored areas first, then others)
- `clear()`: Remove all drawables from the container
- `get_state()`: Get the state of all drawables in the container

**Properties:**
- `Points`: Get all Point objects
- `Segments`: Get all Segment objects
- `Vectors`: Get all Vector objects
- `Triangles`: Get all Triangle objects
- `Rectangles`: Get all Rectangle objects
- `Circles`: Get all Circle objects
- `Ellipses`: Get all Ellipse objects
- `Functions`: Get all Function objects
- `ColoredAreas`: Get all ColoredArea objects
- `FunctionsBoundedColoredAreas`: Get all FunctionsBoundedColoredArea objects
- `Angles`: Get all Angle objects
- `SegmentsBoundedColoredAreas`: Get all SegmentsBoundedColoredArea objects
- `FunctionSegmentBoundedColoredAreas`: Get all FunctionSegmentBoundedColoredArea objects

#### Drawable Dependency Manager (`managers/drawable_dependency_manager.py`)

**File Header:**
```
MatHud Drawable Dependency Management System

Maintains hierarchical relationships between drawable objects to preserve geometric integrity
and enable intelligent cascading operations. Tracks parent-child dependencies and manages
the propagation of changes through the dependency graph.

Dependency Architecture:
    - Hierarchical Relationships: Parent-child tracking between geometric objects
    - Type-Based Hierarchy: Points → Segments → Triangles/Rectangles → Complex Objects
    - Bidirectional Mapping: Efficient lookup of both parents and children
    - Transitive Closure: Recursive traversal of entire dependency chains

Core Dependency Rules:
    - Segments depend on their endpoint Points
    - Vectors depend on their origin and tip Points  
    - Triangles depend on their three Segments and six Points
    - Rectangles depend on their four Segments and four Points
    - Circles/Ellipses depend on their center Points
    - ColoredAreas depend on their boundary Functions and/or Segments
    - Angles depend on their vertex Point and two arm Segments

Change Propagation:
    - Canvas Reference Updates: Ensures all objects maintain proper canvas references
    - Dependency Analysis: Automatic detection of relationships during object creation
    - Cascading Operations: Moving/deleting parents affects all children
    - Integrity Maintenance: Prevents orphaned objects and broken references

Graph Operations:
    - Dependency Registration: register_dependency(child, parent)
    - Relationship Queries: get_parents(), get_children(), get_all_parents(), get_all_children()
    - Graph Cleanup: remove_drawable() removes all references
    - Topological Sorting: resolve_dependency_order() for proper operation sequencing

State Management:
    - Deep Copying Support: Handles state serialization for undo/redo
    - Reference Restoration: Rebuilds dependency graph after state restoration
    - Validation: Ensures all objects have required methods (get_class_name)
    - Error Recovery: Graceful handling of missing or invalid dependencies

Mathematical Integration:
    - Coordinate Matching: Uses MathUtils for floating-point coordinate comparisons
    - Geometric Validation: Ensures relationships match geometric reality
    - Tolerance Handling: Robust matching with mathematical precision considerations
```

**Class Documentation:**
```
Manages dependencies between drawable objects to maintain hierarchical structure.

This class:
- Tracks parent-child relationships between drawables
- Resolves dependency chains
- Handles propagation of changes (like canvas references)
```

**Key Methods:**
- `__init__(drawable_manager_proxy=None)`: Initialize the dependency manager with drawable manager proxy
- `register_dependency(child, parent)`: Register a child-parent dependency relationship
- `unregister_dependency(child, parent)`: Unregister a specific child-parent dependency
- `get_parents(drawable)`: Get all direct parents of a drawable
- `get_children(drawable)`: Get all direct children of a drawable
- `get_all_parents(drawable)`: Get all parents recursively (transitive closure)
- `get_all_children(drawable)`: Get all children recursively (transitive closure)
- `remove_drawable(drawable)`: Remove all dependencies for a drawable
- `update_canvas_references(drawable, canvas)`: Update canvas references for drawable and its dependencies
- `analyze_drawable_for_dependencies(drawable)`: Analyze a drawable and register its dependencies
- `resolve_dependency_order(drawables)`: Resolve dependency order using topological sorting

#### Undo Redo Manager (`managers/undo_redo_manager.py`)

**File Header:**
```
MatHud Undo/Redo State Management System

Provides comprehensive undo and redo functionality for canvas operations through state archiving
and restoration. Maintains operation history and handles complex object relationships during
state transitions.

State Management Architecture:
    - Snapshot System: Deep copying of entire canvas state for each operation
    - Dual Stack System: Separate undo and redo stacks for bidirectional navigation
    - Automatic Archiving: State capture before any destructive operation
    - State Restoration: Complete canvas reconstruction from archived states

Archived State Components:
    - Drawable Objects: Complete deep copy of all geometric objects and their properties
    - Computation History: Mathematical operation results and expressions
    - Object Relationships: Preservation of parent-child dependencies
    - Canvas References: Proper object-to-canvas relationship maintenance

Operation Flow:
    - archive(): Captures current state before modifications
    - undo(): Restores previous state and moves current to redo stack
    - redo(): Restores next state and moves current to undo stack
    - State clearing: Automatic redo stack clearing on new operations

Complex State Handling:
    - Dependency Rebuilding: _rebuild_dependency_graph() recreates object relationships
    - Deep Copy Management: Handles nested object structures and circular references
    - Memory Efficiency: Strategic state limitation to prevent memory bloat

Integration Points:
    - DrawableManager: State capture of all drawable objects
    - DrawableDependencyManager: Dependency graph reconstruction
    - Canvas: Automatic redrawing after state changes
    - Mathematical Operations: Computation history preservation

Error Recovery:
    - Graceful Degradation: Continues operation even if some references can't be restored
    - Validation: Checks for required manager instances before operations
    - Logging: Comprehensive warning system for debugging state issues
```

**Class Documentation:**
```
Manages undo and redo operations for a Canvas object.

This class is responsible for:
- Archiving canvas states (for undo operations)
- Handling undo operations (restore previous state)
- Handling redo operations (restore undone state)
```

**Key Methods:**
- `__init__(canvas)`: Initialize the UndoRedoManager with canvas reference
- `archive()`: Archive the current canvas state for undo functionality
- `undo()`: Restore the most recent archived state
- `redo()`: Restore a previously undone state
- `can_undo()`: Check if undo operation is possible
- `can_redo()`: Check if redo operation is possible
- `clear()`: Clear all archived states
- `_rebuild_dependency_graph()`: Rebuild dependency relationships between drawables

#### Transformations Manager (`managers/transformations_manager.py`)

**File Header:**
```
MatHud Geometric Transformations Management System

Handles geometric transformations of drawable objects including translation and rotation.
Provides coordinated transformation operations with proper state management and canvas integration.

Transformation Types:
    - Translation: Moving objects by specified x and y offsets
    - Rotation: Rotating objects around specified points or their centers

Operation Coordination:
    - State Archiving: Automatic undo/redo state capture before transformations
    - Object Validation: Ensures target objects exist before transformation
    - Method Delegation: Calls transformation methods on drawable objects
    - Canvas Integration: Automatic redrawing after successful transformations

Error Handling:
    - Object Existence Validation: Checks for drawable presence before operations
    - Transformation Validation: Ensures objects support required transformation methods
    - Exception Management: Graceful error handling with descriptive messages
    - State Consistency: Maintains proper canvas state even if transformations fail

Integration Points:
    - DrawableManager: Object lookup and validation
    - UndoRedoManager: State preservation for transformation operations
    - Canvas: Visual updates after transformations
    - Drawable Objects: Delegation to object-specific transformation methods
```

**Class Documentation:**
```
Manages geometric transformations of drawable objects on a Canvas.

Coordinates translation and rotation operations with proper state management,
object validation, and canvas integration.
```

**Key Methods:**
- `__init__(canvas)`: Initialize the TransformationsManager
- `translate_object(name, x_offset, y_offset)`: Translates a drawable object by the specified offset
- `rotate_object(name, angle)`: Rotates a drawable object by the specified angle

### Specialized Managers

#### Point Manager (`managers/point_manager.py`)

**File Header:**
```
MatHud Point Management System

Manages point creation, retrieval, and deletion operations for geometric visualization.
Points serve as the fundamental building blocks for all other geometric objects.

Core Responsibilities:
    - Point Creation: Creates points at specified coordinates with collision detection
    - Point Retrieval: Efficient lookup by coordinates or name
    - Dependency Management: Handles cascading deletion of dependent objects
    - Extra Graphics: Automatically splits segments and creates new connections

Geometric Integration:
    - Segment Splitting: New points automatically split intersecting segments
    - Connection Creation: Generates appropriate segments between nearby points
    - Coordinate Validation: Ensures point placement follows mathematical constraints
    - Name Generation: Provides systematic naming for mathematical clarity

Dependency Hierarchy:
    - Points are used by: Segments, Vectors, Triangles, Rectangles, Circles, Ellipses
    - Deletion cascades to: All dependent geometric objects
    - Preservation logic: Maintains parent segments when deleting child points

Canvas Integration:
    - State Management: Automatic undo/redo archiving for all point operations
    - Visual Updates: Immediate canvas redrawing after point modifications
    - Extra Graphics: Optional geometric enhancement features

Error Handling:
    - Coordinate Validation: Ensures valid mathematical coordinates
    - Existence Checking: Prevents duplicate points at same location
    - Dependency Safety: Safe deletion with preservation of essential objects
```

**Class Documentation:**
```
Manages point drawables for a Canvas.

This class is responsible for:
- Creating point objects
- Retrieving point objects by various criteria
- Deleting point objects
```

**Key Methods:**
- `__init__(canvas, drawables_container, name_generator, dependency_manager, drawable_manager_proxy)`: Initialize the PointManager
- `get_point(x, y)`: Get a point at the specified coordinates
- `get_point_by_name(name)`: Get a point by its name
- `create_point(x, y, name="", extra_graphics=True)`: Create a new point at the specified coordinates. Handles collision detection, name generation, extra graphics, and dependency management.
- `delete_point(x, y)`: Delete a point at the specified coordinates
- `delete_point_by_name(name)`: Delete a point by its name

#### Segment Manager (`managers/segment_manager.py`)

**File Header:**
```
MatHud Segment Management System

Manages line segment creation, retrieval, and deletion with comprehensive geometric integration.
Handles segment operations including point-to-point connections, intersections, and splitting.

Core Responsibilities:
    - Segment Creation: Creates line segments between points with endpoint management
    - Segment Retrieval: Lookup by coordinates, endpoints, or segment names
    - Segment Splitting: Automatic division when new points intersect existing segments
    - Dependency Tracking: Manages relationships with triangles, rectangles, and vectors

Geometric Operations:
    - Point Integration: Automatically creates missing endpoint points
    - Intersection Detection: Identifies and handles segment intersections
    - Splitting Logic: Divides segments while preserving dependent objects
    - Collinearity Handling: Manages segments that share the same line

Advanced Features:
    - Dependency Preservation: Maintains parent-child relationships during operations
    - Connection Finding: Identifies potential new segments from point arrangements
    - Validation: Ensures mathematical validity of segment configurations
    - Name Generation: Systematic naming based on endpoint coordinates

Integration Points:
    - PointManager: Automatic point creation for segment endpoints
    - PolygonManager: Supplies edges for polygon formation (triangles, rectangles, and other n-gons)
    - VectorManager: Creates underlying segments for vector visualization

State Management:
    - Undo/Redo: Complete state archiving for all segment operations
    - Canvas Updates: Immediate visual feedback for segment modifications
    - Dependency Updates: Cascading updates to dependent geometric objects
```

**Key Methods:**
- `get_segment_by_coordinates(x1, y1, x2, y2)`: Get a segment by its endpoint coordinates
- `get_segment_by_name(name)`: Get a segment by its name
- `get_segment_by_points(p1, p2)`: Get a segment by its endpoint points
- `create_segment(x1, y1, x2, y2, name="", extra_graphics=True)`: Create a new segment between specified points
- `delete_segment(x1, y1, x2, y2, delete_children=True, delete_parents=False)`: Delete a segment by coordinates
- `delete_segment_by_name(name, delete_children=True, delete_parents=False)`: Delete a segment by name

#### Vector Manager (`managers/vector_manager.py`)

**File Header:**
```
MatHud Vector Management System

Manages vector creation, retrieval, and deletion for directed line segment visualization.
Handles vector operations with automatic point and segment management.

Core Responsibilities:
    - Vector Creation: Creates directed line segments from origin to tip points
    - Vector Retrieval: Lookup by origin/tip coordinates with mathematical precision
    - Vector Deletion: Safe removal with underlying segment cleanup
    - Point Integration: Automatic creation and management of endpoint points

Vector Properties:
    - Direction: Maintains explicit origin and tip point relationships
    - Visualization: Renders with directional arrows and proper styling
    - Mathematical Accuracy: Preserves vector mathematics with coordinate precision
    - Naming: Systematic naming based on endpoint coordinates or custom names

Integration Points:
    - PointManager: Creates and manages origin and tip points
    - SegmentManager: Creates underlying line segments for vector visualization
    - DrawableManager: Coordinates with other geometric objects
    - Canvas: Handles rendering and visual updates

Advanced Features:
    - Extra Graphics: Optional creation of related geometric objects
    - Dependency Management: Tracks relationships with underlying segments
    - State Preservation: Maintains vector integrity during operations
    - Cleanup Logic: Intelligent removal of unused segments during deletion

Mathematical Context:
    - Vector Mathematics: Supports standard vector operations and properties
    - Coordinate System: Works within canvas coordinate space
    - Precision Handling: Uses mathematical tolerance for coordinate matching
    - Geometric Relationships: Integrates with other geometric constructions
```

**Key Methods:**
- `get_vector(x1, y1, x2, y2)`: Get a vector by its origin and tip coordinates
- `create_vector(origin_x, origin_y, tip_x, tip_y, name="", extra_graphics=True)`: Create a vector from origin to tip
- `delete_vector(origin_x, origin_y, tip_x, tip_y)`: Delete a vector by its coordinates


**File Header:**
```
MatHud Triangle Management System

Manages triangle creation, retrieval, and deletion with comprehensive geometric validation.
Handles triangle construction from three vertices with automatic segment and point management.

Core Responsibilities:
    - Triangle Creation: Constructs triangles from three vertex coordinates
    - Triangle Retrieval: Efficient lookup by vertex coordinates
    - Triangle Deletion: Safe removal with cleanup of constituent segments
    - Dependency Management: Tracks relationships with points and segments

Geometric Validation:
    - Collinearity Detection: Prevents creation of degenerate triangles
    - Coordinate Precision: Uses mathematical tolerance for vertex matching
    - Connectivity Analysis: Automatically detects triangles from segment arrangements
    - Graph Theory Integration: Leverages connectivity algorithms for triangle identification

Advanced Features:
    - Automatic Triangle Detection: Identifies triangles from connected segments
    - Smart Construction: Creates missing points and segments as needed
    - Name Parsing: Extracts vertex names from triangle identifiers
    - Extra Graphics: Optional creation of related geometric objects

Integration Points:
    - PointManager: Creates and manages triangle vertices
    - SegmentManager: Creates and manages triangle edges
    - GeometryUtils: Graph connectivity and geometric analysis
    - DependencyManager: Tracks triangle relationships with constituent elements

Mathematical Properties:
    - Area Calculation: Supports triangle area computation
    - Centroid Finding: Enables geometric center calculations
    - Orientation Testing: Determines vertex ordering (clockwise/counterclockwise)
    - Validity Checking: Ensures triangles meet geometric requirements

State Management:
    - Undo/Redo: Complete state archiving for triangle operations
    - Canvas Integration: Immediate visual updates after modifications
    - Dependency Tracking: Maintains relationships during operations
```

**Key Methods:**
- `get_polygon_by_vertices(vertices, polygon_type="triangle")`: Get a triangle by its vertex coordinates
- `create_polygon(vertices, polygon_type="triangle", name="", extra_graphics=True)`: Create a triangle from three points
- `delete_polygon(polygon_type="triangle", vertices=[...])`: Delete a triangle by its vertex coordinates
- `create_new_triangles_from_connected_segments()`: Automatically detect and create triangles from connected segments

#### Rectangle Operations (Polygon Manager)

**Overview:**
Rectangles are constructed through the unified polygon pipeline. Supplying `polygon_type="rectangle"` to `create_polygon` routes coordinates through `canonicalize_rectangle`, which normalizes diagonal pairs or noisy vertex lists into a valid rectangle before instantiation.

**Key Points:**
- `PolygonManager.create_polygon` canonicalizes rectangle vertices using `utils/polygon_canonicalizer.py`.
- Workspace restoration and other call sites build rectangles by invoking `create_polygon` with the canonicalized vertex list; no rectangle-specific manager is required.
- AI tooling (`static/functions_definitions.py`) documents this behavior so prompts can provide diagonal corners or approximate rectangles confidently.

#### Circle Manager (`managers/circle_manager.py`)

**File Header:**
```
MatHud Circle Management System

Manages circle creation, retrieval, and deletion for curved geometric visualization.
Handles circle operations with center point management and radius-based construction.

Core Responsibilities:
    - Circle Creation: Creates circles from center coordinates and radius values
    - Circle Retrieval: Lookup by center/radius parameters or circle name
    - Circle Deletion: Safe removal with proper cleanup
    - Center Point Management: Automatic creation and tracking of circle centers

Geometric Properties:
    - Center-Radius Model: Uses mathematical center point and radius distance
    - Coordinate Precision: Maintains exact center coordinates
    - Radius Validation: Ensures positive radius values for valid circles
    - Mathematical Accuracy: Preserves circular geometry properties

Advanced Features:
    - Collision Detection: Prevents creation of duplicate circles
    - Name Parsing: Extracts center point names from circle identifiers
    - Point Integration: Seamless integration with point management system
    - Extra Graphics: Optional creation of related geometric objects

Integration Points:
    - PointManager: Creates and manages circle center points
    - DependencyManager: Tracks circle relationships with center points
    - Canvas: Handles rendering and visual updates
    - DrawableManager: Coordinates with other geometric objects

Mathematical Context:
    - Circular Geometry: Supports standard circle properties and calculations
    - Coordinate System: Works within canvas coordinate space
    - Distance Calculations: Uses radius for geometric relationships
    - Intersection Logic: Enables geometric analysis with other objects

State Management:
    - Undo/Redo: Complete state archiving for circle operations
    - Canvas Integration: Immediate visual updates after modifications
    - Dependency Tracking: Maintains relationships with center points
    - Name Generation: Systematic naming for mathematical clarity
```

**Key Methods:**
- `get_circle(center_x, center_y, radius)`: Get a circle by its center coordinates and radius
- `get_circle_by_name(name)`: Get a circle by its name
- `create_circle(center_x, center_y, radius, name="", extra_graphics=True)`: Create a circle with specified center and radius
- `delete_circle(name)`: Delete a circle by its name

#### Ellipse Manager (`managers/ellipse_manager.py`)

**File Header:**
```
MatHud Ellipse Management System

Manages ellipse creation, retrieval, and deletion operations for geometric visualization.
Handles ellipse operations with automatic center point management and dependency tracking.

Core Responsibilities:
    - Ellipse Creation: Creates ellipses from center coordinates, radii, and rotation angle
    - Ellipse Retrieval: Lookup by center/radii parameters or ellipse name
    - Ellipse Deletion: Safe removal with proper cleanup
    - Center Point Management: Automatic creation and tracking of ellipse centers

Manager Features:
    - Collision Detection: Checks for existing ellipses before creation (without rotation angle)
    - Dependency Tracking: Registers ellipse relationships with center points
    - State Archiving: Automatic undo/redo state capture before modifications
    - Extra Graphics: Optional creation of related geometric objects

Integration Points:
    - PointManager: Creates and manages ellipse center points
    - DependencyManager: Tracks ellipse relationships with center points
    - Canvas: Handles rendering and visual updates
    - DrawableManager: Coordinates with other geometric objects

State Management:
    - Undo/Redo: Complete state archiving for ellipse operations
    - Canvas Integration: Immediate visual updates after modifications
    - Drawables Container: Proper storage and retrieval through container system

Dependencies:
    - drawables.ellipse: Ellipse geometric object
    - utils.math_utils: Mathematical utilities (though MathUtils import is unused)
```

**Class Documentation:**
```
Manages ellipse drawables for a Canvas.

This class is responsible for:
- Creating ellipse objects with center points, radii, and rotation angles
- Retrieving ellipse objects by coordinates, parameters, or name
- Deleting ellipse objects with proper cleanup and redrawing
```

**Key Methods:**
- `__init__(canvas, drawables_container, name_generator, dependency_manager, point_manager, drawable_manager_proxy)`: Initialize the EllipseManager with dependencies
- `get_ellipse(center_x, center_y, radius_x, radius_y)`: Get an ellipse by its center coordinates and radii (Note: does not consider rotation angle)
- `get_ellipse_by_name(name)`: Get an ellipse by its name
- `create_ellipse(center_x, center_y, radius_x, radius_y, rotation_angle=0, name="", extra_graphics=True)`: Create an ellipse with specified center, radii, and rotation angle
- `delete_ellipse(name)`: Delete an ellipse by its name with cleanup and canvas redraw

#### Function Manager (`managers/function_manager.py`)

**File Header:**
```
MatHud Function Management System

Manages mathematical function creation, modification, and deletion for graph visualization.
Handles function plotting with expression validation, bounds management, and colored area integration.

Core Responsibilities:
    - Function Creation: Creates mathematical function objects from string expressions
    - Function Modification: Updates existing function expressions and bounds
    - Function Deletion: Safe removal with cleanup of associated colored areas
    - Expression Validation: Ensures mathematical expressions are properly formatted

Mathematical Integration:
    - Expression Parsing: Converts string expressions to plottable mathematical functions
    - Bounds Management: Handles left and right domain boundaries for function visualization
    - Domain Validation: Ensures mathematical validity of function domains
    - Function Evaluation: Supports real-time function plotting and computation

Advanced Features:
    - Expression Fixing: Automatic correction of common mathematical notation issues
    - Function Updates: Modifies existing functions without recreation
    - Name Generation: Systematic naming for function identification
    - Colored Area Integration: Automatic cleanup of dependent area visualizations

Integration Points:
    - ExpressionValidator: Mathematical expression parsing and validation
    - ColoredAreaManager: Manages function-bounded area visualizations
    - Canvas: Handles function plotting and visual updates
    - DrawableManager: Coordinates with other geometric objects

Expression Support:
    - Mathematical Functions: sin, cos, tan, log, exp, sqrt, and more
    - Variables: x as primary variable for function expressions
    - Constants: pi, e, and other mathematical constants
    - Operations: Standard arithmetic and advanced mathematical operations

State Management:
    - Undo/Redo: Complete state archiving for function operations
    - Canvas Integration: Immediate visual updates after modifications
    - Dependency Tracking: Maintains relationships with colored areas
    - Expression Persistence: Preserves function expressions across operations
```

**Class Documentation:**
```
Manages function drawables for a Canvas with mathematical expression support.

Handles the complete lifecycle of mathematical function objects from expression
parsing through visualization to deletion with proper cleanup of dependencies.
```

**Key Methods:**
- `__init__(canvas, drawables_container, name_generator, dependency_manager, drawable_manager_proxy)`: Initialize the FunctionManager with dependencies
- `get_function(name)`: Get a function by its name
- `draw_function(function_string, name, left_bound=None, right_bound=None)`: Draw a function on the canvas or update existing function
- `delete_function(name)`: Delete a function by its name with cleanup of associated colored areas

#### Colored Area Manager (`managers/colored_area_manager.py`)

**File Header:**
```
MatHud Colored Area Management System

Manages colored area creation, deletion, and style management for mathematical region visualization.
Handles areas bounded by functions, segments, or mixed boundaries with automatic type detection.

Core Responsibilities:
    - Area Creation: Creates colored regions between mathematical boundaries
    - Area Deletion: Safe removal with cleanup of dependencies
    - Type Detection: Automatically determines area type based on boundary objects
    - Style Management: Handles color and opacity customization

Supported Area Types:
    - Function-Function Areas: Regions between two mathematical functions
    - Segment-Segment Areas: Regions between line segments and axes
    - Function-Segment Areas: Mixed regions between functions and segments
    - Axis Integration: Areas between objects and coordinate axes

Advanced Features:
    - Automatic Type Detection: Determines appropriate area class based on boundaries
    - Smart Boundary Handling: Manages x-axis references and null boundaries
    - Intersection Calculation: Creates boundary points for accurate area representation
    - Color Validation: Ensures valid color and opacity values

Integration Points:
    - FunctionManager: Retrieves function objects for boundary definition
    - SegmentManager: Retrieves segment objects and creates intersection points
    - StyleUtils: Validates color and opacity parameters
    - Canvas: Handles area rendering and visual updates

Mathematical Context:
    - Integration Visualization: Represents definite integrals as colored areas
    - Geometric Analysis: Shows relationships between mathematical objects
    - Boundary Calculations: Handles complex boundary intersections
    - Domain Management: Respects function domains and segment ranges

State Management:
    - Undo/Redo: Complete state archiving for area operations
    - Dependency Tracking: Maintains relationships with boundary objects
    - Canvas Integration: Immediate visual updates after modifications
    - Cleanup Logic: Intelligent removal of areas when boundaries are deleted
```

**Class Documentation:**
```
Manages colored area drawables for a Canvas.

This class is responsible for:
- Creating colored area objects
- Retrieving colored area objects
- Deleting colored area objects
```

**Key Methods:**
- `__init__(canvas, drawables_container, name_generator, dependency_manager, drawable_manager_proxy)`: Initialize the ColoredAreaManager with dependencies
- `create_colored_area(drawable1_name, drawable2_name=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3)`: Creates a colored area between functions, segments, or mixed boundaries with automatic type detection
- `delete_colored_area(name)`: Delete a colored area by its name with undo state archiving
- `delete_colored_areas_for_function(func)`: Deletes all colored areas associated with a function
- `delete_colored_areas_for_segment(segment)`: Deletes all colored areas associated with a segment
- `get_colored_areas_for_drawable(drawable)`: Gets all colored areas associated with a drawable (function or segment)
- `update_colored_area_style(name, color=None, opacity=None)`: Updates the color and/or opacity of a colored area
- `create_drawables_from_new_connections()`: Create drawables from new connections
- `create_angle(vx, vy, p1x, p1y, p2x, p2y, label=None, color=None, angle_name=None)`: Create an angle by points
- `delete_angle(name)`: Delete an angle by name
- `update_angle(name, new_color=None)`: Update angle properties

#### Angle Manager (`managers/angle_manager.py`)

**File Header:**
```
MatHud Angle Management System

Manages angle creation, retrieval, and deletion for angular measurement and visualization.
Handles angle construction from vertex points and arm segments with reflex angle support.

Core Responsibilities:
    - Angle Creation: Creates angles from vertex and arm-defining points
    - Angle Retrieval: Lookup by name, constituent segments, or defining points
    - Angle Deletion: Safe removal with dependency cleanup
    - Property Management: Updates angle colors and visual properties

Geometric Construction:
    - Vertex-Based Definition: Uses common vertex point and two arm-defining points
    - Automatic Segment Creation: Creates underlying segments for angle arms
    - Reflex Angle Support: Handles both standard and reflex angle measurements
    - Point Integration: Seamless creation and management of defining points

Advanced Features:
    - Dependency Tracking: Maintains relationships with constituent segments
    - State Management: Preserves angle properties during operations
    - Collision Detection: Prevents creation of duplicate angles
    - Event Handling: Responds to segment updates and deletions

Integration Points:
    - PointManager: Creates and manages vertex and arm-defining points
    - SegmentManager: Creates and manages angle arm segments
    - DependencyManager: Tracks angle relationships with constituent elements
    - Canvas: Handles angle rendering and visual updates

Mathematical Properties:
    - Angle Measurement: Supports angular calculations and degree measurements
    - Orientation Detection: Handles clockwise and counterclockwise orientations
    - Reflex Calculations: Manages angles greater than 180 degrees
    - Collinearity Validation: Prevents creation of degenerate angles

State Persistence:
    - Serialization: Saves and loads angle states for workspace management
    - Property Updates: Modifies angle properties without recreation
    - Cleanup Logic: Intelligent removal when constituent segments are deleted
    - Undo/Redo: Complete state archiving for angle operations
```

**Class Documentation:**
```
Manages Angle drawables for a Canvas.
This class is responsible for:
- Creating Angle objects, including their underlying points and segments if needed.
- Retrieving Angle objects by name, constituent segments, or defining points.
- (Future) Deleting Angle objects and managing their dependencies.
```

**Key Methods:**
- `__init__(canvas, drawables_container, name_generator, dependency_manager, point_manager, segment_manager, drawable_manager_proxy)`: Initialize the AngleManager with all required dependencies
- `create_angle(vx, vy, p1x, p1y, p2x, p2y, color=None, angle_name=None, is_reflex=False, extra_graphics=True)`: Creates an angle defined by a vertex point and two arm-defining points
- `get_angle_by_name(name)`: Retrieves an Angle by its unique name
- `get_angle_by_segments(segment1, segment2, is_reflex_filter=None)`: Retrieves an Angle by its two defining Segment objects
- `get_angle_by_points(vertex_point, arm1_point, arm2_point, is_reflex_filter=None)`: Retrieves an Angle by its three defining Point objects
- `delete_angle(angle_name)`: Delete an angle by name with dependency cleanup
- `update_angle(angle_name, new_color=None)`: Update angle properties like color
- `handle_segment_updated(updated_segment_name)`: Handle updates when constituent segments change
- `handle_segment_removed(removed_segment_name)`: Handle cleanup when constituent segments are deleted
- `load_angles(angles_data)`: Load angles from state data for workspace restoration
- `get_angles_state()`: Get serialized state of all angles for workspace saving
- `clear_angles()`: Remove all angles from the container

### Utility Modules

#### Math Utils (`utils/math_utils.py`)

**File Header:**
```
MatHud Mathematical Utilities Module

Comprehensive mathematical computation library for geometric analysis, symbolic algebra, and numerical calculations.
Provides the mathematical foundation for all geometric objects and canvas operations.

Key Features:
    - Geometric analysis: point matching, distance, area, angle calculations
    - Coordinate validation and tolerance-based comparisons
    - Line and curve equation generation (lines, circles, ellipses)
    - Symbolic mathematics: derivatives, integrals, limits, simplification
    - System of equations solving (linear, quadratic, mixed systems)
    - Statistical functions: mean, median, mode, variance
    - Asymptote and discontinuity analysis for function plotting
    - Rectangle and triangle validation algorithms

Mathematical Categories:
    - Point/Segment Operations: coordinate matching, distance, collinearity
    - Shape Analysis: area calculations, centroid finding, geometric validation
    - Equation Generation: algebraic formulas for geometric objects
    - Symbolic Computation: calculus operations via MathJS integration
    - Numerical Methods: equation solving, statistical analysis
    - Function Analysis: asymptotes, discontinuities, behavior analysis

Tolerance System:
    - EPSILON = 1e-9: Global tolerance for floating-point comparisons
    - Adaptive thresholds for segment-based calculations
    - Coordinate-aware precision handling

Dependencies:
    - browser.window: MathJS library integration for symbolic math
    - math: Standard mathematical functions and constants
    - statistics: Statistical computation functions
    - drawables.position: Coordinate container for geometric calculations
```

**Class Documentation:**
```
Comprehensive mathematical utilities class for geometric analysis and symbolic computation.

Provides static methods for all mathematical operations required by the MatHud canvas system,
including coordinate validation, geometric calculations, equation generation, and symbolic mathematics.

Class Attributes:
    EPSILON (float): Global tolerance constant (1e-9) for floating-point comparisons
```

**Key Methods:**
- `format_number_for_cartesian(n, max_digits=6)`: Formats the number to a string with a maximum number of significant digits or in scientific notation
- `point_matches_coordinates(point, x, y)`: Check if a point matches given coordinates within tolerance
- `segment_matches_coordinates(segment, x1, y1, x2, y2)`: Check if a segment matches given endpoint coordinates in any order
- `segment_matches_point_names(segment, p1_name, p2_name)`: Check if a segment connects two points by their names
- `segment_has_end_point(segment, x, y)`: Check if a segment has an endpoint at the given coordinates
- `get_2D_distance(p1, p2)`: Calculate Euclidean distance between two points in 2D space
- `get_2D_midpoint(p1, p2)`: Calculate the midpoint between two points in 2D space
- `is_point_on_segment(px, py, sp1x, sp1y, sp2x, sp2y)`: Check if a point lies on a line segment between two endpoints
- `get_triangle_area(p1, p2, p3)`: Calculate the area of a triangle given three points
- `get_triangle_centroid(p1, p2, p3)`: Calculate the centroid (center of mass) of a triangle
- `get_rectangle_area(diagonal_p1, diagonal_p2)`: Calculate rectangle area using diagonal points
- `cross_product(origin, p1, p2)`: Calculate the cross product of two vectors
- `dot_product(origin, p1, p2)`: Calculate the dot product of two vectors
- `calculate_angle_degrees(vertex_coords, arm1_coords, arm2_coords)`: Calculate angle in degrees between three points
- `are_points_valid_for_angle_geometry(vertex_coords, arm1_coords, arm2_coords)`: Validate if three points can form a valid angle
- `is_right_angle(origin, p1, p2)`: Check if three points form a right angle
- `is_rectangle(x1, y1, x2, y2, x3, y3, x4, y4)`: Check if four points form a rectangle
- `evaluate_expression_using_python(expression)`: Evaluate mathematical expression using Python's eval
- `points_orientation(p1x, p1y, p2x, p2y, p3x, p3y)`: Find orientation of ordered triplet of points
- `segments_intersect(s1x1, s1y1, s1x2, s1y2, s2x1, s2y1, s2x2, s2y2)`: Check if two line segments intersect
- `get_line_formula(x1, y1, x2, y2)`: Calculate the algebraic line equation from two points
- `get_segments_intersection(s1_x1, s1_y1, s1_x2, s1_y2, s2_x1, s2_y1, s2_x2, s2_y2)`: Find intersection point of two line segments
- `get_circle_formula(x, y, r)`: Generate circle equation in algebraic form
- `get_ellipse_formula(x, y, rx, ry, rotation_angle=0)`: Generate ellipse equation with optional rotation
- `try_convert_to_number(value)`: Safely convert value to number
- `sqrt(x)`: Calculate square root using MathJS
- `pow(x, exp)`: Calculate power using MathJS
- `det(matrix)`: Calculate matrix determinant using MathJS
- `convert(value, from_unit, to_unit)`: Unit conversion using MathJS
- `evaluate(expression, variables=None)`: Evaluate mathematical expression using MathJS
- `derivative(expression, variable)`: Calculate derivative using MathJS
- `limit(expression, variable, value_to_approach)`: Calculate limit using MathJS
- `integral(expression, variable, lower_bound=None, upper_bound=None)`: Calculate integral using MathJS
- `simplify(expression)`: Simplify mathematical expression using MathJS
- `expand(expression)`: Expand mathematical expression using MathJS
- `factor(expression)`: Factor mathematical expression using MathJS
- `get_equation_type(equation)`: Determine the type of mathematical equation
- `determine_max_number_of_solutions(equations)`: Determine maximum number of solutions for equation system
- `solve(equation, variable)`: Solve equation for specified variable using MathJS
- `solve_linear_system(equations)`: Solve system of linear equations
- `solve_linear_quadratic_system(equations)`: Solve mixed linear-quadratic equation system
- `solve_quadratic_system(equations)`: Solve system of quadratic equations
- `solve_system_of_equations(equations)`: Main system solver with type detection
- `random(min_value=0, max_value=1)`: Generate random number
- `round(value, ndigits=0)`: Round number to specified digits
- `gcd(*values)`: Calculate greatest common divisor
- `lcm(*values)`: Calculate least common multiple
- `mean(values)`: Calculate arithmetic mean
- `median(values)`: Calculate median value
- `mode(values)`: Calculate mode of values
- `stdev(values)`: Calculate standard deviation
- `variance(values)`: Calculate variance
- `calculate_vertical_asymptotes(function_string, left_bound=None, right_bound=None)`: Find vertical asymptotes of function
- `calculate_horizontal_asymptotes(function_string)`: Find horizontal asymptotes of function
- `calculate_asymptotes_and_discontinuities(function_string, left_bound=None, right_bound=None)`: Complete asymptote and discontinuity analysis
- `calculate_point_discontinuities(function_string, left_bound=None, right_bound=None)`: Find point discontinuities in function
- `triangle_matches_coordinates(triangle, x1, y1, x2, y2, x3, y3)`: Check if triangle matches given coordinates
- `find_diagonal_points(points, rect_name_for_warning)`: Find diagonal points for rectangle construction

#### Style Utils (`utils/style_utils.py`)

**File Header:**
```
MatHud Style Utilities Module

CSS validation and styling utilities for mathematical visualization objects.
Provides validation functions for colors, opacity values, and other styling properties.

Key Features:
    - CSS color validation for named colors, hex values, rgb(), rgba(), hsl(), hsla()
    - Opacity value validation (0.0 to 1.0 range)
    - Combined color and opacity validation
    - Comprehensive named color support (HTML/CSS standard colors)

Supported Color Formats:
    - Named colors: Standard CSS color names (red, blue, etc.)
    - Hex colors: #RGB and #RRGGBB formats
    - Functional colors: rgb(), rgba(), hsl(), hsla() formats

Validation Features:
    - Type safety for opacity values
    - Range checking for opacity (0-1)
    - Format validation for all color types
    - Error handling with descriptive messages

Dependencies:
    - None (pure validation utilities)
```

**Class Documentation:**
```
CSS styling validation utilities for mathematical visualization objects.

Provides static methods for validating color values, opacity settings, and other
styling properties used throughout the MatHud canvas system.
```

**Key Methods:**
- `is_valid_css_color(color)`: Validates if a string is a valid CSS color. Supports named colors, hex colors, rgb(), rgba(), hsl(), and hsla()
- `validate_opacity(opacity)`: Validates if an opacity value is between 0 and 1
- `validate_color_and_opacity(color, opacity)`: Validates both color and opacity values

#### Geometry Utils (`utils/geometry_utils.py`)

**File Header:**
```
MatHud Geometry Utilities Module

Graph theory and geometric analysis utilities for connectivity and relationship validation.
Provides functions for analyzing connections between geometric objects and validating graph structures.

Key Features:
    - Point name extraction from segment collections
    - Graph connectivity analysis for geometric networks
    - Segment relationship validation
    - Unique identifier management for geometric objects

Graph Theory Operations:
    - Fully connected graph validation
    - Point-to-segment mapping
    - Connectivity analysis for shape construction
    - Network topology validation

Use Cases:
    - Triangle validation (three connected segments)
    - Rectangle validation (four connected segments in proper topology)
    - Shape completion checking
    - Geometric network analysis

Dependencies:
    - itertools.combinations: Graph pair analysis
    - utils.math_utils: Segment matching operations
```

**Class Documentation:**
```
Graph theory and geometric analysis utilities for connectivity validation.

Provides static methods for analyzing relationships between geometric objects,
particularly for validating connectivity in geometric networks and shapes.
```

**Key Methods:**
- `get_unique_point_names_from_segments(segments)`: Extract unique point names from a list of segments
- `is_fully_connected_graph(list_of_point_names, segments)`: Check if all points in the list are connected by segments

#### Computation Utils (`utils/computation_utils.py`)

**File Header:**
```
MatHud Computation Utilities Module

Computation history management and expression tracking utilities.
Provides functions for managing mathematical computation history and avoiding duplicate calculations.

Key Features:
    - Computation history tracking
    - Duplicate expression detection
    - Expression-result pair management
    - Computation history persistence

History Management:
    - Expression uniqueness validation
    - Result caching and retrieval
    - Computation deduplication
    - History list maintenance

Use Cases:
    - AI computation result tracking
    - Mathematical expression caching
    - Computation history display
    - Performance optimization through caching

Dependencies:
    - None (pure data management utilities)
```

**Class Documentation:**
```
Computation history management utilities for mathematical expression tracking.

Provides static methods for managing computation history, detecting duplicates,
and maintaining a record of mathematical calculations performed in the canvas.
```

**Key Methods:**
- `has_computation(computations, expression)`: Check if a computation with the given expression already exists
- `add_computation(computations, expression, result)`: Add a computation to the history if it doesn't already exist

### Name Generators

#### Base Name Generator (`name_generator/base.py`)

**File Header:**
```
MatHud Base Name Generation System

Abstract base class for systematic naming of mathematical objects.
Provides the foundation for consistent naming conventions across object types.

Key Features:
    - Common name utilities and validation
    - Drawable name retrieval by class type
    - String filtering for mathematical naming
    - Canvas integration for name conflict detection

Dependencies:
    - re: Regular expression pattern matching for name filtering
```

**Class Documentation:**
```
Base class for name generation systems with common utilities.

Provides shared functionality for systematic naming of mathematical objects
including name filtering, drawable retrieval, and canvas integration.

Attributes:
    canvas (Canvas): Canvas instance for accessing drawable objects
```

**Key Methods:**
- `__init__(canvas)`: Initialize base name generator with canvas reference
- `get_drawable_names(class_name)`: Get sorted list of names for drawables of a specific class
- `filter_string(name)`: Filter a string to keep only letters, apostrophes, digits, and parentheses

#### Drawable Name Generator (`name_generator/drawable.py`)

**File Header:**
```
MatHud Multi-Type Drawable Name Generator

Coordinated name generation system managing names across all drawable object types.
Provides unified naming interface with type-specific delegation.

Key Features:
    - Multi-type name coordination (points, functions, shapes, areas)
    - Type-specific naming strategy delegation
    - Global name uniqueness validation
    - Angle name generation from geometric relationships

Dependencies:
    - name_generator.point: Point naming system
    - name_generator.function: Function naming system
```

**Class Documentation:**
```
Coordinates name generation across all drawable object types.

Manages type-specific name generators and provides unified interface
for consistent naming throughout the mathematical visualization system.

Attributes:
    canvas (Canvas): Canvas instance for drawable object access
    used_letters_from_names (dict): Backward compatibility tracking
    point_generator (PointNameGenerator): Specialized point name generator
    function_generator (FunctionNameGenerator): Specialized function name generator
```

**Key Methods:**
- `__init__(canvas)`: Initialize multi-type name generator with specialized generators
- `reset_state()`: Reset the state of all specialized name generators
- `print_names()`: Print all drawable names by category for debugging
- `get_drawable_names(class_name)`: Get sorted list of names for drawables of a specific class
- `filter_string(name)`: Filter a string to keep only letters, apostrophes, digits, and parentheses
- `split_point_names(expression, n=2)`: Split a point expression into individual point names
- `generate_point_name(preferred_name)`: Generate a unique point name, using preferred_name if possible
- `generate_function_name(preferred_name)`: Generate a unique function name, using preferred_name if possible
- `generate_angle_name_from_segments(segment1_name, segment2_name)`: Generate canonical angle name from two segment names

#### Point Name Generator (`name_generator/point.py`)

**File Header:**
```
MatHud Point Name Generation System

Alphabetical naming system for geometric points following mathematical conventions.
Provides systematic progression through single and multiple letter combinations.

Key Features:
    - Alphabetical sequence progression (A, B, C, ..., Z, A', B', ...)
    - Mathematical naming conventions support
    - Name collision detection and resolution
    - Expression parsing for multi-point extraction

Dependencies:
    - re: Regular expression pattern matching for name parsing
    - name_generator.base: Base class functionality
```

**Class Documentation:**
```
Generates alphabetical names for geometric points.

Implements systematic alphabetical progression for point naming
following standard mathematical conventions with apostrophe extensions.

Attributes:
    canvas (Canvas): Canvas instance for accessing drawable objects
    used_letters_from_names (dict): Tracks which letters have been used for each name
```

**Key Methods:**
- `__init__(canvas)`: Initialize point name generator with canvas reference
- `reset_state()`: Reset the internal tracking of used letters from names
- `split_point_names(expression, n=2)`: Split a point expression into individual point names
- `generate_point_name(preferred_name)`: Generate a unique point name, using preferred_name if possible
- `_generate_unique_point_name()`: Generate a unique point name using alphabetical sequence with apostrophes
- `_find_available_name_from_alphabet(alphabet, existing_names)`: Find an available name from an alphabet, adding apostrophes as needed
- `_try_add_apostrophes(base_letter, point_names, initial_count=1, max_attempts=5)`: Try adding apostrophes to a base letter until finding an unused name

#### Function Name Generator (`name_generator/function.py`)

**File Header:**
```
MatHud Function Name Generation System

Mathematical function naming system using standard notation conventions.
Provides systematic naming for mathematical functions and expressions.

Key Features:
    - Standard mathematical notation (f, g, h, f1, f2, ...)
    - Function name incrementation with numeric suffixes
    - Parenthesis handling for function expressions
    - Collision detection and resolution

Dependencies:
    - re: Regular expression pattern matching for name parsing
    - itertools.count: Infinite counting for name generation
    - name_generator.base: Base class functionality
```

**Class Documentation:**
```
Generates mathematical names for function objects.

Implements systematic function naming using mathematical notation
conventions with support for standard and extended naming patterns.

Attributes:
    canvas (Canvas): Canvas instance for accessing drawable objects
```

**Key Methods:**
- `_extract_number_suffix(func_name)`: Extract a numeric suffix from a function name if present
- `_increment_function_name(func_name)`: Increment a function name by adding or incrementing a number suffix
- `_generate_unique_function_name()`: Generate a unique function name using alphabetical sequence
- `generate_function_name(preferred_name)`: Generate a unique function name, using preferred_name if possible
- `_extract_function_name_before_parenthesis(preferred_name)`: Extract the function name before any parenthesis
- `_find_available_function_name(preferred_name, function_names)`: Find an available function name based on the preferred name
- `reset_state()`: Reset any internal state for function naming

### Supporting Files

#### Expression Evaluator (`expression_evaluator.py`)

**File Header:**
```
MatHud Mathematical Expression Evaluator

Handles evaluation of mathematical expressions and function calls within the canvas system.
Supports both numeric computations and custom function evaluation with error handling.

Evaluation Types:
    - Numeric expressions: Basic mathematical operations with variables
    - Function expressions: Canvas-defined functions with argument substitution
    - Hybrid evaluation: Fallback from numeric to function evaluation

Dependencies:
    - utils.math_utils: Core mathematical computation engine
    - re: Regular expression parsing for function calls
```

**Class Documentation:**
```
Handles evaluation of mathematical expressions and custom functions.

Provides static methods for evaluating numeric expressions and canvas-defined
functions with comprehensive error handling and type consistency.
```

**Key Methods:**
- `evaluate_numeric_expression(expression, variables)`: Evaluates a numeric mathematical expression with variable substitution
- `evaluate_function(expression, canvas)`: Evaluates a function expression using canvas-defined functions
- `evaluate_expression(expression, variables=None, canvas=None)`: Main method to evaluate expressions with fallback from numeric to function evaluation

#### Function Registry (`function_registry.py`)

**File Header:**
```
MatHud Function Registry System

Central registry for mapping AI function names to their implementations.
Manages available functions and defines which operations support undo/redo functionality.

Function Categories:
    - Canvas operations: reset, clear, undo, redo
    - Geometric shapes: points, segments, vectors, triangles, rectangles, circles, ellipses
    - Mathematical functions: plotting, evaluation, symbolic computation
    - Object transformations: translate, rotate
    - Workspace management: save, load, list, delete
    - Special features: colored areas, angle measurement, testing

Dependencies:
    - utils.math_utils: Mathematical computation functions
    - process_function_calls: Expression evaluation facade
```

**Class Documentation:**
```
Static registry mapping function names to implementations and undo capabilities.

Maintains the central mapping between AI function names and their Python implementations,
and defines which functions support undo/redo operations for state management.
```

**Key Methods:**
- `get_available_functions(canvas, workspace_manager, ai_interface=None)`: Get the complete dictionary of all available functions with their implementations
- `get_undoable_functions()`: Get the tuple of function names that support undo/redo operations

#### Process Function Calls (`process_function_calls.py`)

**File Header:**
```
MatHud Function Call Processing Facade

Main coordinator for processing AI function calls, expression evaluation, and result validation.
Provides a unified interface to the various specialized processing modules for backward compatibility.

Key Features:
    - Expression evaluation with variable substitution
    - Function call execution and result collection
    - Result validation and error detection
    - Canvas state management during processing

Dependencies:
    - expression_evaluator: Mathematical expression parsing and computation
    - result_processor: Function call execution and result aggregation
    - result_validator: Result structure and success validation
```

**Class Documentation:**
```
Main facade for processing function calls, evaluating expressions, and validating results.

This class serves as a unified interface for the various specialized processing modules,
maintaining backward compatibility while delegating to appropriate specialized handlers.
```

**Key Methods:**
- `evaluate_expression(expression, variables=None, canvas=None)`: Evaluates a mathematical expression with optional variable substitution
- `get_results(calls, available_functions, undoable_functions, canvas)`: Process function calls and collect their results with state management
- `validate_results(results)`: Validates result structure and data types for integrity
- `is_successful_result(value)`: Checks if a result represents successful computation vs error

#### Constants (`constants.py`)

**File Header:**
```
MatHud Client-Side Constants Configuration

Global configuration values for the mathematical canvas visualization system.
Defines styling, interaction thresholds, and performance parameters for consistent behavior.

Categories:
    - Visual Styling: Point sizes, colors, fonts
    - User Interaction: Click thresholds, zoom factors
    - Angle Visualization: Arc display and text positioning
    - Performance: Event throttling for smooth interactions

Dependencies:
    - None (pure configuration module)
```

**Key Constants:**
- `default_point_size`: Default size for point objects (2 pixels)
- `default_color`: Default color for canvas elements ("black")
- `default_font_size`: Default font size for text elements (16)
- `point_label_font_size`: Font size for point labels (5/8 ratio of default)
- `successful_call_message`: Success message for function calls ("Call successful!")
- `double_click_threshold_s`: Maximum time between clicks for double-click detection (0.2 seconds)
- `DEFAULT_ANGLE_COLOR`: Default color for angle indicators ("blue")
- `DEFAULT_ANGLE_ARC_SCREEN_RADIUS`: Arc radius in pixels for angle indicators (15)
- `DEFAULT_ANGLE_TEXT_ARC_RADIUS_FACTOR`: Text positioning relative to arc radius (1.8)
- `zoom_in_scale_factor`: Scale factor for zoom in operations (1.1)
- `zoom_out_scale_factor`: Scale factor for zoom out operations (0.9)
- `mousemove_throttle_ms`: Mouse movement throttling for smooth panning (8ms)

#### Geometry (`geometry.py`)

**File Header:**
```
MatHud Geometry Module

Convenience import aggregator for all drawable geometric objects.
Provides a single import point for all mathematical visualization classes.

Exported Classes:
    - Drawable: Base class for all canvas objects
    - Point, Position: Point and position representations
    - Segment, Vector: Line-based geometric objects  
    - Triangle, Rectangle: Polygon shapes
    - Circle, Ellipse: Curved geometric objects
    - Function: Mathematical function plotting

Dependencies:
    - drawables.*: Individual geometric class implementations
```

**Exported Classes:**
- `Drawable`: Base class for all canvas objects
- `Point`: Point geometric object with coordinates
- `Position`: 2D coordinate pair container
- `Segment`: Line segment between two points
- `Vector`: Directed line segment with arrow
- `Triangle`: Three-sided polygon
- `Rectangle`: Four-sided polygon
- `Circle`: Circular geometric object
- `Ellipse`: Elliptical geometric object
- `Function`: Mathematical function plotting object

#### Result Validator (`result_validator.py`)

**File Header:**
```
MatHud Result Validation System

Validates the structure and content of AI function call results.
Ensures data integrity and distinguishes between successful computations and errors.

Validation Features:
    - Structure validation: Checks result dictionary format and types
    - Success detection: Identifies successful vs failed computations
    - Type safety: Enforces allowed data types for results

Dependencies:
    - constants: Success message definitions
```

**Class Documentation:**
```
Handles validation of function call results and error detection.

Provides static methods for validating result structure and determining
whether function calls completed successfully or encountered errors.
```

**Key Methods:**
- `validate_results(results)`: Validates that results have the correct structure and data types
- `is_successful_result(value)`: Checks if a result value represents a successful computation


#### HTML Template (`templates/index.html`)

**File Header:**
```
MatHud Mathematical Canvas Web Interface

Main HTML template for the interactive mathematical graphing calculator.
Provides AI-powered canvas for geometric shapes, calculations, and mathematical exploration.

Key Components:
    - MathJax: LaTeX mathematical notation rendering
    - Brython: Python-in-browser execution for canvas operations
    - SVG Canvas: Interactive mathematical visualization area
    - Chat Interface: AI communication with model selection and vision toggle
    - Responsive Layout: Dual-pane interface (canvas + chat)

Dependencies:
    - Google Fonts (Inter): Modern typography
    - MathJax 3: Mathematical equation rendering
    - Brython 3.12.5: Python runtime for browser-side logic (CDN)
    - Math.js 14.5.2: Mathematical computation library (CDN)
    - Nerdamer 1.1.13: Symbolic algebra and calculus (CDN with full modules)
    - Flask templates: Dynamic asset URL generation
```

**Key Sections:**
- **Head Section**: Meta tags, font loading, MathJax configuration, and Brython/math libraries from CDN
- **Math Container**: SVG canvas element for interactive mathematical visualizations
- **Chat Interface**: AI model selector, vision toggle, chat history display, and user input area
- **JavaScript Integration**: MathJax setup, Brython initialization, and vision toggle functionality

**Key Features:**
- **MathJax Configuration**: LaTeX rendering with inline `\(...\)` and display `$$...$$` math
- **AI Model Selection**: Dropdown with GPT-4 family and GPT-3.5-turbo options
- **Vision Toggle**: Conditional enabling based on model capabilities
- **Responsive Design**: Flexible dual-pane layout for different screen sizes

#### CSS Stylesheet (`static/style.css`)

**File Header:**
```
MatHud Mathematical Canvas Stylesheet

Modern CSS styling for the interactive mathematical graphing calculator interface.
Implements a dual-pane layout with responsive design and comprehensive theming system.

Architecture:
    - CSS Custom Properties: Consistent color scheme and spacing system
    - Flexbox Layout: Responsive dual-pane interface (60% canvas, 40% chat)
    - Component-Based Styling: Modular styles for chat, controls, and canvas areas
    - Responsive Design: Mobile-first approach with tablet and desktop breakpoints
    - Mathematical Typography: Specialized styling for LaTeX and mathematical notation

Key Features:
    - Modern Inter font family with multiple weights
    - Subtle shadows and rounded corners for depth
    - Hover states and smooth transitions for interactivity
    - Custom scrollbar styling for better UX
    - Markdown content support in chat messages
    - Accessible form controls with focus states

Dependencies:
    - Google Fonts (Inter): Loaded via HTML link
    - CSS Custom Properties: Modern browser support required
    - Flexbox: Modern layout system for responsive design
```

**Key Style Categories:**
- **Design Tokens**: CSS custom properties for colors, shadows, and spacing
- **Layout System**: Flexbox-based dual-pane container with responsive breakpoints
- **Chat Interface**: Comprehensive styling for messages, controls, and markdown content
- **Mathematical Content**: Specialized styling for LaTeX expressions and mathematical notation
- **Form Controls**: Modern input styling with focus states and accessibility features
- **Responsive Design**: Mobile and tablet breakpoints for optimal viewing on all devices

**Key Features:**
- **Color System**: Modern color palette with primary, secondary, and surface colors
- **Typography Scale**: Hierarchical text sizing with Inter font family
- **Shadow System**: Layered shadows for depth and visual hierarchy
- **Markdown Support**: Complete styling for headings, code blocks, tables, and mathematical expressions
- **Accessibility**: Focus indicators, color contrast, and keyboard navigation support

---

## Server-Side Components

### Server-Side Workspace Manager (`static/workspace_manager.py`)

**File Header:**
```
MatHud Server-Side Workspace Management

Handles workspace file operations for saving and loading canvas states.
Provides secure file operations with path validation and JSON-based storage.

Dependencies:
    - os: File system operations and path validation
    - json: Workspace state serialization and deserialization
    - re: Workspace name validation with regex
    - datetime: Timestamp generation for metadata
```

**Class Documentation:**
```
Server-side workspace file operations manager.

Manages saving, loading, listing, and deleting workspace files with
security validation and JSON-based state storage with metadata.

Attributes:
    workspaces_dir (str): Base directory for storing workspace files
```

**Key Methods:**
- `__init__(workspaces_dir=WORKSPACES_DIR)`: Initialize the workspace manager with base directory
- `save_workspace(state, name=None, test_dir=None)`: Save workspace state to file with metadata
- `load_workspace(name=None, test_dir=None)`: Load workspace state from file

### OpenAI API Integration (`static/openai_api.py`)

**File Header:**
```
MatHud OpenAI API Integration

Manages OpenAI API communication with chat completions, vision support, and tool calling.
Handles conversation history, message formatting, and model configuration.

Key Features:
    - Chat completions with OpenAI GPT models
    - Vision-enabled conversations with canvas image analysis
    - Tool calling for mathematical operations and canvas manipulation
    - Conversation history management with token optimization
    - Message content preparation with multimodal support
    - Canvas state cleaning for memory efficiency

Communication Flow:
    - User message processing with optional canvas vision
    - API request formation with conversation context
    - Response handling with tool call extraction
    - Conversation history updates and cleanup
    - Token optimization through state removal

Vision Integration:
    - Canvas screenshot encoding for AI analysis
    - Base64 image data embedding in messages
    - Vision toggle support for optional image inclusion
    - Model capability checking for vision features

Tool Calling Support:
    - Mathematical function execution coordination
    - Canvas operation tool definitions
    - Tool response message formatting
    - Client-side tool execution integration

Message Management:
    - Conversation history persistence
    - Canvas state removal for token efficiency
    - Image data cleanup after processing
    - Error response generation and handling

Dependencies:
    - openai: OpenAI API client library
    - dotenv: Environment variable loading for API keys
    - base64: Image encoding for vision requests
    - json: Message parsing and formatting
    - os: Environment variable access
    - static.functions_definitions: AI tool definitions
    - static.ai_model: Model configuration and capabilities
```

**Class Documentation:**
```
OpenAI API integration for chat completions with vision and tool calling support.

Manages conversation history, handles vision-enabled messages with image data,
and processes tool calls for mathematical operations and canvas manipulation.

Attributes:
    client (OpenAI): OpenAI API client instance
    model (AIModel): Current AI model configuration
    temperature (float): Response randomness setting
    max_tokens (int): Maximum response length
    tools (list): Available function definitions for tool calling
    messages (list): Conversation history with role-based messages
    DEV_MSG (str): System message defining AI behavior and capabilities
```

**Key Methods:**
- `_initialize_api_key()`: Initialize the OpenAI API key from environment or .env file (static method)
- `__init__(model=None, temperature=0.2, tools=FUNCTIONS, max_tokens=32000)`: Initialize OpenAI API client and conversation state
- `get_model()`: Get the current AI model instance
- `set_model(identifier)`: Set the AI model by identifier string
- `_remove_canvas_state_from_user_messages()`: Remove canvas state from the last user message in conversation history
- `_remove_images_from_user_messages()`: Remove image content from the last user message in conversation history
- `_clean_conversation_history()`: Clean up conversation history by removing canvas states and images
- `_create_enhanced_prompt_with_image(user_message)`: Create enhanced prompt with both text and base64 encoded image
- `_prepare_message_content(full_prompt)`: Prepare message content with optional canvas image for vision-enabled messages
- `_create_assistant_message(response_message)`: Create assistant message from API response message
- `_create_error_response(error_message)`: Create error response matching OpenAI's response structure
- `_create_tool_message(tool_call_id, content)`: Create tool message in response to a tool call
- `_append_tool_messages(tool_calls)`: Create and append tool messages for each tool call
- `create_chat_completion(full_prompt)`: Create chat completion with OpenAI API (main entry point)

### AI Function Definitions (`static/functions_definitions.py`)

**File Header:**
```
MatHud AI Function Definitions

Comprehensive set of 40+ AI function definitions for mathematical operations and canvas manipulation.
Provides OpenAI tool calling schema for geometric shapes, calculations, transformations, and workspace management.

Categories:
    - Canvas Operations: reset, clear, undo, redo, run_tests, zoom_to_bounds
    - Geometric Shapes: points, segments, vectors, triangles, rectangles, circles, ellipses, angles
    - Mathematical Functions: plotting, colored areas, bounded regions
    - Calculations: expressions, trigonometry, algebra, calculus
    - Transformations: translate, rotate, scale geometric objects
    - Workspace Management: save, load, list, delete workspaces

Dependencies:
    - OpenAI Function Calling: Structured function definitions with strict schema validation
    - JSON Schema: Parameter validation and type checking for all function arguments
```

**Key Components:**
- `FUNCTIONS`: Complete list of OpenAI function definitions with JSON schema
- Function categories: Canvas operations, geometric shapes, mathematical functions, calculations, transformations, workspace management
- `zoom_to_bounds`: Canvas zoom box tool that fits the viewport to explicit math bounds
- Parameter validation: Strict JSON schema enforcement for all function arguments
- Type safety: Required parameters and type checking for robust AI integration

### Flask Application Manager (`static/app_manager.py`)

**File Header:**
```
MatHud Flask Application Manager

Core Flask application configuration and initialization.
Manages dependency injection for AI API, WebDriver, workspace operations, and logging.

Dependencies:
    - Flask: Web framework core
    - static.openai_api: OpenAI API integration
    - static.webdriver_manager: Selenium WebDriver for vision system
    - static.workspace_manager: Workspace file operations
    - static.log_manager: Application logging
    - static.routes: Route definitions and registration
```

**Class Documentation:**
```
Manages core Flask application setup and utilities for the MatHud mathematical visualization system.

Coordinates Flask application initialization with comprehensive dependency injection for all core services.
Provides standardized API response formatting and error handling across the entire application.

Core Responsibilities:
    - Flask Application Factory: Creates and configures Flask app instances
    - Dependency Injection: Initializes and coordinates OpenAI API, WebDriver, workspace, and logging managers
    - Response Standardization: Consistent JSON API response formatting
    - Service Integration: Bridges Flask web framework with specialized application managers

Managed Dependencies:
    - OpenAIChatCompletionsAPI: AI-powered mathematical problem solving
    - WebDriverManager: Selenium-based vision system for canvas image capture
    - WorkspaceManager: File system operations and workspace organization
    - LogManager: Application-wide logging and debugging support
    - Route Registration: RESTful API endpoint configuration
```

**Key Methods:**
- `make_response(data=None, message=None, status='success', code=200)`: Create a consistent JSON response format (static method)
- `create_app()`: Create and configure the Flask application with all managers and routes (static method)

### Flask Route Definitions (`static/routes.py`)

**File Header:**
```
MatHud Flask Route Definitions

Defines all Flask application routes for AI communication, workspace management,
and WebDriver initialization. Handles JSON requests and provides consistent API responses.

Dependencies:
    - flask: Request handling, templating, and JSON processing
    - static.tool_call_processor: OpenAI tool call format conversion
    - static.app_manager: Consistent API response formatting
```

**Key Routes:**
- `@app.route('/')`: Main application page serving the mathematical visualization interface
- `@app.route('/init_webdriver')`: Initialize WebDriver for vision system after Flask startup
- `@app.route('/save_workspace', methods=['POST'])`: Save current workspace state to file
- `@app.route('/load_workspace', methods=['GET'])`: Load workspace state from file
- `@app.route('/list_workspaces', methods=['GET'])`: List all saved workspaces
- `@app.route('/delete_workspace', methods=['GET'])`: Delete workspace by name
- `@app.route('/send_message', methods=['POST'])`: Process AI chat messages with tool calling support

**Key Functions:**
- `register_routes(app)`: Register all routes with the Flask application instance
- `_process_ai_response(app, choice)`: Process AI response choice and log results

### Application Logging System (`static/log_manager.py`)

**File Header:**
```
MatHud Application Logging System

Session-based logging with timestamped entries for debugging and monitoring.
Creates daily log files and tracks user interactions, AI responses, and tool calls.

Dependencies:
    - logging: Python logging framework
    - os: File system operations
    - datetime: Timestamp generation
    - json: Message parsing and validation
```

**Class Documentation:**
```
Manages application logging operations.

Provides session-based logging with automatic file rotation by date.
Logs user messages, AI responses, tool calls, and system events.
```

**Key Methods:**
- `__init__(logs_dir='./logs/')`: Initialize LogManager with specified logs directory
- `_get_log_file_name()`: Get date-based log filename (private method)
- `_setup_logging()`: Initialize logging configuration with daily rotation (private method)
- `log_new_session()`: Log new session delimiter with timestamp
- `log_user_message(user_message)`: Log user message and parse JSON components
- `log_ai_response(ai_message)`: Log AI-generated response text
- `log_ai_tool_calls(ai_tool_calls)`: Log AI-requested function calls

### Selenium WebDriver Manager (`static/webdriver_manager.py`)

**File Header:**
```
MatHud Selenium WebDriver Management

Manages headless Firefox WebDriver for capturing canvas images for vision system.
Handles SVG state injection, page configuration, and screenshot capture operations.

Dependencies:
    - selenium: WebDriver automation framework
    - selenium.webdriver: Firefox WebDriver and configuration
    - selenium.webdriver.support: WebDriverWait and expected conditions
    - logging: Error logging for WebDriver operations
    - os: File system operations for screenshot storage
    - time: Timing delays for WebDriver operations
```

**Class Documentation:**
```
Manages Selenium WebDriver operations for capturing math visualizations.

Provides headless Firefox WebDriver for injecting SVG states and capturing
canvas screenshots for the vision system. Handles page configuration,
error recovery, and resource cleanup.
```

**Key Methods:**
- `__init__(base_url="http://127.0.0.1:5000/")`: Initialize WebDriverManager with base URL
- `capture_svg_state(svg_state)`: Update SVG state and capture canvas (main entry point)
- `update_svg_state(svg_state)`: Update SVG content and attributes with provided state
- `_setup_driver()`: Initialize Firefox WebDriver with headless mode (private method)
- `_configure_page_layout()`: Configure page layout for screenshot capture (private method)
- `capture_canvas()`: Capture math visualization canvas as PNG image
- `_wait_for_svg_elements()`: Wait for SVG elements to be present (private method)
- `_verify_svg_content()`: Verify SVG content is not empty (private method)
- `_get_container_dimensions()`: Get container dimensions for sizing (private method)
- `_configure_svg_size(dimensions)`: Configure SVG size for capture (private method)
- `cleanup()`: Clean up WebDriver resources

### AI Model Configuration (`static/ai_model.py`)

**File Header:**
```
MatHud AI Model Configuration

AI model definitions and capability management for OpenAI models.
Handles model-specific features like vision support and provides factory methods.

Dependencies:
    - None (pure configuration module)
```

**Class Documentation:**
```
AI model configuration and capability management.

Manages model-specific capabilities (like vision support) and provides
factory methods for creating model instances from identifiers.
```

**Key Methods:**
- `__init__(identifier, has_vision)`: Initialize AIModel instance with identifier and vision capability
- `from_identifier(identifier)`: Create AIModel instance from identifier string (static method)
- `get_default_model()`: Get the default AI model instance (static method)
- `__str__()`: String representation returning model identifier

**Key Attributes:**
- `MODEL_CONFIGS`: Dictionary of model configurations with capabilities
- `DEFAULT_MODEL`: Default model identifier string
- `id`: Model identifier string
- `has_vision`: Boolean indicating vision capability support

### Tool Call Processing Utilities (`static/tool_call_processor.py`)

**File Header:**
```
MatHud Tool Call Processing Utilities

Converts OpenAI tool call objects into JSON-serializable format for client processing.
Handles argument parsing and error recovery for malformed tool calls.

Dependencies:
    - json: JSON parsing and serialization
    - logging: Error logging for malformed arguments
```

**Class Documentation:**
```
Static class for processing tool calls into JSON-serializable format.

Provides utilities to convert OpenAI tool call objects into simplified
dictionaries that can be sent to the client-side function processing system.
```

**Key Methods:**
- `jsonify_tool_call(tool_call)`: Convert single tool call into JSON-serializable dictionary (static method)
- `jsonify_tool_calls(tool_calls)`: Convert list of tool calls into simplified format (static method)


### Rendering Modules

The rendering stack converts math-space drawables into Canvas2D, SVG, or WebGL output while keeping models renderer-agnostic.

#### Renderer Factory (`rendering/factory.py`)

```
Factory responsible for choosing and instantiating renderer backends.

Preference chain defaults to Canvas2D -> SVG -> WebGL. A caller-specified
`preferred` string is honored first, and the factory falls back when a
constructor raises or returns `None`. Helper `_build_preference_chain`
avoids duplicates, `_attempt_renderer` wraps instantiation with error
suppression, and `_safe_instantiate` guards against constructors that yield
`None`.
```

Key points:
1. Renderer modules (`rendering.canvas2d_renderer`, `rendering.svg_renderer`, `rendering.webgl_renderer`) load lazily so environments without WebGL can still construct other backends.
2. Each constructor returns an object implementing `RendererProtocol`; the factory does not mutate state beyond instantiation.

#### SVG Renderer (`rendering/svg_renderer.py`)

```
SVG-based renderer with rich plan caching and telemetry. Maintains separate
paths for cartesian grids and drawable groups, and reuses DOM nodes via
`SvgPrimitiveAdapter` pooling.
```

Highlights:
1. `_resolve_cartesian_plan` caches the most recent `OptimizedPrimitivePlan` per cartesian signature, evicting the previous group when a rebuild is required.
2. `_resolve_drawable_plan_context` manages per-drawable cache entries keyed by plan signature and drawable identity; stale entries are pruned by `_prune_unused_plan_entries` after each frame.
3. `_mark_screen_space_plan_dirty` keeps screen-space plans fresh across zoom operations, while telemetry hooks record apply/skip metrics.
4. Feature toggles `window.MatHudSvgOffscreen` and `localStorage["mathud.svg.offscreen"]` enable optional offscreen staging without changing the optimized path.

#### Canvas2D Renderer (`rendering/canvas2d_renderer.py`)

```
Primary renderer targeting the Canvas 2D API. Mirrors SVG's plan caching and
optionally composites via an offscreen canvas.
```

Highlights:
1. `_resolve_cartesian_plan` and `_resolve_drawable_plan` reuse cached `OptimizedPrimitivePlan` instances when signatures match, recording telemetry whenever a rebuild occurs.
2. `_initialize_layer_state` toggles offscreen compositing based on `window.MatHudCanvas2DOffscreen` or `localStorage["mathud.canvas2d.offscreen"]`.
3. `_flush_offscreen_to_main` copies the offscreen buffer back to the primary surface, while `begin_frame`/`end_frame` and telemetry accessors expose layer metrics.

#### WebGL Renderer (`rendering/webgl_renderer.py`)

```
Experimental renderer that targets WebGL through Brython's browser APIs.
Initializes shaders once, uploads geometry per draw call, and delegates
primitive operations to `WebGLPrimitiveAdapter`.
```

Highlights:
1. `_prepare_canvas_and_context` ensures the canvas element exists and retrieves the WebGL context, raising when unavailable.
2. `_parse_color` canonicalizes style strings via a scratch 2D canvas; `_parse_rgb_color` normalizes alpha values above 1 by dividing by 255.
3. `_prepare_vertices` maps math coordinates to normalized device coordinates before issuing GPU draw calls, while `_should_apply_plan` skips invisible work.

#### Renderables (`rendering/function_renderable.py`, etc.)

```
Function and area renderables convert math models into `OptimizedPrimitivePlan`
command lists so renderers consume screen-ready geometry.
```

Modules include `function_renderable.py`, `functions_area_renderable.py`, `function_segment_area_renderable.py`, and `segments_area_renderable.py`, each isolating sampling logic from math models.

#### Shared Drawable Renderers (`rendering/shared_drawable_renderers.py`)

```
Collection of helper functions that translate math-space drawables into
primitive commands shared across all backends.
```

Highlights:
1. `render_point_helper` emits circle primitives and label metadata describing math and screen positions.
2. `_compute_zoom_adjusted_font_size` clamps label font size based on mapper scale, hiding labels when they shrink below `label_vanish_threshold_px`.
3. Stroke/fill helpers centralize style coercion so adapters receive consistent instructions.

#### Style Manager (`rendering/style_manager.py`)

```
Provides renderer style dictionaries detached from the global defaults.

`get_renderer_style()` clones the internal base style before applying any
overrides, protecting shared state across renderers.
```

Key points:
1. `_clone_base_style` performs shallow copies for nested dict entries so modifying a returned style never mutates `_BASE_STYLE`.
2. `get_default_style_value` exposes canonical values for tests and callers.

#### Primitive Adapters

- **Canvas2D (`rendering/canvas2d_primitive_adapter.py`)**: Prepares fill and stroke batches, flushes polygons before line work, and reuses cached text brush settings.
- **WebGL (`rendering/webgl_primitive_adapter.py`)**: Converts stroke metadata into parsed colors and delegates to renderer `_draw_points`, `_draw_lines`, and `_draw_line_strip` helpers.
- **SVG (`rendering/svg_primitive_adapter.py`)**: Manages DOM pooling and re-parenting so cached plans can reuse existing nodes (see module for details).

#### Renderer Test Suites (`server_tests/client_renderer/`)

```
Pytest-based regression tests that exercise renderer logic under CPython using
lightweight browser stubs installed in `server_tests.client_renderer.__init__`.
```

Coverage highlights:
1. `test_renderer_factory_plan.py` validates factory fallback ordering and preferred renderer short-circuiting.
2. `test_webgl_renderer_plan.py` checks invisible-plan gating and RGBA alpha normalization in `_parse_color`.
3. `test_svg_renderer_plan.py` covers cartesian plan cache reuse and stale plan pruning.
4. `test_canvas2d_renderer_plan.py` focuses on cartesian plan signature changes and offscreen compositing flush behavior.
5. `test_renderer_support_plan.py` verifies shared helper metadata, `_map_state_equal` tolerance, style cloning, and `ClosedArea` defaults.

### Testing and Quality Assurance

MatHud implements a comprehensive dual-sided testing architecture that mirrors the application's client-server structure. The testing system ensures reliability across both the browser-based mathematical visualization components and the server-side AI integration services.

#### Client-Side Testing (`static/client/client_tests/tests.py`)
The client-side testing framework runs in the browser using Brython and covers all mathematical visualization components. The `Tests` class orchestrates comprehensive testing of:
- Mathematical utilities and geometric calculations
- Drawable objects (points, segments, shapes, functions)
- Canvas operations and coordinate systems
- AI interface and function call processing
- Expression validation and mathematical computations
- Name generation systems and dependency management

The client tests are integrated into the AI interface through `test_runner.py`, allowing the AI to validate system functionality in real-time and ensure mathematical operations produce expected results.

#### Server-Side Testing (`run_server_tests.py`)
The server-side testing uses pytest and focuses on Flask application components and API functionality. The `run_server_tests.py` script provides a command-line interface for:
- Testing Flask routes and HTTP endpoints
- Validating workspace management operations
- Verifying AI API integration and tool calling
- Testing WebDriver vision system functionality
- Ensuring proper error handling and response formatting

In addition to server-specific suites, the runner also executes CPython-based regression tests for client renderer classes located in `server_tests/client_renderer/`, using lightweight browser stubs to exercise `static/client` code directly from pytest.

The server tests are organized in the `server_tests/`

### Graph and Tree Tools
- `generate_graph(name?, graph_type, vertices, edges, adjacency_matrix?, directed?, root?, layout?, placement_box?)`: Programmatically place a graph, tree, or DAG on the canvas.
- `delete_graph(name)`: Remove a graph/tree and its associated points, edges, and weight labels.
- `analyze_graph(operation, graph_name, params?)`: Analyze an existing graph by name (must already exist on canvas).

Notes:
1. In this section, "graph" means graph theory vertices and edges (not function plotting and not dependency graphs).
2. Vertices are created as points on the canvas. Undirected edges render as segments; directed edges render as vectors.
3. If an edge has a numeric weight, it is rendered as a midpoint label on the segment/vector.

#### Creation (`generate_graph`)
Key behaviors:
1. **Graph types**: `graph` (general), `tree` (rooted), `dag` (directed acyclic graph).
2. **Vertices**: You can provide explicit coordinates per vertex, or omit them and let the layout engine place vertices automatically.
3. **Edges**: Edges reference vertices by index (0-based) in the provided vertices list. If you provide an adjacency matrix instead, row/column order follows that same vertex order.
4. **Placement box**: `placement_box` is in math coordinates (y increases upward). It constrains the layout so the graph lands in a predictable region.
5. **Layout**: `layout` is a hint. Supported modes include `tree`/`hierarchical`, `radial`, `circular`, `grid`, and `force`. Trees default to a top-down tree layout unless you explicitly request `radial`.

#### Analysis (`analyze_graph`)
Supported `operation` values:
1. Path/structure: `shortest_path`, `mst`, `topological_sort`, `bfs`, `dfs`, `levels`, `diameter`, `lca`
2. Connectivity: `bridges`, `articulation_points`, `bipartite`, `euler_status`
3. Tree transforms: `balance_children`, `invert_children`, `reroot`
4. Geometry on graph vertices: `convex_hull`, `point_in_hull`

Common `params` usage (high-level):
1. `shortest_path`: requires `start` and `goal` (use the vertex names you see on the canvas, like `A` and `D`). If any weights exist, the shortest path uses weighted cost.
2. `bfs` / `dfs`: use `start`.
3. `levels`: uses `root` (or the stored tree root).
4. `lca`: uses `root`, `a`, `b`.
5. `reroot`: uses `new_root` (and optionally `root`).
6. `point_in_hull`: uses numeric `x` and `y`.

Return data:
1. Operations return structured data like `path`, `cost`, `edges`, `order`, `levels`, etc.
2. Many operations also return `highlight_vectors`: a list of edge names (segment/vector names) that can be highlighted by the client.

Examples (as user prompts):
1. Create and analyze shortest path:
   - "Create an undirected weighted graph named G1 with vertices A, B, C, D and edges A-B (1), B-C (2), A-C (4), C-D (1)."
   - "On graph G1, find the shortest path from A to D and highlight the edges."
2. Compute an MST:
   - "Create an undirected weighted graph named G2 with vertices A, B, C, D, E and edges A-B (3), A-C (1), B-C (7), B-D (5), C-D (2), D-E (7), C-E (8)."
   - "On graph G2, compute the minimum spanning tree and highlight the MST edges."