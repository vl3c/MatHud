from constants import default_color
from copy import deepcopy
from drawable import Drawable
from math_util import MathUtil
from rotatable_polygon import RotatablePolygon


class Rectangle(RotatablePolygon):
    def __init__(self, segment1, segment2, segment3, segment4, canvas, color=default_color):
        if not self._segments_form_rectangle(segment1, segment2, segment3, segment4):
            raise ValueError("The segments do not form a rectangle")
        if not MathUtil.is_rectangle(segment1.point1.original_position.x, segment1.point1.original_position.y, 
                                 segment2.point1.original_position.x, segment2.point1.original_position.y,
                                 segment3.point1.original_position.x, segment3.point1.original_position.y, 
                                 segment4.point1.original_position.x, segment4.point1.original_position.y):
            raise ValueError("The quadrilateral formed by the segments is not a rectangle")
        self.segment1 = segment1
        self.segment2 = segment2
        self.segment3 = segment3
        self.segment4 = segment4
        name = segment1.point1.name + segment1.point2.name + segment2.point2.name + segment3.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @RotatablePolygon.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment1.canvas = value
        self.segment2.canvas = value
        self.segment3.canvas = value
        self.segment4.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Rectangle'

    def draw(self):
        pass  # Drawing is done by the canvas for the segments

    def _initialize(self):
        self.segment1._initialize()
        self.segment2._initialize()
        self.segment3._initialize()
        self.segment4._initialize()

    def _segments_form_rectangle(self, s1, s2, s3, s4):
        # Check if the end point of one segment is the start point of the next
        correct_connections = (
            s1.point2 == s2.point1 and
            s2.point2 == s3.point1 and
            s3.point2 == s4.point1 and
            s4.point2 == s1.point1
        )
        return correct_connections

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points

    def get_state(self):
        # Collect all point names into a list
        point_names = [
            self.segment1.point1.name, self.segment1.point2.name,
            self.segment2.point1.name, self.segment2.point2.name,
            self.segment3.point1.name, self.segment3.point2.name,
            self.segment4.point1.name, self.segment4.point2.name
        ]
        # Convert the list into a set to remove duplicates, then convert it back to a list and sort it
        points_names = sorted(list(set(point_names)))
        state = {"name": self.name, "args": {"p1": points_names[0], "p2": points_names[1], "p3": points_names[2], "p4": points_names[3]}}
        return state

    def __deepcopy__(self, memo):
        # Check if the triangle has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        new_s1 = deepcopy(self.segment1, memo)
        new_s2 = deepcopy(self.segment2, memo)
        new_s3 = deepcopy(self.segment3, memo)
        new_s4 = deepcopy(self.segment4, memo)
        new_rectangle = Rectangle(new_s1, new_s2, new_s3, new_s4, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_rectangle
        return new_rectangle

    def translate(self, x_offset, y_offset):
        self.segment1.translate(x_offset, y_offset)
        self.segment2.translate(x_offset, y_offset)
        self.segment3.translate(x_offset, y_offset)
        self.segment4.translate(x_offset, y_offset)
        self._initialize()

    def get_vertices(self):
        """Return the set of unique vertices of the rectangle"""
        return {
            self.segment1.point1, self.segment1.point2,
            self.segment2.point1, self.segment2.point2,
            self.segment3.point1, self.segment3.point2,
            self.segment4.point1, self.segment4.point2
        } 