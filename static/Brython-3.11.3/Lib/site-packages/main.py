from ai_interface import AIInterface
from browser import document
from canvas import Canvas
from point import Position
import time

# Instantiate the canvas
viewport = document['math-svg'].getBoundingClientRect()
canvas = Canvas(viewport.width, viewport.height)

# Instantiate the AIInterface class to handle interactions with the AI
ai_interface = AIInterface(canvas)

# Bind the send_message function to the send button's click event
document["send-button"].bind("click", ai_interface.interact_with_ai)

# Bind the send_message function to the Enter key in the chat-input field
def check_enter(event):
    if event.keyCode == 13:  # 13 is the key code for Enter
        ai_interface.interact_with_ai(event)

document["chat-input"].bind("keypress", check_enter)

# Bind the canvas's handle_wheel function to the mouse wheel event
def handle_wheel(event):
    svg_canvas = document['math-svg']
    rect = svg_canvas.getBoundingClientRect()
    # Save the current zoom point and update it to the mouse position
    canvas.zoom_point = Position(event.clientX - rect.left, event.clientY - rect.top)
    if event.deltaY < 0:
        # Zoom in
        canvas.scale_factor *= 1.1
        canvas.zoom_direction = -1
    else:
        # Zoom out
        canvas.scale_factor *= 0.9
        canvas.zoom_direction = 1
    canvas.draw(True)

document["math-svg"].bind("wheel", handle_wheel)

last_click_timestamp = None

# Bind the canvas's handle_mousedown function to the mouse down event
def handle_mousedown(event):
    def get_decimal_places(value):
        # Absolute value to handle negative numbers
        abs_val = abs(value)
        if 0 < abs_val < 1:
            # Number of leading zeros after decimal point + 1
            # Using format to convert the number to string and split by the decimal point
            decimal_part = format(abs_val, ".10f").split(".")[1]
            leading_zeros = len(decimal_part) - len(decimal_part.lstrip('0'))
            decimal_places_needed = leading_zeros + 2
            return decimal_places_needed
        elif 0 < abs_val < 10:
            return 2
        elif abs_val < 100:
            return 1
        else:
            return 0
    global last_click_timestamp
    # Check for double click
    current_timestamp = time.time()
    if last_click_timestamp and (current_timestamp - last_click_timestamp) < 0.5:  # 0.5 seconds threshold
        # It's a double click
        rect = document["math-svg"].getBoundingClientRect()
        canvas_x = event.clientX - rect.left
        canvas_y = event.clientY - rect.top
        scale_factor = canvas.scale_factor
        origin = canvas.cartesian2axis.origin
        # Calculate the coordinates of the clicked point
        x = (canvas_x - origin.x) * 1/scale_factor
        y = (origin.y - canvas_y) * 1/scale_factor
        # Calculate the number of decimal places for x and y
        decimal_places_x = get_decimal_places(x)
        decimal_places_y = get_decimal_places(y)
        # Round x and y to the determined number of decimal places
        x = round(x, decimal_places_x)
        y = round(y, decimal_places_y)
        coordinates = f"({x}, {y}) "
        document["chat-input"].value += coordinates

    last_click_timestamp = current_timestamp

    # Logic for panning the canvas
    canvas.dragging = True
    canvas.last_mouse_position = Position(event.clientX, event.clientY)

document["math-svg"].bind("mousedown", handle_mousedown)


# Bind the canvas's handle_mouseup function to the mouse up event
def handle_mouseup(event):
    canvas.dragging = False

document["math-svg"].bind("mouseup", handle_mouseup)


# Bind the canvas's handle_mousemove function to the mouse move event
def handle_mousemove(event):
    if canvas.dragging:
        dx = event.clientX - canvas.last_mouse_position.x
        dy = event.clientY - canvas.last_mouse_position.y
        canvas.offset.x += dx
        canvas.offset.y += dy
        canvas.last_mouse_position = Position(event.clientX, event.clientY)
        canvas.draw(False)

document["math-svg"].bind("mousemove", handle_mousemove)