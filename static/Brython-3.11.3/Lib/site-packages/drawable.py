from browser import document, svg
from config import default_color
from random import randint
import re

class Drawable:
    def __init__(self, name="", color=default_color, canvas=None):
        self.name = name
        self.color = color
        self.canvas = canvas
    
    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value

    @property
    def color(self):
        return self._color

    @color.setter
    def color(self, value):
        self._color = value

    @property
    def canvas(self):
        return self._canvas

    @canvas.setter
    def canvas(self, value):
        self._canvas = value

    def _initialize(self):
        raise NotImplementedError("Subclasses must implement _initialize method")
        
    def _translate(self, offset):
        raise NotImplementedError("Subclasses must implement _translate method")

    def _translate_towards(self, destination, displacement):
        raise NotImplementedError("Subclasses must implement _translate_towards method")

    def _scale(self, factor):
        raise NotImplementedError("Subclasses must implement _scale method")

    def get_class_name(self):
        raise NotImplementedError("Subclasses must implement class_name method")
    
    def get_name(self):
        return self.name
    
    def zoom(self):
        raise NotImplementedError("Subclasses must implement zoom method")

    def pan(self):
        raise NotImplementedError("Subclasses must implement pan method")

    def draw(self):
        raise NotImplementedError("Subclasses must implement draw method")

    def reset(self):
        self._initialize()

    def create_svg_element(self, element_name, **attributes):
        # If text_content is present in attributes, store it separately and remove from attributes
        text_content = attributes.pop('text_content', None)
        text_font_size = attributes.pop('text_font_size', None)
        # If there was a font size, add it to the attributes
        if text_font_size is not None:
            attributes['font-size'] = f'{text_font_size}px'
        # print(f"Creating SVG element '{element_name}' with attributes: {attributes}")  # Debug print statement
        svg_element = getattr(svg, element_name)(**attributes)
        # If there was text content, add it to the svg element
        if text_content is not None:
            svg_element.text = text_content
            # Add a style to prevent text selection
            svg_element.style['user-select'] = 'none'
            svg_element.style['-webkit-user-select'] = 'none'
            svg_element.style['-moz-user-select'] = 'none'
            svg_element.style['-ms-user-select'] = 'none'
        document["math-svg"] <= svg_element
        return svg_element
    
    def get_state(self):
        raise NotImplementedError("Subclasses must implement get_state method")
    

class DrawableNameGenerator:
    def __init__(self):
        self.point_names = set()
        self.segment_names = set()

    def _generate_unique_point_name(self):
        characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        # First, check for unused letters in the alphabet
        for character in characters:
            if character not in self.point_names:
                return character
        # If all letters are used, start appending apostrophes to existing letters
        for character in characters:
            point_name = character
            while point_name in self.point_names:
                point_name += "'"
            if point_name not in self.point_names:
                return point_name
    
    def _generate_default_name(self):
        return ''

    def _add_unique_point_name(self, name):
        while name in self.point_names:
            name += "'"
        self.point_names.add(name)
        return name

    def _add_unique_segment_name(self, unique_point_name1, unique_point_name2):
        sorted_point_names = sorted([unique_point_name1, unique_point_name2])
        name = ''.join(sorted_point_names)
        self.segment_names.add(name)
        return name

    def get_unique_point_name(self, name):
        name = self.filter_string(name)
        if name is None or name == '':
            name = self._generate_unique_point_name()
        elif len(name) > 1:
            name_parts = self.split_name_in2(name)
            if name_parts[0] not in self.point_names and (name_parts[1] in self.point_names or len(name_parts[0]) <= len(name_parts[1])):
                name = name_parts[0]
            elif name_parts[1] not in self.point_names:
                name = name_parts[1]
            else:
                name = self._generate_unique_point_name()
        name = self._add_unique_point_name(name)
        print(f"Generated unique point name: {name}")
        return name
       
    def get_unique_segment_name(self, point_name1, point_name2):
        if point_name1 not in self.point_names:
            point_name1 = self.get_unique_point_name(point_name1)
        if point_name2 not in self.point_names:
            point_name2 = self.get_unique_point_name(point_name2)
        name = self._add_unique_segment_name(point_name1, point_name2)
        print(f"Generated unique segment name: {name}")
        return name
    
    @staticmethod
    def split_name_in2(name):
        # Handle the cases when name is None, an empty string, or a string with only one character
        if name is None or len(name) < 2:
            return [name, '']
        # The regular expression pattern matches uppercase letters possibly followed by one or more apostrophes.
        matches = re.findall(r'[A-Z]\'+|[A-Z]|[a-z]', name)
        if len(matches) == 2:
            return [match.upper() for match in matches]
        else:
            # When there's no match or only one match, return the first two letters of the name.
            return [name[0].upper(), name[1].upper()]

    @staticmethod
    def filter_string(name):
        # Regular expression to match letters and apostrophes
        pattern = r"[a-zA-Z']+"
        matches = re.findall(pattern, name)
        return ''.join(matches)

    def delete_point_name(self, name):
        self.point_names.discard(name)
    
    def delete_segment_name(self, name):
        sorted_name = ''.join(sorted(self.split_name_in2(name)))
        self.segment_names.discard(name)
        self.segment_names.discard(sorted_name)