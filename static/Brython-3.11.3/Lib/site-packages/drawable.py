from browser import document, svg
from config import default_color
from random import randint
import re
import copy

class Drawable:
    def __init__(self, name="", color=default_color, canvas=None):
        self.name = name
        self.color = color
        self.canvas = canvas
    
    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value

    @property
    def color(self):
        return self._color

    @color.setter
    def color(self, value):
        self._color = value

    @property
    def canvas(self):
        return self._canvas

    @canvas.setter
    def canvas(self, value):
        self._canvas = value

    def _initialize(self):
        raise NotImplementedError("Subclasses must implement _initialize method")
        
    def _translate(self, offset):
        raise NotImplementedError("Subclasses must implement _translate method")

    def _translate_towards(self, destination, displacement):
        raise NotImplementedError("Subclasses must implement _translate_towards method")

    def _scale(self, factor):
        raise NotImplementedError("Subclasses must implement _scale method")

    def get_class_name(self):
        raise NotImplementedError("Subclasses must implement class_name method")
    
    def get_name(self):
        return self.name
    
    def zoom(self):
        raise NotImplementedError("Subclasses must implement zoom method")

    def pan(self):
        raise NotImplementedError("Subclasses must implement pan method")

    def draw(self):
        raise NotImplementedError("Subclasses must implement draw method")

    def reset(self):
        self._initialize()

    def create_svg_element(self, element_name, **attributes):
        # If text_content is present in attributes, store it separately and remove from attributes
        text_content = attributes.pop('text_content', None)
        text_font_size = attributes.pop('text_font_size', None)
        # If there was a font size, add it to the attributes
        if text_font_size is not None:
            attributes['font-size'] = f'{text_font_size}px'
        # print(f"Creating SVG element '{element_name}' with attributes: {attributes}")  # Debug print statement
        svg_element = getattr(svg, element_name)(**attributes)
        # If there was text content, add it to the svg element
        if text_content is not None:
            svg_element.text = text_content
            # Add a style to prevent text selection
            svg_element.style['user-select'] = 'none'
            svg_element.style['-webkit-user-select'] = 'none'
            svg_element.style['-moz-user-select'] = 'none'
            svg_element.style['-ms-user-select'] = 'none'
        document["math-svg"] <= svg_element
        return svg_element
    
    def get_state(self):
        raise NotImplementedError("Subclasses must implement get_state method")
    

class DrawableNameGenerator:
    def __init__(self):
        self.point_names = set()
        self.segment_names = set()
        self.triangle_names = set()
        self.rectangle_names = set()
        self.circle_names = set()
        self.ellipse_names = set()
        self.function_names = set()
        self.undo_stack = []
        self.redo_stack = []

    def print_names(self):
        print(f"Point names: {self.point_names}")
        print(f"Segment names: {self.segment_names}")
        print(f"Triangle names: {self.triangle_names}")
        print(f"Rectangle names: {self.rectangle_names}")
        print(f"Circle names: {self.circle_names}")
        print(f"Ellipse names: {self.ellipse_names}")
        print(f"Function names: {self.function_names}")

    def archive(self):
        names_archive = {
            'point_names': copy.deepcopy(self.point_names),
            'segment_names': copy.deepcopy(self.segment_names),
            'triangle_names': copy.deepcopy(self.triangle_names),
            'rectangle_names': copy.deepcopy(self.rectangle_names),
            'circle_names': copy.deepcopy(self.circle_names),
            'ellipse_names': copy.deepcopy(self.ellipse_names),
            'function_names': copy.deepcopy(self.function_names)
        }
        self.undo_stack.append(names_archive)

    def undo(self):
        if len(self.undo_stack) > 0:
            names_archive = self.undo_stack.pop()
            self.redo_stack.append(copy.deepcopy(names_archive))
            self.point_names = names_archive['point_names']
            self.segment_names = names_archive['segment_names']
            self.triangle_names = names_archive['triangle_names']
            self.rectangle_names = names_archive['rectangle_names']
            self.circle_names = names_archive['circle_names']
            self.ellipse_names = names_archive['ellipse_names']
            self.function_names = names_archive['function_names']

    def redo(self):
        if len(self.redo_stack) > 0:
            names_archive = self.redo_stack.pop()
            self.undo_stack.append(copy.deepcopy(names_archive))
            self.point_names = names_archive['point_names']
            self.segment_names = names_archive['segment_names']
            self.triangle_names = names_archive['triangle_names']
            self.rectangle_names = names_archive['rectangle_names']
            self.circle_names = names_archive['circle_names']
            self.ellipse_names = names_archive['ellipse_names']
            self.function_names = names_archive['function_names']

    def _generate_unique_point_name(self):
        characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        # First, check for unused letters in the alphabet
        for character in characters:
            if character not in self.point_names:
                return character
        # If all letters are used, start appending apostrophes to existing letters
        for character in characters:
            point_name = character
            while point_name in self.point_names:
                point_name += "'"
            if point_name not in self.point_names:
                return point_name
    
    def _generate_default_name(self):
        return ''

    def _generate_default_function_name(self):
        return 'f'

    def _increment_name(self, obj_name):
        # Check if there is a number before the bracket (, if not, append 1; if there is, increment it
        match = re.search(r'(\d+)(?=\()', obj_name)
        if match:
            number = int(match.group())
            obj_name = obj_name[:match.start()] + str(number + 1) + obj_name[match.end():]
        else:
            # Check if function_name contains '('
            if '(' in obj_name:
                parts = obj_name.split("(")
                obj_name = parts[0] + '1(' + parts[1]
            else:
                # If there is no '(', simply append '1' to the function name
                obj_name += '1'
        return obj_name

    def _add_unique_point_name(self, name):
        while name in self.point_names:
            name += "'"
        self.point_names.add(name)
        return name

    def _add_unique_segment_name(self, unique_point_name1, unique_point_name2):
        sorted_point_names = sorted([unique_point_name1, unique_point_name2])
        name = ''.join(sorted_point_names)
        self.segment_names.add(name)
        return name

    def _add_unique_triangle_name(self, unique_p1, unique_p2, unique_p3):
        sorted_point_names = sorted([unique_p1, unique_p2, unique_p3])
        name = ''.join(sorted_point_names)
        self.triangle_names.add(name)
        return name
    
    def _add_unique_rectangle_name(self, unique_p1, unique_p2, unique_p3, unique_p4):
        sorted_point_names = sorted([unique_p1, unique_p2, unique_p3, unique_p4])
        name = ''.join(sorted_point_names)
        self.rectangle_names.add(name)
        return name

    def clear(self):
        self.point_names.clear()
        self.segment_names.clear()
        self.triangle_names.clear()
        self.rectangle_names.clear()
        self.circle_names.clear()
        self.ellipse_names.clear()
        self.function_names.clear()

    def get_unique_point_name(self, name):
        name = self.filter_string(name)
        if name is None or name == '':
            name = self._generate_unique_point_name()
        elif len(name) > 1:
            name_parts = self.split_in_n_point_names(name, 2)
            if name_parts[0] not in self.point_names and (name_parts[1] in self.point_names or len(name_parts[0]) <= len(name_parts[1])):
                name = name_parts[0]
            elif name_parts[1] not in self.point_names:
                name = name_parts[1]
            else:
                name = self._generate_unique_point_name()
        name = self._add_unique_point_name(name)
        print(f"Generated unique point name: {name}")
        return name
       
    def get_unique_segment_name(self, point_name1, point_name2):
        point_name1 = self.filter_string(point_name1)
        point_name2 = self.filter_string(point_name2)
        if point_name1 not in self.point_names:
            point_name1 = self.get_unique_point_name(point_name1)
        if point_name2 not in self.point_names:
            point_name2 = self.get_unique_point_name(point_name2)
        name = self._add_unique_segment_name(point_name1, point_name2)
        print(f"Generated unique segment name: {name}")
        return name
    
    def _get_unique_segment_name_from_string(self, segment_name):
        segment_name = self.filter_string(segment_name)
        # Sort the point names alphabetically
        segment_name = sorted(self.split_in_n_point_names(segment_name, 2))
        segment_name_str = ''.join(segment_name)
        if segment_name_str not in self.segment_names:
            return self.get_unique_segment_name(segment_name[0], segment_name[1])
        else:
            return segment_name_str

    def get_unique_triangle_name(self, segment_name1, segment_name2, segment_name3):
        print(f"Generating unique triangle name from segments: {segment_name1}, {segment_name2}, {segment_name3}")
        segment_name1 = self._get_unique_segment_name_from_string(segment_name1)
        s1_points = self.split_in_n_point_names(segment_name1, 2)
        segment_name2 = self._get_unique_segment_name_from_string(segment_name2)
        s2_points = self.split_in_n_point_names(segment_name2, 2)
        segment_name3 = self._get_unique_segment_name_from_string(segment_name3)
        s3_points = self.split_in_n_point_names(segment_name3, 2)
        
        # Flatten the list of segments and convert to a set to eliminate duplicates
        unique_points = list(set(s1_points + s2_points + s3_points))
        
        # Sort the list of unique points
        unique_points.sort()

        # Determine the triangle name based on the number of unique points
        if len(unique_points) == 3:
            name = self._add_unique_triangle_name(unique_points[0], unique_points[1], unique_points[2])
        elif len(unique_points) == 2:
            all_points = s1_points + s2_points + s3_points
            repeated_point = max(all_points, key=all_points.count)
            name = self._add_unique_triangle_name(unique_points[0], repeated_point, unique_points[1])
        else:
            raise ValueError("Invalid triangle with less than 2 unique points.")

        print(f"Generated unique triangle name: {name}")
        return name
    
    def get_unique_rectangle_name(self, segment_name1, segment_name2, segment_name3, segment_name4):
        segment_name1 = self._get_unique_segment_name_from_string(segment_name1)
        s1_points = self.split_in_n_point_names(segment_name1, 2)
        segment_name2 = self._get_unique_segment_name_from_string(segment_name2)
        s2_points = self.split_in_n_point_names(segment_name2, 2)
        segment_name3 = self._get_unique_segment_name_from_string(segment_name3)
        s3_points = self.split_in_n_point_names(segment_name3, 2)
        segment_name4 = self._get_unique_segment_name_from_string(segment_name4)
        s4_points = self.split_in_n_point_names(segment_name4, 2)
        # Flatten the list of segments and convert to a set to eliminate duplicates
        unique_points = list(set(s1_points + s2_points + s3_points + s4_points))
        # Sort the list of unique points
        unique_points.sort()
        name = self._add_unique_rectangle_name(unique_points[0], unique_points[1], unique_points[2], unique_points[3])
        print(f"Generated unique rectangle name: {name}")
        return name

    def get_unique_circle_name(self, center_name):
        center_name = self.filter_string(center_name)
        if center_name not in self.point_names:
            center_name = self.get_unique_point_name(center_name)
        name = center_name
        while name in self.circle_names:
            name = self._increment_name(name)
        self.circle_names.add(name)
        print(f"Generated unique circle name: {name}")
        return name

    def get_unique_ellipse_name(self, center_name):
        center_name = self.filter_string(center_name)
        if center_name not in self.point_names:
            center_name = self.get_unique_point_name(center_name)
        name = center_name
        while name in self.ellipse_names:
            name = self._increment_name(name)
        self.ellipse_names.add(name)
        print(f"Generated unique ellipse name: {name}")
        return name

    def get_unique_function_name(self, function_name):
        if function_name is None or function_name == '':
            function_name = self._generate_default_function_name()
        while function_name in self.function_names:
            function_name = self._increment_name(function_name)
        self.function_names.add(function_name)
        print(f"Generated unique function name: {function_name}")
        return function_name

    @staticmethod
    def split_in_n_point_names(name, n):
        # Handle the cases when name is None or an empty string
        if name is None or len(name) < 1:
            return [''] * n
        elif len(name) < n:
            return sorted([name[i].upper() for i in range(len(name))]) + [''] * (n - len(name))
        # The regular expression pattern matches uppercase letters possibly followed by one or more apostrophes.
        matches = re.findall(r'[A-Z]\'+|[A-Z]|[a-z]', name)
        if len(matches) == n:
            return sorted([match.upper() for match in matches])
        else:
            # When there's no match or only one match, return the first n letters of the name.
            return sorted([name[i].upper() for i in range(n)])

    @staticmethod
    def filter_string(name):
        # Regular expression to match letters and apostrophes
        pattern = r"[a-zA-Z']+"
        matches = re.findall(pattern, name)
        return ''.join(matches)

    def delete_point_name(self, name):
        self.point_names.discard(name)
    
    def delete_segment_name(self, name):
        sorted_name = ''.join(sorted(self.split_in_n_point_names(name, 2)))
        self.segment_names.discard(sorted_name)

    def delete_triangle_name(self, name):
        sorted_name = ''.join(sorted(self.split_in_n_point_names(name, 3)))
        self.triangle_names.discard(sorted_name)

    def delete_rectangle_name(self, name):
        sorted_name = ''.join(sorted(self.split_in_n_point_names(name, 4)))
        self.rectangle_names.discard(sorted_name)

    def delete_circle_name(self, name):
        self.circle_names.discard(name)

    def delete_ellipse_name(self, name):
        self.ellipse_names.discard(name)

    def delete_function_name(self, name):
        self.function_names.discard(name)