from browser import document, window
from constants import (
    double_click_threshold_s,
    zoom_in_scale_factor,
    zoom_out_scale_factor,
    mousemove_throttle_ms
)
from geometry import Position
import time


def throttle(wait_ms):
    """
    Decorator factory that creates a throttle decorator with specified wait time.
    Throttling ensures the function is called at a regular interval, unlike
    debouncing which waits for a pause in calls.
    
    Args:
        wait_ms: The minimum time between function calls in milliseconds
    
    Returns:
        A decorator function that will throttle the decorated function
    """
    def decorator(func):
        last_call = None
        queued = None
        
        def throttled(*args, **kwargs):
            nonlocal last_call, queued
            current_time = window.performance.now()  # Get high-resolution timestamp in ms
            
            try:
                if queued is not None:
                    window.clearTimeout(queued)
                    queued = None

                if last_call is None:
                    # First call executes immediately
                    last_call = current_time
                    func(*args, **kwargs)
                else:
                    elapsed = current_time - last_call
                    if elapsed >= wait_ms:
                        # If enough time has passed, execute immediately
                        last_call = current_time
                        func(*args, **kwargs)
                    else:
                        # Schedule to run at next interval
                        remaining_time = wait_ms - elapsed
                        queued = window.setTimeout(
                            lambda: throttled(*args, **kwargs),
                            remaining_time
                        )
            except Exception as e:
                print(f"Error in throttle: {str(e)}")
        
        return throttled
    
    return decorator


class CanvasEventHandler:
    def __init__(self, canvas, ai_interface):
        self.canvas = canvas
        self.ai_interface = ai_interface
        self.last_click_timestamp = None
        self.current_mouse_position = None
        self.bind_events()
    
    def bind_events(self):
        """Bind all event handlers with error handling."""
        try:
            document["send-button"].bind("click", self.ai_interface.interact_with_ai)
            document["chat-input"].bind("keypress", self.check_enter)
            document["math-svg"].bind("wheel", self.handle_wheel)
            document["math-svg"].bind("mousedown", self.handle_mousedown)
            document["math-svg"].bind("mouseup", self.handle_mouseup)
            document["math-svg"].bind("mousemove", self.handle_mousemove)
        except Exception as e:
            print(f"Error binding events: {str(e)}")

    def check_enter(self, event):
        """Handle enter key press in chat input."""
        try:
            if event.keyCode == 13:  # 13 is the key code for Enter
                self.ai_interface.interact_with_ai(event)
        except Exception as e:
            print(f"Error handling enter key: {str(e)}")

    def handle_wheel(self, event):
        """Handle mouse wheel events for zooming."""
        try:
            svg_canvas = document['math-svg']
            rect = svg_canvas.getBoundingClientRect()
            # Save the current zoom point and update it to the mouse position
            self.canvas.zoom_point = Position(event.clientX - rect.left, event.clientY - rect.top)
            if event.deltaY < 0:
                # Zoom in
                self.canvas.scale_factor *= zoom_in_scale_factor
                self.canvas.zoom_direction = -1
            else:
                # Zoom out
                self.canvas.scale_factor *= zoom_out_scale_factor
                self.canvas.zoom_direction = 1
            self.canvas.draw(True)
        except Exception as e:
            print(f"Error handling wheel event: {str(e)}")

    def get_decimal_places(self, value):
        """Calculate appropriate decimal places for coordinate display."""
        try:
            abs_val = abs(value)
            if 0 < abs_val < 1:
                decimal_part = format(abs_val, ".10f").split(".")[1]
                leading_zeros = len(decimal_part) - len(decimal_part.lstrip('0'))
                return leading_zeros + 2
            elif 0 < abs_val < 10:
                return 2
            elif abs_val < 100:
                return 1
            else:
                return 0
        except Exception as e:
            print(f"Error calculating decimal places: {str(e)}")
            return 2  # Default to 2 decimal places on error

    def handle_mousedown(self, event):
        """Handle mouse down events for panning and coordinate capture."""
        try:
            current_timestamp = time.time()
            if self.last_click_timestamp and (current_timestamp - self.last_click_timestamp) < double_click_threshold_s:
                # Handle double click
                rect = document["math-svg"].getBoundingClientRect()
                canvas_x = event.clientX - rect.left
                canvas_y = event.clientY - rect.top
                scale_factor = self.canvas.scale_factor
                origin = self.canvas.cartesian2axis.origin
                
                x = (canvas_x - origin.x) * 1/scale_factor
                y = (origin.y - canvas_y) * 1/scale_factor
                
                decimal_places_x = self.get_decimal_places(x)
                decimal_places_y = self.get_decimal_places(y)
                
                x = round(x, decimal_places_x)
                y = round(y, decimal_places_y)
                coordinates = f"({x}, {y}) "
                document["chat-input"].value += coordinates

            self.last_click_timestamp = current_timestamp
            self.canvas.dragging = True
            self.current_mouse_position = Position(event.clientX, event.clientY)
            self.canvas.last_mouse_position = self.current_mouse_position
        except Exception as e:
            print(f"Error handling mousedown: {str(e)}")
            self.canvas.dragging = False

    def handle_mouseup(self, event):
        """Handle mouse up events."""
        try:
            self.canvas.dragging = False
            self.current_mouse_position = None
        except Exception as e:
            print(f"Error handling mouseup: {str(e)}")

    def handle_mousemove(self, event):
        """Handle mouse movement for canvas panning."""
        try:
            if not self.canvas.dragging:
                return
                
            self.current_mouse_position = Position(event.clientX, event.clientY)
            self._update_canvas_position(event)
        except Exception as e:
            print(f"Error handling mousemove: {str(e)}")
    
    @throttle(mousemove_throttle_ms)
    def _update_canvas_position(self, event):
        """Update canvas position with throttling for smooth performance."""
        try:
            if self.current_mouse_position and self.canvas.last_mouse_position:
                dx = self.current_mouse_position.x - self.canvas.last_mouse_position.x
                dy = self.current_mouse_position.y - self.canvas.last_mouse_position.y
                self.canvas.offset.x += dx
                self.canvas.offset.y += dy
                self.canvas.last_mouse_position = self.current_mouse_position
                self.canvas.draw(False)
        except Exception as e:
            print(f"Error updating canvas position: {str(e)}") 