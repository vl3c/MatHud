"""
Markdown Parser for MatHud Chat Interface

A comprehensive markdown parser that supports:
- Headers (H1-H6: # ## ### #### ##### ######)
- Bold text (**bold** or __bold__)
- Italic text (*italic* or _italic_)
- Strikethrough text (~~strikethrough~~)
- Inline and block code (` and ```)
- Links and images
- Ordered and unordered lists with nesting
- Checkboxes (- [x] and - [ ])
- Tables
- Blockquotes
- Horizontal rules
- Mathematical expressions (LaTeX: \(...\) for inline, $$...$$ for block)
"""


class MarkdownParser:
    """Custom markdown parser optimized for chat interface display."""
    
    def parse(self, text):
        """Parse markdown text to HTML."""
        try:
            # Skip Brython's apply_markdown as it's not working properly
            # It wraps everything in a single <p> tag and doesn't parse headers correctly
            html_content = self._simple_markdown_parse(text)
            return html_content
            
        except Exception as e:
            print(f"Error in custom markdown parsing: {e}")
            # Ultimate fallback
            return text.replace('\n', '<br>')

    def _simple_markdown_parse(self, text):
        """Simple markdown parser for basic formatting using string operations."""
        try:
            # First handle tables
            text = self._process_tables(text)
            
            # Split text into lines for processing
            lines = text.split('\n')
            html_lines = []
            in_code_block = False
            code_block_content = []
            
            for line in lines:
                # Skip table processing if already processed
                if '<table>' in line or '</table>' in line or '<tr>' in line or '<td>' in line or '<th>' in line:
                    html_lines.append(line)
                    continue
                    
                # Handle code blocks
                if line.strip().startswith('```'):
                    if in_code_block:
                        # End code block
                        code_content = '\n'.join(code_block_content)
                        html_lines.append(f'<pre><code>{code_content}</code></pre>')
                        code_block_content = []
                        in_code_block = False
                    else:
                        # Start code block
                        in_code_block = True
                    continue
                
                if in_code_block:
                    code_block_content.append(line)
                    continue
                
                # Process other markdown elements
                processed_line = line
                
                # Headers (H1-H6)
                if processed_line.startswith('###### '):
                    processed_line = f'<h6>{processed_line[7:]}</h6>'
                elif processed_line.startswith('##### '):
                    processed_line = f'<h5>{processed_line[6:]}</h5>'
                elif processed_line.startswith('#### '):
                    processed_line = f'<h4>{processed_line[5:]}</h4>'
                elif processed_line.startswith('### '):
                    processed_line = f'<h3>{processed_line[4:]}</h3>'
                elif processed_line.startswith('## '):
                    processed_line = f'<h2>{processed_line[3:]}</h2>'
                elif processed_line.startswith('# '):
                    processed_line = f'<h1>{processed_line[2:]}</h1>'
                # Lists - handle ordered and unordered with indentation
                elif self._is_list_item(processed_line):
                    processed_line = self._process_list_item(processed_line)
                # Blockquotes
                elif processed_line.startswith('> '):
                    processed_line = f'<blockquote>{processed_line[2:]}</blockquote>'
                # Horizontal rules
                elif processed_line.strip() == '---':
                    processed_line = '<hr>'
                
                # Handle inline formatting
                processed_line = self._process_inline_markdown(processed_line)
                
                html_lines.append(processed_line)
            
            # Join lines and wrap list items
            html = self._join_lines_with_smart_breaks(html_lines)
            html = self._wrap_list_items_improved(html)
            
            # Process mathematical expressions after everything else
            html = self._process_math_expressions(html)
            
            return html
            
        except Exception as e:
            print(f"Error in simple markdown parsing: {e}")
            # Ultimate fallback
            return text.replace('\n', '<br>')
    
    def _process_tables(self, text):
        """Process markdown tables."""
        try:
            lines = text.split('\n')
            result_lines = []
            in_table = False
            table_lines = []
            
            for i, line in enumerate(lines):
                # Check if this might be a table line (contains |)
                if '|' in line.strip() and line.strip() != '':
                    # Check if next line is a separator (contains | and -)
                    is_header = False
                    if i + 1 < len(lines):
                        next_line = lines[i + 1].strip()
                        if '|' in next_line and '-' in next_line:
                            is_header = True
                    
                    if not in_table:
                        in_table = True
                        table_lines = []
                    
                    table_lines.append((line, is_header))
                    
                    # Skip the separator line
                    if is_header and i + 1 < len(lines):
                        continue
                        
                else:
                    # Not a table line
                    if in_table:
                        # Process the collected table
                        table_html = self._build_table_html(table_lines)
                        result_lines.append(table_html)
                        in_table = False
                        table_lines = []
                    
                    result_lines.append(line)
            
            # Handle table at end of text
            if in_table and table_lines:
                table_html = self._build_table_html(table_lines)
                result_lines.append(table_html)
            
            return '\n'.join(result_lines)
            
        except Exception as e:
            print(f"Error processing tables: {e}")
            return text
    
    def _build_table_html(self, table_lines):
        """Build HTML table from markdown table lines."""
        try:
            if not table_lines:
                return ''
            
            html = '<table>'
            
            for line_data in table_lines:
                line, is_header = line_data
                # Parse table row
                cells = [cell.strip() for cell in line.split('|')]
                # Remove empty cells at start/end
                if cells and cells[0] == '':
                    cells = cells[1:]
                if cells and cells[-1] == '':
                    cells = cells[:-1]
                
                if cells:
                    tag = 'th' if is_header else 'td'
                    html += '<tr>'
                    for cell in cells:
                        # Process inline markdown in table cells
                        cell_content = self._process_inline_markdown(cell)
                        html += f'<{tag}>{cell_content}</{tag}>'
                    html += '</tr>'
            
            html += '</table>'
            return html
            
        except Exception as e:
            print(f"Error building table HTML: {e}")
            return ''
    
    def _is_list_item(self, line):
        """Check if a line is a list item (ordered, unordered, or checkbox)."""
        stripped = line.strip()
        
        # Checkbox items
        if stripped.startswith('- [x]') or stripped.startswith('- [ ]'):
            return True
            
        # Unordered list
        if stripped.startswith('- ') or stripped.startswith('* '):
            return True
            
        # Ordered list (number followed by period and space)
        if len(stripped) > 2 and stripped[1:3] == '. ':
            try:
                int(stripped[0])  # Check if first char is number
                return True
            except:
                pass
                
        # Handle multi-digit numbers
        parts = stripped.split('. ', 1)
        if len(parts) == 2:
            try:
                int(parts[0])
                return True
            except:
                pass
        return False
    
    def _process_list_item(self, line):
        """Process a list item and determine its type and indentation."""
        # Count leading spaces for indentation level
        leading_spaces = len(line) - len(line.lstrip())
        indent_level = leading_spaces // 2  # 2 spaces = 1 indent level
        
        stripped = line.strip()
        
        # Handle checkboxes
        if stripped.startswith('- [x]'):
            content = stripped[6:]  # Remove '- [x] '
            checkbox = '<span class="checkbox checked">âœ“</span>'
            return f'<li class="checkbox-item" data-list-type="ul" data-indent="{indent_level}">{checkbox}{content}</li>'
        elif stripped.startswith('- [ ]'):
            content = stripped[6:]  # Remove '- [ ] '
            checkbox = '<span class="checkbox unchecked"></span>'
            return f'<li class="checkbox-item" data-list-type="ul" data-indent="{indent_level}">{checkbox}{content}</li>'
        
        # Determine list type and content
        if stripped.startswith('- ') or stripped.startswith('* '):
            # Unordered list
            content = stripped[2:]
            list_type = 'ul'
        else:
            # Ordered list (number followed by period)
            parts = stripped.split('. ', 1)
            if len(parts) == 2:
                try:
                    int(parts[0])
                    content = parts[1]
                    list_type = 'ol'
                except:
                    # Fallback
                    content = stripped
                    list_type = 'ul'
            else:
                content = stripped
                list_type = 'ul'
        
        # Add data attributes to track list type and indent level
        return f'<li data-list-type="{list_type}" data-indent="{indent_level}">{content}</li>'
    
    def _join_lines_with_smart_breaks(self, lines):
        """Join lines with smart line break handling."""
        try:
            result_lines = []
            
            for i, line in enumerate(lines):
                if line.strip():  # Non-empty line
                    result_lines.append(line)
                else:
                    # Empty line - only add break if not between list items or table elements
                    if i > 0 and i < len(lines) - 1:
                        prev_line = lines[i-1].strip()
                        next_line = lines[i+1].strip()
                        
                        # Don't add breaks between list items
                        prev_is_list = '<li' in prev_line
                        next_is_list = '<li' in next_line
                        
                        # Don't add breaks around tables
                        prev_is_table = any(tag in prev_line for tag in ['<table>', '</table>', '<tr>', '<td>', '<th>'])
                        next_is_table = any(tag in next_line for tag in ['<table>', '</table>', '<tr>', '<td>', '<th>'])
                        
                        if not (prev_is_list and next_is_list) and not (prev_is_table or next_is_table):
                            result_lines.append('<br>')
            
            return '<br>'.join(result_lines)
            
        except Exception as e:
            print(f"Error joining lines: {e}")
            return '<br>'.join(lines)

    def _wrap_list_items_improved(self, html):
        """Wrap list items with proper <ul>/<ol> tags and handle REAL nesting."""
        try:
            lines = html.split('<br>')
            result = []
            i = 0
            
            while i < len(lines):
                line = lines[i].strip()
                
                if '<li data-list-type=' in line and '</li>' in line:
                    # Start processing a list
                    list_items = []
                    current_index = i
                    
                    # Collect all consecutive list items
                    while current_index < len(lines):
                        current_line = lines[current_index].strip()
                        if '<li data-list-type=' in current_line and '</li>' in current_line:
                            list_type = self._extract_data_attr(current_line, 'data-list-type')
                            indent_level = int(self._extract_data_attr(current_line, 'data-indent') or '0')
                            
                            # Clean the line (remove data attributes)
                            clean_line = current_line.replace(f' data-list-type="{list_type}"', '')
                            clean_line = clean_line.replace(f' data-indent="{indent_level}"', '')
                            
                            list_items.append((clean_line, list_type, indent_level))
                            current_index += 1
                        else:
                            break
                    
                    # Process the collected list items into nested HTML
                    nested_html = self._build_nested_list_html(list_items)
                    result.append(nested_html)
                    i = current_index
                else:
                    # Not a list item
                    if line:
                        result.append(line)
                    i += 1
            
            # Join with line breaks
            return '<br>'.join(result)
            
        except Exception as e:
            print(f"Error in improved list wrapping: {e}")
            return html
    
    def _extract_data_attr(self, line, attr_name):
        """Extract data attribute value from HTML line."""
        try:
            start = line.find(f'{attr_name}="') + len(f'{attr_name}="')
            end = line.find('"', start)
            return line[start:end] if start > len(f'{attr_name}="') - 1 and end > start else None
        except:
            return None
    
    def _build_nested_list_html(self, list_items):
        """Build properly nested HTML from list items."""
        try:
            if not list_items:
                return ''
            
            result = []
            stack = []  # Stack of (list_type, indent_level)
            
            for item_html, list_type, indent_level in list_items:
                # Close lists that are deeper than current level
                while stack and stack[-1][1] >= indent_level:
                    if stack[-1][1] == indent_level and stack[-1][0] == list_type:
                        # Same level and type, continue
                        break
                    # Close the deeper list
                    closed_type = stack.pop()[0]
                    tag = 'ol' if closed_type == 'ol' else 'ul'
                    result.append(f'</{tag}>')
                
                # Open new list if needed
                if not stack or stack[-1][1] < indent_level or stack[-1][0] != list_type:
                    tag = 'ol' if list_type == 'ol' else 'ul'
                    result.append(f'<{tag}>')
                    stack.append((list_type, indent_level))
                
                # Add the list item
                result.append(item_html)
            
            # Close all remaining open lists
            while stack:
                closed_type = stack.pop()[0]
                tag = 'ol' if closed_type == 'ol' else 'ul'
                result.append(f'</{tag}>')
            
            return ''.join(result)
            
        except Exception as e:
            print(f"Error building nested list HTML: {e}")
            return ''
    
    def _process_inline_markdown(self, text):
        """Process inline markdown elements like bold, italic, code."""
        try:
            # Bold text (**text** and __text__)
            while '**' in text:
                start = text.find('**')
                if start == -1:
                    break
                end = text.find('**', start + 2)
                if end == -1:
                    break
                before = text[:start]
                content = text[start + 2:end]
                after = text[end + 2:]
                text = before + f'<strong>{content}</strong>' + after
            
            processed_double_positions = set()
            while '__' in text:
                start = text.find('__')
                if start == -1 or start in processed_double_positions:
                    break
                end = text.find('__', start + 2)
                if end == -1:
                    break
                
                # Check if double underscore is surrounded by spaces or at word boundaries
                char_before = text[start - 1] if start > 0 else ' '
                char_after = text[end + 2] if end + 2 < len(text) else ' '
                
                # Only apply bold formatting if properly spaced
                if (not char_before.isalnum() and not char_after.isalnum()) or \
                   (char_before == ' ' and char_after == ' '):
                    before = text[:start]
                    content = text[start + 2:end]
                    after = text[end + 2:]
                    text = before + f'<strong>{content}</strong>' + after
                    break  # Exit and restart search since text changed
                else:
                    # Mark this position as processed to avoid infinite loop
                    processed_double_positions.add(start)
                    # Find next double underscore after this one
                    next_start = text.find('__', start + 2)
                    if next_start == -1:
                        break
            
            # Italic text (*text* and _text_)
            while '*' in text and '<strong>' not in text:  # Avoid conflicts with bold
                start = text.find('*')
                if start == -1:
                    break
                end = text.find('*', start + 1)
                if end == -1:
                    break
                before = text[:start]
                content = text[start + 1:end]
                after = text[end + 1:]
                text = before + f'<em>{content}</em>' + after
            
            # Enhanced underscore italic processing - only format when surrounded by spaces or at word boundaries
            processed_positions = set()
            while '_' in text and '<strong>' not in text:  # Avoid conflicts with bold
                start = text.find('_')
                if start == -1 or start in processed_positions:
                    break
                end = text.find('_', start + 1)
                if end == -1:
                    break
                
                # Check if underscore is surrounded by spaces or at word boundaries
                char_before = text[start - 1] if start > 0 else ' '
                char_after = text[end + 1] if end + 1 < len(text) else ' '
                
                # Only apply italic formatting if:
                # 1. Underscore is preceded by space or punctuation (not alphanumeric)
                # 2. Underscore is followed by space or punctuation (not alphanumeric)
                if (not char_before.isalnum() and not char_after.isalnum()) or \
                   (char_before == ' ' and char_after == ' '):
                    before = text[:start]
                    content = text[start + 1:end]
                    after = text[end + 1:]
                    text = before + f'<em>{content}</em>' + after
                    break  # Exit and restart search since text changed
                else:
                    # Mark this position as processed to avoid infinite loop
                    processed_positions.add(start)
                    # Find next underscore after this one
                    next_start = text.find('_', start + 1)
                    if next_start == -1:
                        break
            
            # Strikethrough (~~text~~)
            while '~~' in text:
                start = text.find('~~')
                if start == -1:
                    break
                end = text.find('~~', start + 2)
                if end == -1:
                    break
                before = text[:start]
                content = text[start + 2:end]
                after = text[end + 2:]
                text = before + f'<del>{content}</del>' + after
            
            # Inline code (`text`)
            while '`' in text:
                start = text.find('`')
                if start == -1:
                    break
                end = text.find('`', start + 1)
                if end == -1:
                    break
                before = text[:start]
                content = text[start + 1:end]
                after = text[end + 1:]
                text = before + f'<code>{content}</code>' + after
            
            # Links [text](url)
            while '[' in text and '](' in text and ')' in text:
                start = text.find('[')
                if start == -1:
                    break
                middle = text.find('](', start)
                if middle == -1:
                    break
                end = text.find(')', middle)
                if end == -1:
                    break
                before = text[:start]
                link_text = text[start + 1:middle]
                link_url = text[middle + 2:end]
                after = text[end + 1:]
                text = before + f'<a href="{link_url}">{link_text}</a>' + after
            
            return text
            
        except Exception as e:
            print(f"Error processing inline markdown: {e}")
            return text
    
    def _process_math_expressions(self, text):
        """Process LaTeX mathematical expressions."""
        try:
            # Process block math expressions ($$...$$) first
            # Find all matches and replace from end to beginning to preserve positions
            block_matches = []
            pos = 0
            while True:
                start = text.find('$$', pos)
                if start == -1:
                    break
                end = text.find('$$', start + 2)
                if end == -1:
                    break
                block_matches.append((start, end + 2, text[start + 2:end]))
                pos = end + 2
            
            # Replace from end to beginning
            for start, end, content in reversed(block_matches):
                replacement = f'<div class="math-block">$${content}$$</div>'
                text = text[:start] + replacement + text[end:]
            
            # Process inline math expressions (\(...\))
            inline_matches = []
            pos = 0
            while True:
                start = text.find('\\(', pos)
                if start == -1:
                    break
                end = text.find('\\)', start + 2)
                if end == -1:
                    break
                inline_matches.append((start, end + 2, text[start + 2:end]))
                pos = end + 2
            
            # Replace from end to beginning
            for start, end, content in reversed(inline_matches):
                replacement = f'<span class="math-inline">\\({content}\\)</span>'
                text = text[:start] + replacement + text[end:]
            
            return text
            
        except Exception as e:
            print(f"Error processing math expressions: {e}")
            return text 