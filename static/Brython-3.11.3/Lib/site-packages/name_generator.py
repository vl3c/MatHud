from itertools import count
import re


class DrawableNameGenerator:
    def __init__(self, canvas):
        self.canvas = canvas
        self.used_letters_from_names = {}  # Track which letters have been used for each name

    def print_names(self):
        print(f"Point names: {self.get_drawable_names('Point')}")
        print(f"Segment names: {self.get_drawable_names('Segment')}")
        print(f"Triangle names: {self.get_drawable_names('Triangle')}")
        print(f"Rectangle names: {self.get_drawable_names('Rectangle')}")
        print(f"Circle names: {self.get_drawable_names('Circle')}")
        print(f"Ellipse names: {self.get_drawable_names('Ellipse')}")
        print(f"Function names: {self.get_drawable_names('Function')}")

    def get_drawable_names(self, class_name):
        drawables = self.canvas.get_drawables_by_class_name(class_name)
        drawable_names = sorted([drawable.name for drawable in drawables])
        return drawable_names

    def filter_string(self, name):
        # Regular expression to match letters, apostrophes, digits, and parentheses
        pattern = r"[a-zA-Z0-9'\(\)]+"
        matches = re.findall(pattern, name)
        return ''.join(matches)

    def split_point_names(self, expression, n=2):
        if expression is None or len(expression) < 1:
            return [''] * n
        expression = self.filter_string(expression)
        expression = expression.upper()
        
        # Initialize tracking for this name if not exists
        if expression not in self.used_letters_from_names:
            matches = re.findall(r'[A-Z][\']*', expression)
            # Store all letters, including those that might be used
            self.used_letters_from_names[expression] = {
                'letters': list(dict.fromkeys(matches)),  # All letters
                'next_index': 0  # Next unused letter index
            }
            
        name_data = self.used_letters_from_names[expression]
        available_letters = name_data['letters']
        start_index = name_data['next_index']
        
        # Get the next n letters
        result = []
        for i in range(n):
            if start_index + i < len(available_letters):
                result.append(available_letters[start_index + i])
            else:
                result.append('')
                
        # Update the next index
        name_data['next_index'] = min(start_index + n, len(available_letters))
        
        return result

    def _generate_unique_point_name(self):
        alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        point_names = self.get_drawable_names('Point')
        # Start with no apostrophes and increase the number of apostrophes until a unique name is found
        num_apostrophes = 0
        while True:
            for letter in alphabet:
                name = letter + "'" * num_apostrophes
                if name not in point_names:
                    return name
            num_apostrophes += 1

    def generate_point_name(self, preferred_name):
        if not preferred_name:
            return self._generate_unique_point_name()
            
        # Filter and uppercase the preferred name
        preferred_name = self.filter_string(preferred_name).upper()
        point_names = self.get_drawable_names('Point')
        
        # Initialize tracking for this name if not exists
        if preferred_name not in self.used_letters_from_names:
            matches = re.findall(r'[A-Z][\']*', preferred_name)
            self.used_letters_from_names[preferred_name] = {
                'letters': list(dict.fromkeys(matches)),  # All available letters with their apostrophes
                'next_index': 0  # Next unused letter index
            }
        
        name_data = self.used_letters_from_names[preferred_name]
        available_letters = name_data['letters']
        start_index = name_data['next_index']
        
        # Try each remaining letter (with its apostrophes) from the preferred name
        for i in range(start_index, len(available_letters)):
            letter_with_apostrophes = available_letters[i]
            base_letter = letter_with_apostrophes[0]  # Get just the letter without apostrophes
            # Try the letter as is first
            if letter_with_apostrophes not in point_names:
                name_data['next_index'] = i + 1
                return letter_with_apostrophes
            # If the letter is used, try adding apostrophes
            num_apostrophes = letter_with_apostrophes.count("'") + 1
            while True:
                name = base_letter + "'" * num_apostrophes
                if name not in point_names:
                    name_data['next_index'] = i + 1
                    return name
                num_apostrophes += 1
                # If we've tried too many apostrophes, move to next letter
                if num_apostrophes > 5:  # Arbitrary limit to prevent infinite loop
                    break
                
        # If no letters from preferred name are available, generate a unique name
        return self._generate_unique_point_name()

    def _increment_function_name(self, func_name):
        func_name = self.filter_string(func_name)
        # Check if there is a number after the function name, if not, append 1; if there is, increment it
        match = re.search(r'(?<=\w)(\d+)$', func_name)
        if match:
            number = int(match.group())
            func_name = func_name[:match.start()] + str(number + 1)
        else:
            # If there is no number, simply append '1' to the function name
            func_name += '1'
        return func_name

    def _generate_unique_function_name(self):
        func_alphabet = 'fghijklmnopqrstuvwxyzabcde'
        function_names = self.get_drawable_names('Function')
        for number in count():
            for letter in func_alphabet:
                func_name = f"{letter}{number if number > 0 else ''}"
                if func_name not in function_names:
                    return func_name
        raise ValueError("All function names are taken")

    def generate_function_name(self, preferred_name):
        if not preferred_name:
            return self._generate_unique_function_name()
        function_names = self.get_drawable_names('Function')
        # get the function name before the first '('
        match = re.search(r'(?<=\w)(?=\()', preferred_name)
        if match:
            preferred_name = preferred_name[:match.start()]
        # If the preferred name is not already used, return it
        if preferred_name not in function_names:
            return preferred_name
        # If the preferred name is already used, increment until we generate a new unique name
        while True:
            preferred_name = self._increment_function_name(preferred_name)
            if preferred_name not in function_names:
                return preferred_name