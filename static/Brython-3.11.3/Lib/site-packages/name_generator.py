from itertools import count
import re


class NameGenerator:
    """Base class for name generation with common utilities."""
    
    def __init__(self, canvas):
        self.canvas = canvas
    
    def get_drawable_names(self, class_name):
        """Get sorted list of names for drawables of a specific class."""
        drawables = self.canvas.get_drawables_by_class_name(class_name)
        drawable_names = sorted([drawable.name for drawable in drawables])
        return drawable_names
    
    def filter_string(self, name):
        """Filter a string to keep only letters, apostrophes, digits, and parentheses."""
        if not name:
            return ""
        pattern = r"[a-zA-Z0-9'\(\)]+"
        matches = re.findall(pattern, name)
        return ''.join(matches)


class PointNameGenerator(NameGenerator):
    """Specialized generator for point names."""
    
    def __init__(self, canvas):
        super().__init__(canvas)
        self.used_letters_from_names = {}  # Track which letters have been used for each name
    
    def _init_tracking_for_expression(self, expression):
        """Initialize tracking for a point expression."""
        if expression not in self.used_letters_from_names:
            matches = re.findall(r'[A-Z][\']*', expression)
            self.used_letters_from_names[expression] = {
                'letters': list(dict.fromkeys(matches)),  # All letters
                'next_index': 0  # Next unused letter index
            }
        return self.used_letters_from_names[expression]
    
    def _get_next_letters(self, name_data, n):
        """Extract the next n letters from the name data."""
        available_letters = name_data['letters']
        start_index = name_data['next_index']
        
        result = []
        for i in range(n):
            if start_index + i < len(available_letters):
                result.append(available_letters[start_index + i])
            else:
                result.append('')
                
        # Update the next index
        name_data['next_index'] = min(start_index + n, len(available_letters))
        return result
    
    def split_point_names(self, expression, n=2):
        """Split a point expression into individual point names."""
        if expression is None or len(expression) < 1:
            return [''] * n
            
        expression = self.filter_string(expression)
        expression = expression.upper()
        
        # Initialize tracking for this name
        name_data = self._init_tracking_for_expression(expression)
        
        # Get the next n letters
        return self._get_next_letters(name_data, n)
    
    def _generate_unique_point_name(self):
        """Generate a unique point name using alphabetical sequence with apostrophes."""
        alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        point_names = self.get_drawable_names('Point')
        
        return self._find_available_name_from_alphabet(alphabet, point_names)
    
    def _find_available_name_from_alphabet(self, alphabet, existing_names):
        """Find an available name from an alphabet, adding apostrophes as needed."""
        num_apostrophes = 0
        while True:
            for letter in alphabet:
                name = letter + "'" * num_apostrophes
                if name not in existing_names:
                    return name
            num_apostrophes += 1
    
    def _init_tracking_for_preferred_name(self, preferred_name):
        """Initialize tracking for a preferred point name."""
        if preferred_name not in self.used_letters_from_names:
            matches = re.findall(r'[A-Z][\']*', preferred_name)
            self.used_letters_from_names[preferred_name] = {
                'letters': list(dict.fromkeys(matches)),  # All available letters with their apostrophes
                'next_index': 0  # Next unused letter index
            }
        return self.used_letters_from_names[preferred_name]
    
    def _find_available_name_from_preferred(self, letter_with_apostrophes, point_names):
        """Find an available name based on a preferred letter, adding apostrophes if needed."""
        base_letter = letter_with_apostrophes[0]  # Get just the letter without apostrophes
        
        # Try the letter as is first
        if letter_with_apostrophes not in point_names:
            return letter_with_apostrophes
            
        # Try adding apostrophes
        return self._try_add_apostrophes(base_letter, point_names)
    
    def _try_add_apostrophes(self, base_letter, point_names, initial_count=1, max_attempts=5):
        """Try adding apostrophes to a base letter until finding an unused name."""
        num_apostrophes = initial_count
        
        while num_apostrophes <= max_attempts:
            name = base_letter + "'" * num_apostrophes
            if name not in point_names:
                return name
            num_apostrophes += 1
            
        return None  # Could not find an available name with reasonable apostrophes
    
    def generate_point_name(self, preferred_name):
        """Generate a unique point name, using preferred_name if possible."""
        if not preferred_name:
            return self._generate_unique_point_name()
            
        # Filter and uppercase the preferred name
        preferred_name = self.filter_string(preferred_name).upper()
        point_names = self.get_drawable_names('Point')
        
        # Initialize tracking for this name
        name_data = self._init_tracking_for_preferred_name(preferred_name)
        available_letters = name_data['letters']
        start_index = name_data['next_index']
        
        # Try each remaining letter from the preferred name
        for i in range(start_index, len(available_letters)):
            letter_with_apostrophes = available_letters[i]
            
            name = self._find_available_name_from_preferred(letter_with_apostrophes, point_names)
            if name:
                name_data['next_index'] = i + 1
                return name
                
        # If no letters from preferred name are available, generate a unique name
        return self._generate_unique_point_name()


class FunctionNameGenerator(NameGenerator):
    """Specialized generator for function names."""
    
    def _extract_number_suffix(self, func_name):
        """Extract a numeric suffix from a function name if present."""
        match = re.search(r'(?<=\w)(\d+)$', func_name)
        if match:
            number = int(match.group())
            prefix = func_name[:match.start()]
            return prefix, number
        return func_name, None
    
    def _increment_function_name(self, func_name):
        """Increment a function name by adding or incrementing a number suffix."""
        func_name = self.filter_string(func_name)
        
        prefix, number = self._extract_number_suffix(func_name)
        
        if number is not None:
            return prefix + str(number + 1)
        else:
            return func_name + '1'
    
    def _try_function_name(self, letter, number, existing_names):
        """Try a function name with the given letter and number."""
        func_name = f"{letter}{number if number > 0 else ''}"
        if func_name not in existing_names:
            return func_name
        return None
    
    def _generate_unique_function_name(self):
        """Generate a unique function name using alphabetical sequence."""
        func_alphabet = 'fghijklmnopqrstuvwxyzabcde'
        function_names = self.get_drawable_names('Function')
        
        for number in count():
            for letter in func_alphabet:
                name = self._try_function_name(letter, number, function_names)
                if name:
                    return name
                    
        raise ValueError("All function names are taken")
    
    def _extract_function_name_before_parenthesis(self, preferred_name):
        """Extract the function name before any parenthesis."""
        match = re.search(r'(?<=\w)(?=\()', preferred_name)
        if match:
            return preferred_name[:match.start()]
        return preferred_name
    
    def _find_available_function_name(self, preferred_name, function_names):
        """Find an available function name based on the preferred name."""
        if preferred_name not in function_names:
            return preferred_name
            
        # Try incrementing until we find an available name
        current_name = preferred_name
        while True:
            current_name = self._increment_function_name(current_name)
            if current_name not in function_names:
                return current_name
    
    def generate_function_name(self, preferred_name):
        """Generate a unique function name, using preferred_name if possible."""
        if not preferred_name:
            return self._generate_unique_function_name()
            
        function_names = self.get_drawable_names('Function')
        
        # Extract name before parenthesis if present
        clean_name = self._extract_function_name_before_parenthesis(preferred_name)
        
        # Find an available function name
        return self._find_available_function_name(clean_name, function_names)


class DrawableNameGenerator:
    """Main class that orchestrates the generation of various drawable names."""
    
    def __init__(self, canvas):
        self.canvas = canvas
        self.used_letters_from_names = {}  # Maintain for backward compatibility
        
        # Initialize specialized generators
        self.point_generator = PointNameGenerator(canvas)
        self.function_generator = FunctionNameGenerator(canvas)
    
    def print_names(self):
        """Print all drawable names by category."""
        print(f"Point names: {self.get_drawable_names('Point')}")
        print(f"Segment names: {self.get_drawable_names('Segment')}")
        print(f"Triangle names: {self.get_drawable_names('Triangle')}")
        print(f"Rectangle names: {self.get_drawable_names('Rectangle')}")
        print(f"Circle names: {self.get_drawable_names('Circle')}")
        print(f"Ellipse names: {self.get_drawable_names('Ellipse')}")
        print(f"Function names: {self.get_drawable_names('Function')}")
    
    # Delegate methods to specialized generators or base NameGenerator
    
    def get_drawable_names(self, class_name):
        """Get sorted list of names for drawables of a specific class."""
        drawables = self.canvas.get_drawables_by_class_name(class_name)
        drawable_names = sorted([drawable.name for drawable in drawables])
        return drawable_names
    
    def filter_string(self, name):
        """Filter a string to keep only letters, apostrophes, digits, and parentheses."""
        return self.point_generator.filter_string(name)
    
    def split_point_names(self, expression, n=2):
        """Split a point expression into individual point names."""
        # Update our internal tracker for backward compatibility
        result = self.point_generator.split_point_names(expression, n)
        if expression and expression in self.point_generator.used_letters_from_names:
            self.used_letters_from_names[expression] = self.point_generator.used_letters_from_names[expression]
        return result
    
    def _generate_unique_point_name(self):
        """Generate a unique point name using alphabetical sequence with apostrophes."""
        return self.point_generator._generate_unique_point_name()
    
    def generate_point_name(self, preferred_name):
        """Generate a unique point name, using preferred_name if possible."""
        # Update our internal tracker for backward compatibility
        result = self.point_generator.generate_point_name(preferred_name)
        if preferred_name and preferred_name in self.point_generator.used_letters_from_names:
            self.used_letters_from_names[preferred_name] = self.point_generator.used_letters_from_names[preferred_name]
        return result
    
    def _increment_function_name(self, func_name):
        """Increment a function name by adding or incrementing a number suffix."""
        return self.function_generator._increment_function_name(func_name)
    
    def _generate_unique_function_name(self):
        """Generate a unique function name using alphabetical sequence."""
        return self.function_generator._generate_unique_function_name()
    
    def generate_function_name(self, preferred_name):
        """Generate a unique function name, using preferred_name if possible."""
        return self.function_generator.generate_function_name(preferred_name)