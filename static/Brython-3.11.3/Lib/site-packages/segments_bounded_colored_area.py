from colored_area import ColoredArea
from segment import Segment
import copy

class SegmentsBoundedColoredArea(ColoredArea):
    def __init__(self, segment1, segment2=None, canvas=None, color="lightblue", opacity=0.3):
        """
        Creates a colored area bounded by a segment and either another segment or the x-axis.
        segment2=None means the area will be bounded by segment1 and the x-axis.
        """
        name = self._generate_name(segment1, segment2)
        super().__init__(name=name, canvas=canvas, color=color, opacity=opacity)
        self.segment1 = segment1
        self.segment2 = segment2

    def _generate_name(self, segment1, segment2):
        """Generate a descriptive name for the colored area"""
        s1_name = segment1.name if segment1 else 'x_axis'
        s2_name = segment2.name if segment2 else 'x_axis'
        return f"area_between_{s1_name}_and_{s2_name}"

    def get_class_name(self):
        return 'SegmentsBoundedColoredArea'

    def draw(self):
        # For segment1, use endpoints in order
        points = [(self.segment1.point1.x, self.segment1.point1.y),
                 (self.segment1.point2.x, self.segment1.point2.y)]

        # For segment2 or x-axis, get reverse points
        if self.segment2:
            # Use segment2's endpoints in reverse order
            reverse_points = [(self.segment2.point2.x, self.segment2.point2.y),
                            (self.segment2.point1.x, self.segment2.point1.y)]
        else:
            # Use x-axis points below segment1's endpoints
            reverse_points = [(self.segment1.point2.x, 0),
                            (self.segment1.point1.x, 0)]

        # Create SVG path using base class method
        self._create_svg_path(points, reverse_points)

    def uses_segment(self, segment):
        """Check if this colored area uses a specific segment"""
        def segments_match(s1, s2):
            return (s1.point1.x == s2.point1.x and 
                   s1.point1.y == s2.point1.y and
                   s1.point2.x == s2.point2.x and
                   s1.point2.y == s2.point2.y)

        return segments_match(self.segment1, segment) or (self.segment2 and segments_match(self.segment2, segment))

    def get_state(self):
        state = super().get_state()
        state["args"].update({
            "segment1": self.segment1.name,
            "segment2": self.segment2.name if self.segment2 else None
        })
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
            
        # Create new instance using __init__
        new_area = SegmentsBoundedColoredArea(
            segment1=self.segment1,  # Segments will be properly deep copied by their own __deepcopy__
            segment2=self.segment2,
            canvas=self.canvas,  # Canvas reference is not deep copied
            color=self.color,
            opacity=self.opacity
        )
        memo[id(self)] = new_area
        return new_area 