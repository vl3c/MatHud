import unittest
import copy
from geometry import Position, Function
from expression_validator import ExpressionValidator
from .simple_mock import SimpleMock


class TestFunction(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0),
                                 get_visible_left_bound=SimpleMock(return_value=-10),
                                 get_visible_right_bound=SimpleMock(return_value=10),
                                 get_visible_top_bound=SimpleMock(return_value=10),
                                 get_visible_bottom_bound=SimpleMock(return_value=-10)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True))
        self.left_bound = -9
        self.right_bound = 9
        self.function_string = "x*2"
        self.name = "DoubleX"
        self.function = Function(self.function_string, self.canvas, self.name, left_bound=self.left_bound, right_bound=self.right_bound)

    def test_initialize(self):
        # Test that the function is correctly initialized
        self.assertEqual(self.function.function_string, ExpressionValidator.fix_math_expression(self.function_string))
        self.assertIsNotNone(self.function.function)
        self.assertEqual(self.function.name, self.name)

    def test_init_with_invalid_function_explicit(self):
        with self.assertRaises(ValueError):
            _ = Function("sin(/0)", self.canvas, "InvalidFunction")

    def test_get_class_name(self):
        self.assertEqual(self.function.get_class_name(), 'Function')

    def test_generate_values(self):
        # Test the generation of function values within canvas bounds
        values = self.function._generate_paths()
        self.assertTrue(len(values) > 0)
        
        # Check x bounds (these should still be strict)
        for value in values:
            self.assertTrue(self.canvas.cartesian2axis.get_visible_left_bound() <= value.x <= self.canvas.cartesian2axis.get_visible_right_bound())
        
        # Count points within and outside y bounds
        points_within_bounds = 0
        points_outside_bounds = 0
        top_bound = self.canvas.cartesian2axis.get_visible_top_bound()
        bottom_bound = self.canvas.cartesian2axis.get_visible_bottom_bound()
        
        for value in values:
            if bottom_bound <= value.y <= top_bound:
                points_within_bounds += 1
            else:
                points_outside_bounds += 1
        
        # Ensure majority of points are within bounds
        self.assertGreater(points_within_bounds, points_outside_bounds, 
                          "Majority of points should be within y bounds")

    def test_zoom(self):
        # Test zoom functionality (mainly impacts _generate_values)
        self.function.zoom()  # This might not change anything directly but can prepare for future tests with scale_factor changes

    def test_get_state(self):
        state = self.function.get_state()
        expected_state = {"name": self.name, "args": {"function_string": self.function_string, "left_bound": self.left_bound, "right_bound": self.right_bound}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        function_copy = copy.deepcopy(self.function)
        self.assertIsNot(function_copy, self.function)
        self.assertEqual(function_copy.function_string, self.function.function_string)
        self.assertEqual(function_copy.name, self.function.name)

    def test_scaled_to_original_and_back(self):
        # Test conversion from scaled to original coordinates and back
        original = (2, 4)
        scaled = self.function._original_to_scaled(*original)
        back_to_original = self.function._scaled_to_original(scaled.x, scaled.y)
        self.assertAlmostEqual(original[0], back_to_original.x)
        self.assertAlmostEqual(original[1], back_to_original.y)

    def test_caching_mechanism(self):
        # Test that points are cached and reused
        self.function._cached_paths = None
        self.function._cache_valid = False
        
        # First draw should generate points
        points = self.function._generate_paths()
        self.function._cached_paths = points
        self.function._cache_valid = True
        initial_points = self.function._cached_paths
        
        self.assertIsNotNone(initial_points)
        self.assertTrue(self.function._cache_valid)

    def test_cache_invalidation_on_zoom(self):
        # Test that cache is invalidated on zoom
        points = self.function._generate_paths()
        self.function._cached_paths = points
        self.function._cache_valid = True
        initial_points = self.function._cached_paths
        
        self.function.zoom()
        self.assertFalse(self.function._cache_valid)
        
        # Change scale factor to simulate zoom
        self.canvas.scale_factor = 2
        new_points = self.function._generate_paths()
        self.function._cached_paths = new_points
        self.assertNotEqual(len(initial_points), len(new_points))

    def test_cache_invalidation_on_pan(self):
        # Test that cache is invalidated on pan
        self.function.draw()
        initial_points = self.function._cached_paths
        
        self.function.pan()
        self.assertFalse(self.function._cache_valid)

    def test_adaptive_step_size(self):
        # Test function with varying slopes
        steep_function = Function("100*x", self.canvas, "Steep")
        gradual_function = Function("0.1*x", self.canvas, "Gradual")
        
        steep_points = steep_function._generate_paths()
        gradual_points = gradual_function._generate_paths()
        
        # Steep function should have fewer points due to larger step size
        self.assertLess(len(steep_points), len(gradual_points))

    def test_discontinuity_handling(self):
        # Test function with discontinuity
        discontinuous_function = Function("1/x", self.canvas, "Discontinuous", step=0.5)  # Smaller step size
        points = discontinuous_function._generate_paths()
        
        # Find gaps in x coordinates that indicate discontinuity
        has_discontinuity = False
        for i in range(1, len(points)):
            original_p1 = self.function._scaled_to_original(points[i-1].x, points[i-1].y)
            original_p2 = self.function._scaled_to_original(points[i].x, points[i].y)
            # Check for either a large x gap or a transition through bounds
            if (abs(original_p2.x - original_p1.x) > discontinuous_function.step * 2) or \
               (abs(original_p2.y - original_p1.y) > (self.canvas.cartesian2axis.get_visible_top_bound() - 
                                                     self.canvas.cartesian2axis.get_visible_bottom_bound())):
                has_discontinuity = True
                break
        
        self.assertTrue(has_discontinuity)

    def test_bounds_checking(self):
        # Test that points are properly bounded
        self.canvas.cartesian2axis.get_visible_left_bound.return_value = -5
        self.canvas.cartesian2axis.get_visible_right_bound.return_value = 5
        self.canvas.cartesian2axis.get_visible_top_bound.return_value = 5
        self.canvas.cartesian2axis.get_visible_bottom_bound.return_value = -5
        
        # Need to update the function's bounds as well
        self.function.left_bound = -5
        self.function.right_bound = 5
        
        points = self.function._generate_paths()
        
        for point in points:
            # We need to check the original coordinates, not the scaled ones
            original_pos = self.function._scaled_to_original(point.x, point.y)
            # Add some tolerance for floating-point comparisons
            self.assertGreaterEqual(original_pos.x, -5.1)
            self.assertLessEqual(original_pos.x, 5.1)
            self.assertGreaterEqual(original_pos.y, -10.1)  # y=2x means y range is double x range
            self.assertLessEqual(original_pos.y, 10.1)

    def test_should_regenerate_points(self):
        # Test conditions for point regeneration
        points = self.function._generate_paths()
        self.function._cached_paths = points
        self.function._cache_valid = True
        self.function._last_scale = self.canvas.scale_factor
        self.function._last_bounds = (
            self.canvas.cartesian2axis.get_visible_left_bound(),
            self.canvas.cartesian2axis.get_visible_right_bound(),
            self.canvas.cartesian2axis.get_visible_top_bound(),
            self.canvas.cartesian2axis.get_visible_bottom_bound()
        )

    def test_draw_with_empty_points(self):
        # Test drawing behavior when no points are generated
        # Mock _generate_values to return empty list
        original_generate = self.function._generate_paths
        self.function._generate_paths = lambda: []
        
        # Should not raise error when drawing with no points
        self.function.draw()
        
        # Restore original method
        self.function._generate_paths = original_generate

    def test_deepcopy_with_cache(self):
        # Test that deepcopy properly handles cache attributes
        self.function.draw()  # Generate initial cache
        function_copy = copy.deepcopy(self.function)
        
        self.assertIsNone(function_copy._cached_paths)
        self.assertFalse(function_copy._cache_valid)
        self.assertIsNone(function_copy._last_scale)
        self.assertIsNone(function_copy._last_bounds)

    def test_performance_limits(self):
        # Test that point generation doesn't exceed limits
        complex_function = Function("sin(x*10)", self.canvas, "Complex")
        points = complex_function._generate_paths()
        
        # Check number of points is reasonable
        self.assertLess(len(points), 1001, "Should not exceed maximum points limit")
        
        # Check minimum distance between points
        for i in range(1, len(points)):
            dx = abs(points[i].x - points[i-1].x)
            dy = abs(points[i].y - points[i-1].y)
            self.assertGreater(dx + dy, 0, "Points should not be duplicates")

    def test_high_frequency_trig_functions(self):
        test_cases = [
            ("10*sin(10*x)", "High frequency and amplitude"),
            ("sin(20*x)", "High frequency only"),
            ("5*sin(x)", "High amplitude only"),
            ("2*sin(3*x)", "Medium frequency and amplitude"),
            ("100*sin(50*x)", "Very high frequency and amplitude")
        ]
        
        for function_string, _ in test_cases:
            with self.subTest(function_string=function_string):
                try:
                    f = Function(function_string, self.canvas, "test_func")
                    points = f._generate_paths()
                    self.assertIsNotNone(points)
                    self.assertGreater(len(points), 0)
                    # All functions should maintain roughly 200 points
                    self.assertGreater(len(points), 100)  # Lower bound
                    self.assertLess(len(points), 500)     # Upper bound
                except Exception as e:
                    self.fail(f"Failed to handle {function_string}: {str(e)}")

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass

