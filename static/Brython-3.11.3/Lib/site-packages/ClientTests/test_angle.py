import unittest
from copy import deepcopy

from drawables.angle import Angle
from .simple_mock import SimpleMock
from name_generator.drawable import DrawableNameGenerator

class TestAngle(unittest.TestCase):
    def setUp(self):
        # Setup for Canvas first, as DrawableNameGenerator needs it
        self.canvas = SimpleMock(
            # drawable_manager will be set after it's created
            create_svg_element = lambda tag_name, attributes, text_content=None: {"tag": tag_name, "attrs": attributes, "text": text_content}
        )

        # Instantiate the real name generator
        self.name_generator = DrawableNameGenerator(self.canvas)

        # Setup for DrawableManager
        self.drawable_manager_segments = {}
        def get_segment_by_name_mock(name):
            return self.drawable_manager_segments.get(name)
        def add_segment_mock(segment):
            self.drawable_manager_segments[segment.name] = segment

        self.drawable_manager = SimpleMock(
            get_segment_by_name = get_segment_by_name_mock,
            add_segment = add_segment_mock,
            name_generator = self.name_generator
        )
        
        # Now that drawable_manager is created, assign it to canvas mock
        self.canvas.drawable_manager = self.drawable_manager

        # Points using SimpleMock with single letter names
        self.A = SimpleMock(name="A", x=0, y=0)
        self.B = SimpleMock(name="B", x=10, y=0)
        self.C = SimpleMock(name="C", x=0, y=10)
        self.D = SimpleMock(name="D", x=10, y=10)
        self.E = SimpleMock(name="E", x=-10, y=0)
        
        # Segments using SimpleMock with names derived from points
        self.s_AB = SimpleMock(name="AB", point1=self.A, point2=self.B, canvas=self.canvas)
        self.s_AC = SimpleMock(name="AC", point1=self.A, point2=self.C, canvas=self.canvas)
        self.s_AD = SimpleMock(name="AD", point1=self.A, point2=self.D, canvas=self.canvas)
        self.s_AE = SimpleMock(name="AE", point1=self.A, point2=self.E, canvas=self.canvas)
        self.s_BD = SimpleMock(name="BD", point1=self.B, point2=self.D, canvas=self.canvas) # Used for no common vertex test
        self.s_CD = SimpleMock(name="CD", point1=self.C, point2=self.D, canvas=self.canvas) # Used for no common vertex test

        # Add segments to the mock drawable_manager
        self.drawable_manager.add_segment(self.s_AB)
        self.drawable_manager.add_segment(self.s_AC)
        self.drawable_manager.add_segment(self.s_AD)
        self.drawable_manager.add_segment(self.s_AE)
        self.drawable_manager.add_segment(self.s_BD)
        self.drawable_manager.add_segment(self.s_CD)

    def test_initialization_valid_90_degrees(self):
        angle = Angle(self.s_AB, self.s_AC, self.canvas)
        self.assertIsNotNone(angle)
        # For SimpleMock, direct object comparison (is) should work for points if they are the same instances
        self.assertIs(angle.vertex_point, self.A)
        self.assertIs(angle.arm1_point, self.B)
        self.assertIs(angle.arm2_point, self.C)
        self.assertAlmostEqual(angle.angle_degrees, 90.0, places=5)
        # Corrected expected name for vertex A, arms B, C (sorted B,C)
        self.assertEqual(angle.name, "angle_BAC")

    def test_initialization_valid_45_degrees(self):
        angle = Angle(self.s_AB, self.s_AD, self.canvas)
        self.assertIsNotNone(angle)
        self.assertIs(angle.vertex_point, self.A)
        self.assertIs(angle.arm1_point, self.B)
        self.assertIs(angle.arm2_point, self.D)
        self.assertAlmostEqual(angle.angle_degrees, 45.0, places=5)
        # Corrected expected name for vertex A, arms B, D (sorted B,D)
        self.assertEqual(angle.name, "angle_BAD")

    def test_initialization_valid_180_degrees(self):
        angle = Angle(self.s_AB, self.s_AE, self.canvas)
        self.assertIsNotNone(angle)
        self.assertIs(angle.vertex_point, self.A)
        self.assertIs(angle.arm1_point, self.B)
        self.assertIs(angle.arm2_point, self.E)
        self.assertAlmostEqual(angle.angle_degrees, 180.0, places=5)
        # Corrected expected name for vertex A, arms B, E (sorted B,E)
        self.assertEqual(angle.name, "angle_BAE")

    def test_initialization_invalid_no_common_vertex(self):
        # s_AB (A-B) and s_CD (C-D)
        with self.assertRaisesRegex(ValueError, "segments do not form a valid angle"):
            Angle(self.s_AB, self.s_CD, self.canvas)

    def test_initialization_invalid_collinear_overlapping_same_segment(self):
        s_AB_copy = SimpleMock(name="AB_copy", point1=self.A, point2=self.B, canvas=self.canvas)
        with self.assertRaisesRegex(ValueError, "segments do not form a valid angle"):
            Angle(self.s_AB, s_AB_copy, self.canvas)

    def test_initialization_invalid_one_segment_is_point_at_vertex(self):
        p_at_vertex = SimpleMock(name="A_vtx_copy", x=self.A.x, y=self.A.y) # Point identical to A
        s_degenerate = SimpleMock(name="S_Deg", point1=self.A, point2=p_at_vertex, canvas=self.canvas)
        with self.assertRaisesRegex(ValueError, "segments do not form a valid angle"):
            Angle(self.s_AB, s_degenerate, self.canvas)

    def test_angle_calculation_270_degrees_or_minus_90(self):
        # Angle from s_AC (A-C) to s_AB (A-B) -> Vertex A, Arms C, B (sorted B,C)
        angle = Angle(self.s_AC, self.s_AB, self.canvas)
        self.assertAlmostEqual(angle.angle_degrees, 270.0, places=5)
        # Corrected expected name
        self.assertEqual(angle.name, "angle_BAC")

    def test_angle_calculation_zero_length_arm(self):
        A_copy = SimpleMock(name="A_copy", x=self.A.x, y=self.A.y)
        s_zero_arm = SimpleMock(name="S_Zero", point1=self.A, point2=A_copy, canvas=self.canvas)
        with self.assertRaisesRegex(ValueError, "segments do not form a valid angle"):
             Angle(s_zero_arm, self.s_AC, self.canvas)

    def test_initialization_with_none_segment(self):
        with self.assertRaisesRegex(ValueError, "segments do not form a valid angle"):
            Angle(None, self.s_AC, self.canvas)
        with self.assertRaisesRegex(ValueError, "segments do not form a valid angle"):
            Angle(self.s_AB, None, self.canvas)
        with self.assertRaisesRegex(ValueError, "segments do not form a valid angle"):
            Angle(None, None, self.canvas)

    def test_get_class_name(self):
        angle = Angle(self.s_AB, self.s_AC, self.canvas)
        self.assertEqual(angle.get_class_name(), 'Angle')

    def test_canvas_property(self):
        angle = Angle(self.s_AB, self.s_AC, self.canvas)
        self.assertIs(angle.canvas, self.canvas)
        self.assertIs(angle.segment1.canvas, self.canvas)
        self.assertIs(angle.segment2.canvas, self.canvas)

        new_canvas_mock = SimpleMock(name="NewCanvas")
        angle.canvas = new_canvas_mock
        self.assertIs(angle.canvas, new_canvas_mock)
        # Check if segments' canvas reference was updated
        self.assertIs(angle.segment1.canvas, new_canvas_mock)
        self.assertIs(angle.segment2.canvas, new_canvas_mock)

    def test_get_state_and_from_state(self):
        # Angle from s_AB, s_AD. Points A, B, D. Vertex A, Arms B,D (sorted B,D)
        angle1 = Angle(self.s_AB, self.s_AD, self.canvas)
        # Corrected expected name
        self.assertEqual(angle1.name, "angle_BAD")
        state = angle1.get_state()

        expected_state = {
            # Corrected expected name in state
            "name": "angle_BAD",
            "type": "angle",
            "args": {
                "segment1_name": "AB",
                "segment2_name": "AD",
                "color": "blue"
            }
        }
        self.assertEqual(state, expected_state)

        self.drawable_manager.add_segment(self.s_AB)
        self.drawable_manager.add_segment(self.s_AD)

        angle2 = Angle.from_state(state, self.canvas)
        self.assertIsNotNone(angle2)
        self.assertEqual(angle2.color, "blue")
        self.assertEqual(angle2.segment1.name, "AB")
        self.assertEqual(angle2.segment2.name, "AD")
        self.assertAlmostEqual(angle2.angle_degrees, 45.0, places=5)

    def test_from_state_segment_not_found(self):
        state = {
            "name": "ghost_angle",
            "type": "angle",
            "args": {"segment1_name": "NonExistentS1", "segment2_name": "AD", "color": "blue"}
        }
        self.drawable_manager.add_segment(self.s_AD)
        
        angle = Angle.from_state(state, self.canvas)
        self.assertIsNone(angle)

    def test_update_points_based_on_segments(self):
        # Angle from s_AB, s_AC. Points A,B,C. Expected angle 90.
        angle = Angle(self.s_AB, self.s_AC, self.canvas)
        self.assertAlmostEqual(angle.angle_degrees, 90.0)

        original_C_y = self.C.y
        original_C_x = self.C.x
        self.C.x = 10 # C was (0,10), now (10,0) which is B's location
        self.C.y = 0 
        
        if hasattr(angle, 'update_points_based_on_segments'):
            result = angle.update_points_based_on_segments()
            self.assertFalse(result)
            self.assertIsNone(angle.angle_degrees)
        else:
            angle._initialize()
            # If _initialize leads to an invalid state, angle_degrees should be None
            self.assertIsNone(angle.angle_degrees)

        self.C.x = original_C_x
        self.C.y = original_C_y

    def test_update_makes_angle_invalid(self):
        angle = Angle(self.s_AB, self.s_AC, self.canvas)
        
        original_B_x = self.B.x
        original_B_y = self.B.y
        self.B.x = self.A.x # Move B to A's location
        self.B.y = self.A.y

        if hasattr(angle, 'update_points_based_on_segments'):
            result = angle.update_points_based_on_segments()
            self.assertFalse(result) 
            self.assertIsNone(angle.angle_degrees)
        else:
            angle._initialize()
            # If _initialize leads to an invalid state, angle_degrees should be None
            self.assertIsNone(angle.angle_degrees)

        self.B.x = original_B_x
        self.B.y = original_B_y

    def test_deepcopy_basic(self):
        # Angle from s_AB, s_AD. Points A,B,D. Vertex A, Arms B,D (sorted B,D)
        original_angle = Angle(self.s_AB, self.s_AD, self.canvas)
        # Corrected expected name
        self.assertEqual(original_angle.name, "angle_BAD") 
        
        memo = {}
        copied_angle = deepcopy(original_angle, memo)

        self.assertIsNot(original_angle, copied_angle)
        self.assertIs(copied_angle.canvas, original_angle.canvas) # canvas is not deepcopied
        
        # Segments should be deepcopied
        self.assertIsNot(copied_angle.segment1, original_angle.segment1)
        self.assertIsNot(copied_angle.segment2, original_angle.segment2)
        self.assertEqual(copied_angle.segment1.name, original_angle.segment1.name)
        self.assertEqual(copied_angle.segment2.name, original_angle.segment2.name)
        
        self.assertEqual(copied_angle.angle_degrees, original_angle.angle_degrees)
        self.assertEqual(copied_angle.color, "blue")

    def test_deepcopy_with_memo(self):
        # Angle from s_AB, s_AD. Points A,B,D. Vertex A, Arms B,D (sorted B,D)
        original_angle = Angle(self.s_AB, self.s_AD, self.canvas)
        # Corrected expected name
        self.assertEqual(original_angle.name, "angle_BAD")

        memo = {}
        copied_angle = deepcopy(original_angle, memo)

        self.assertIsNot(original_angle, copied_angle)
        self.assertIs(copied_angle.canvas, original_angle.canvas) # canvas is not deepcopied
        
        # Segments should be deepcopied
        self.assertIsNot(copied_angle.segment1, original_angle.segment1)
        self.assertIsNot(copied_angle.segment2, original_angle.segment2)
        self.assertEqual(copied_angle.segment1.name, original_angle.segment1.name)
        self.assertEqual(copied_angle.segment2.name, original_angle.segment2.name)
        
        self.assertEqual(copied_angle.angle_degrees, original_angle.angle_degrees)
        self.assertEqual(copied_angle.color, "blue")