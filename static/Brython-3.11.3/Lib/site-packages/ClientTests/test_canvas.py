import unittest
from random import randint
from canvas import Canvas
from expression_validator import ExpressionValidator
from utils.math_utils import MathUtils
from geometry import Position
from .simple_mock import SimpleMock
from utils.geometry_utils import GeometryUtils


class TestCanvas(unittest.TestCase):
    def setUp(self):
        self.canvas = Canvas(500, 500, draw_enabled=False)
        self.mock_cartesian2axis = SimpleMock(draw=SimpleMock(return_value=None), reset=SimpleMock(return_value=None),
                                              get_state=SimpleMock(return_value={'Cartesian_System_Visibility': 'cartesian_state'}),
                                              origin=Position(0, 0))
        self.canvas.cartesian2axis = self.mock_cartesian2axis
        self.mock_point1 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Point'), reset=SimpleMock(return_value=None),
                                      get_state=SimpleMock(return_value='point1_state'),
                                      original_position=Position(10, 10), x=10, y=10, name='A')
        self.mock_point2 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Point'), reset=SimpleMock(return_value=None),
                                      get_state=SimpleMock(return_value='point2_state'),
                                      original_position=Position(20, 20), x=20, y=20, name='B')
        self.mock_segment1 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Segment'), reset=SimpleMock(return_value=None),
                                        get_state=SimpleMock(return_value='segment1_state'), point1=self.mock_point1, point2=self.mock_point2)
        
        # Add backward-compatible drawables property for tests
        # This allows existing tests to work with the new DrawablesContainer
        # by providing getter and setter for the drawables dictionary
        def get_drawables():
            return self.canvas.drawable_manager.drawables._drawables
            
        def set_drawables(value):
            self.canvas.drawable_manager.drawables._drawables = value
            
        setattr(Canvas, 'drawables', property(get_drawables, set_drawables))

    def test_init(self):
        self.assertEqual(self.canvas.width, 500)
        self.assertEqual(self.canvas.height, 500)
        self.assertEqual(self.canvas.scale_factor, 1)
        self.assertEqual(self.canvas.zoom_point.x, 0)
        self.assertEqual(self.canvas.zoom_point.y, 0)
        self.assertEqual(self.canvas.zoom_direction, 0)
        self.assertEqual(self.canvas.zoom_step, 0.1)
        self.assertEqual(self.canvas.dragging, False)
        self.assertEqual(self.canvas.offset.x, 0)
        self.assertEqual(self.canvas.offset.y, 0)
        self.assertEqual(self.canvas.cartesian2axis, self.mock_cartesian2axis)

    def test_add_drawable(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.assertEqual(self.mock_point1.canvas, self.canvas)
        self.assertIn('Point', self.canvas.drawable_manager.drawables._drawables)
        self.assertIn('Segment', self.canvas.drawable_manager.drawables._drawables)
        self.assertIn(self.mock_point1, self.canvas.drawable_manager.drawables._drawables['Point'])
        self.assertIn(self.mock_segment1, self.canvas.drawable_manager.drawables._drawables['Segment'])

    def test_get_drawables(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        drawables = self.canvas.get_drawables()
        self.assertEqual(drawables, [self.mock_point1, self.mock_segment1])

    def test_get_drawables_by_class_name(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        drawables = self.canvas.get_drawables_by_class_name(self.mock_point1.get_class_name())
        self.assertEqual(drawables, [self.mock_point1])

    def test_fix_drawable_canvas_references(self):
        # Add drawables to the container rather than assigning directly
        self.canvas.drawable_manager.drawables._drawables = {'Point': [self.mock_point1], 'Segment': [self.mock_segment1]}
        self.assertEqual(self.mock_point1.canvas, None)
        self.assertEqual(self.mock_segment1.canvas, None)
        self.canvas._fix_drawable_canvas_references()
        self.assertEqual(self.mock_point1.canvas, self.canvas)
        self.assertEqual(self.mock_segment1.canvas, self.canvas)

    def test_get_drawables_state(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        state = self.canvas.get_drawables_state()
        self.assertEqual(state, {'Points': ['point1_state'], 'Segments': ['segment1_state']})

    def test_get_cartesian2axis_state(self):
        state = self.canvas.get_cartesian2axis_state()
        self.assertEqual(state, {'Cartesian_System_Visibility': 'cartesian_state'})

    def test_get_canvas_state(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        state = self.canvas.get_canvas_state()
        self.assertEqual(state, {'Points': ['point1_state'], 'Segments': ['segment1_state'], 'Cartesian_System_Visibility': 'cartesian_state'})

    def test_clear(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.canvas.clear()
        self.assertEqual(self.canvas.drawable_manager.drawables._drawables, {})
        self.assertTrue(len(self.mock_cartesian2axis.reset.calls) > 0)

    def test_reset(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.canvas.center = Position(randint(1, 100), randint(1, 100))
        self.canvas.scale_factor = randint(1, 100)
        self.canvas.offset = Position(randint(1, 100), randint(1, 100))
        self.dragging = True
        # Reset the canvas
        self.canvas.reset()
        # Test the canvas properties
        self.assertEqual(self.canvas.center.x, self.canvas.width / 2)
        self.assertEqual(self.canvas.center.y, self.canvas.height / 2)
        self.assertEqual(self.canvas.scale_factor, 1)
        self.assertEqual(self.canvas.offset.x, 0)
        self.assertEqual(self.canvas.offset.y, 0)
        self.assertEqual(self.canvas.dragging, False)
        # Check that reset methods were called once with no arguments
        self.mock_cartesian2axis.reset.assert_called_once_with()
        self.mock_point1.reset.assert_called_once_with()
        self.mock_segment1.reset.assert_called_once_with()

    def test_undo_redo(self):
        # Test basic undo/redo functionality
        point = self.canvas.create_point(0, 0, "A")
        segment = self.canvas.create_segment(0, 0, 10, 10, "AB")
        
        # Store initial state properties
        initial_point_pos = (point.original_position.x, point.original_position.y)
        initial_segment_points = (
            (segment.point1.original_position.x, segment.point1.original_position.y),
            (segment.point2.original_position.x, segment.point2.original_position.y)
        )
        
        # Make some changes
        self.canvas.delete_point_by_name("A")
        self.canvas.delete_segment_by_name("AB")
        
        # Verify changes
        self.assertIsNone(self.canvas.get_point_by_name("A"))
        self.assertIsNone(self.canvas.get_segment_by_name("AB"))
        
        # Undo changes
        self.canvas.undo()
        
        # Verify state is restored
        restored_point = self.canvas.get_point_by_name("A")
        restored_segment = self.canvas.get_segment_by_name("AB")
        
        self.assertIsNotNone(restored_point)
        self.assertIsNotNone(restored_segment)
        self.assertEqual(
            (restored_point.original_position.x, restored_point.original_position.y),
            initial_point_pos
        )
        self.assertEqual(
            (restored_segment.point1.original_position.x, restored_segment.point1.original_position.y),
            initial_segment_points[0]
        )
        self.assertEqual(
            (restored_segment.point2.original_position.x, restored_segment.point2.original_position.y),
            initial_segment_points[1]
        )
        
        # Redo changes
        self.canvas.redo()
        self.assertIsNone(self.canvas.get_point_by_name("A"))
        self.assertIsNone(self.canvas.get_segment_by_name("AB"))

    def test_get_canvas_state_and_reconstruct_preserves_integrity(self):
        """Test that getting canvas state and reconstructing it preserves integrity."""
        # 1. Populate the canvas with various elements
        pointA = self.canvas.create_point(10, 20, "A")
        pointB = self.canvas.create_point(30, 40, "B")
        pointC = self.canvas.create_point(50, 50, "C") 
        pointD = self.canvas.create_point(5, 15, "D") # New point for vector
        pointE = self.canvas.create_point(25, 35, "E") # New point for vector

        segmentAB = self.canvas.create_segment(pointA.original_position.x, pointA.original_position.y, 
                                              pointB.original_position.x, pointB.original_position.y)
        
        circleC = self.canvas.create_circle(pointC.original_position.x, pointC.original_position.y, 25)
        
        vectorDE = self.canvas.create_vector(pointD.original_position.x, pointD.original_position.y, # New vector
                                             pointE.original_position.x, pointE.original_position.y)

        self.canvas.draw_function("x**3", "f_cubed")
        self.canvas.add_computation("area_calc", 500.75)

        original_state = self.canvas.get_canvas_state()
        self.canvas.clear()

        # Reconstruct Points, Segments, Circles (with else: self.fail)
        if "Points" in original_state:
            for point_data in original_state["Points"]:
                pos = point_data['args']['position']
                self.canvas.create_point(pos['x'], pos['y'], point_data['name'])
        
        if "Segments" in original_state:
            for seg_data in original_state["Segments"]:
                p1_name = seg_data['args']['p1']
                p2_name = seg_data['args']['p2']
                p1 = self.canvas.get_point_by_name(p1_name)
                p2 = self.canvas.get_point_by_name(p2_name)
                if p1 and p2:
                    self.canvas.create_segment(p1.original_position.x, p1.original_position.y,
                                               p2.original_position.x, p2.original_position.y,
                                               seg_data['name'])
                else:
                    self.fail(f"Could not find points {p1_name} or {p2_name} for segment {seg_data['name']}")
        
        if "Circles" in original_state:
            for circ_data in original_state["Circles"]:
                center_name = circ_data['args']['center']
                radius = circ_data['args']['radius']
                center_point = self.canvas.get_point_by_name(center_name)
                if center_point:
                    self.canvas.create_circle(center_point.original_position.x, center_point.original_position.y,
                                              radius, circ_data['name'])
                else:
                    self.fail(f"Could not find center point {center_name} for circle {circ_data['name']}")

        # Reconstruct Vectors (with else: self.fail)
        if "Vectors" in original_state:
            for vec_data in original_state["Vectors"]:
                origin_name = vec_data['args']['origin']
                tip_name = vec_data['args']['tip']
                origin_point = self.canvas.get_point_by_name(origin_name)
                tip_point = self.canvas.get_point_by_name(tip_name)
                if origin_point and tip_point:
                    self.canvas.create_vector(origin_point.original_position.x, origin_point.original_position.y,
                                              tip_point.original_position.x, tip_point.original_position.y,
                                              vec_data['name'])
                else:
                    self.fail(f"Could not find points {origin_name} or {tip_name} for vector {vec_data['name']}")

        # Reconstruct Functions and Computations (with else: self.fail for computations)
        if "Functions" in original_state:
            for func_data in original_state["Functions"]:
                args = func_data['args']
                self.canvas.draw_function(
                    args["function_string"],
                    name=func_data.get("name", ""),
                    left_bound=args.get("left_bound"),
                    right_bound=args.get("right_bound")
                )
        
        if "computations" in original_state:
             for comp_data in original_state["computations"]:
                expression = comp_data.get("expression")
                result = comp_data.get("result")
                if expression is not None and result is not None:
                     self.canvas.add_computation(expression, result)
                else:
                    self.fail(f"Computation data missing expression or result: {comp_data}")

        reconstructed_state = self.canvas.get_canvas_state()

        # Assert counts
        self.assertEqual(len(original_state.get("Points", [])), len(reconstructed_state.get("Points", [])))
        self.assertEqual(len(original_state.get("Segments", [])), len(reconstructed_state.get("Segments", [])))
        self.assertEqual(len(original_state.get("Circles", [])), len(reconstructed_state.get("Circles", [])))
        self.assertEqual(len(original_state.get("Vectors", [])), len(reconstructed_state.get("Vectors", []))) # New assert for vectors
        self.assertEqual(len(original_state.get("Functions", [])), len(reconstructed_state.get("Functions", [])))
        self.assertEqual(len(original_state.get("computations", [])), len(reconstructed_state.get("computations", [])))

        # Assert specific elements by retrieving them based on known properties or constituent points
        rec_pointA = self.canvas.get_point_by_name("A")
        self.assertIsNotNone(rec_pointA, "Point A should be reconstructed")
        self.assertEqual(rec_pointA.original_position.x, 10)

        rec_pointB = self.canvas.get_point_by_name("B") # Get B for segment
        self.assertIsNotNone(rec_pointB, "Point B should be reconstructed")
        rec_segmentAB = self.canvas.get_segment_by_points(rec_pointA, rec_pointB)
        self.assertIsNotNone(rec_segmentAB, "Segment AB should be reconstructed")
        # We can check its constituent points if needed, e.g.:
        self.assertEqual(rec_segmentAB.point1.name, "A")
        self.assertEqual(rec_segmentAB.point2.name, "B")

        rec_pointC = self.canvas.get_point_by_name("C") # Get C for circle
        self.assertIsNotNone(rec_pointC, "Point C should be reconstructed")
        # Assuming the radius was 25 during creation
        rec_circleC = self.canvas.get_circle(rec_pointC.original_position.x, rec_pointC.original_position.y, 25)
        self.assertIsNotNone(rec_circleC, "Circle C should be reconstructed")
        self.assertEqual(rec_circleC.center.name, "C") # Changed from center_point to center
        self.assertEqual(rec_circleC.radius, 25)

        rec_pointD = self.canvas.get_point_by_name("D") # Get D for vector
        self.assertIsNotNone(rec_pointD, "Point D should be reconstructed")
        rec_pointE = self.canvas.get_point_by_name("E") # Get E for vector
        self.assertIsNotNone(rec_pointE, "Point E should be reconstructed")
        rec_vectorDE = self.canvas.get_vector(rec_pointD.original_position.x, rec_pointD.original_position.y, 
                                              rec_pointE.original_position.x, rec_pointE.original_position.y)
        self.assertIsNotNone(rec_vectorDE, "Vector DE should be reconstructed")
        self.assertEqual(rec_vectorDE.origin.name, "D")
        self.assertEqual(rec_vectorDE.tip.name, "E")

        rec_f_cubed = self.canvas.get_function("f_cubed")
        self.assertIsNotNone(rec_f_cubed)
        self.assertEqual(rec_f_cubed.function_string, "x^3")
        
        # Cleaned up: Removed duplicated detailed state comparison for brevity
        # Detailed comparison of sorted lists for each type
        for key in ["Points", "Segments", "Circles", "Vectors", "Functions"]:
            original_items = sorted(original_state.get(key, []), key=lambda x: x['name'])
            reconstructed_items = sorted(reconstructed_state.get(key, []), key=lambda x: x['name'])
            self.assertListEqual(original_items, reconstructed_items, f"{key} state mismatch after sorting")
        
        original_computations = sorted(original_state.get("computations", []), key=lambda x: x['expression'])
        reconstructed_computations = sorted(reconstructed_state.get("computations", []), key=lambda x: x['expression'])
        self.assertListEqual(original_computations, reconstructed_computations, "Computations state mismatch after sorting")

    # Point tests
    def test_create_point_existing(self):
        p1 = self.canvas.create_point(10, 10)
        p2 = self.canvas.create_point(10, 10)
        self.assertEqual(p2, p1)

    def test_create_point_new_unnamed(self):
        p1 = self.canvas.create_point(10, 10)
        p2 = self.canvas.create_point(30, 30)
        self.assertIsNotNone(p1)
        self.assertIsNotNone(p2)
        self.assertEqual(p1.name, 'A')
        self.assertEqual(p2.name, 'B')
        self.assertIn(p1, self.canvas.drawable_manager.drawables._drawables['Point'])
        self.assertIn(p2, self.canvas.drawable_manager.drawables._drawables['Point'])

    def test_create_point_new_named(self):
        point = self.canvas.create_point(30, 30, 'C')
        self.assertIsNotNone(point)
        self.assertEqual(point.name, 'C')
        self.assertIn(point, self.canvas.drawable_manager.drawables._drawables['Point'])

    def test_get_point(self):
        point_created = self.canvas.create_point(10, 10)
        point_retrieved = self.canvas.get_point(10, 10)
        self.assertEqual(point_created, point_retrieved)
        point = self.canvas.get_point(5, 5)
        self.assertIsNone(point)

    def test_get_point_by_name(self):
        point_created = self.canvas.create_point(10, 10)
        point_retrieved = self.canvas.get_point_by_name('A')
        self.assertEqual(point_created, point_retrieved)
        point = self.canvas.get_point_by_name('Z')
        self.assertIsNone(point)

    def test_delete_point(self):
        p1 = self.canvas.create_point(10, 10)
        self.canvas.delete_point(10, 10)
        self.assertNotIn(p1, self.canvas.get_drawables_by_class_name(p1.get_class_name()))

    def test_delete_point_by_name(self):
        p1 = self.canvas.create_point(10, 10)
        self.canvas.delete_point_by_name('A')
        self.assertNotIn(p1, self.canvas.get_drawables_by_class_name(p1.get_class_name()))

    def test_delete_point_by_nonexistent_name(self):
        """Test deleting a point with a non-existent name returns False and doesn't cause errors."""
        # Test deleting a point that doesn't exist
        result = self.canvas.delete_point_by_name('NonexistentPoint')
        self.assertFalse(result, "delete_point_by_name should return False for non-existent names")
        
        # Create a point and verify normal deletion still works
        p1 = self.canvas.create_point(10, 10, name="A")
        self.assertIsNotNone(self.canvas.get_point_by_name("A"))
        
        # Verify the non-existent deletion didn't affect existing points
        self.assertIn(p1, self.canvas.get_drawables_by_class_name('Point'))
        
        # Delete the point and verify it was removed
        self.assertTrue(self.canvas.delete_point_by_name("A"))
        self.assertIsNone(self.canvas.get_point_by_name("A"))

    def test_is_point_within_canvas_visible_area(self):
        self.assertTrue(self.canvas.is_point_within_canvas_visible_area(250, 250))
        self.assertFalse(self.canvas.is_point_within_canvas_visible_area(-1, 501))

    # Segment tests
    def test_create_segment_existing(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        s2 = self.canvas.create_segment(10, 10, 20, 20)
        self.assertEqual(s2, s1)

    def test_create_segment_new(self):
        s = self.canvas.create_segment(100, 100, 300, 300)
        self.assertIsNotNone(s)
        self.assertIn(s, self.canvas.get_drawables_by_class_name(s.get_class_name()))
        self.assertEqual(s.point1.x, 100)
        self.assertEqual(s.point1.y, -100)
        self.assertEqual(s.point2.x, 300)
        self.assertEqual(s.point2.y, -300)

    def test_get_segment_by_coordinates(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        s = self.canvas.get_segment_by_coordinates(10, 10, 20, 20)
        self.assertEqual(s, s1)
        s = self.canvas.get_segment_by_coordinates(5, 5, 15, 15)
        self.assertIsNone(s)

    def test_get_segment_by_points(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        self.assertIsNotNone(s1)
        p1 = self.canvas.get_point(10, 10)
        self.assertIsNotNone(p1)
        p2 = self.canvas.get_point(20, 20)
        self.assertIsNotNone(p2)
        s2 = self.canvas.get_segment_by_points(p1, p2)
        self.assertIsNotNone(s2)
        self.assertEqual(s2, s1)

    def test_delete_segment(self):
        s = self.canvas.create_segment(10, 10, 20, 20)
        self.canvas.delete_segment(10, 10, 20, 20)
        self.assertNotIn(s, self.canvas.get_drawables_by_class_name(s.get_class_name()))
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)

    def test_delete_segment_by_name(self):
        # Create a segment and get its name
        segment = self.canvas.create_segment(10, 10, 20, 20)
        segment_name = segment.name
        
        # Delete the segment by name
        self.canvas.delete_segment_by_name(segment_name)
        
        # Verify segment was deleted
        self.assertNotIn(segment, self.canvas.get_drawables_by_class_name(segment.get_class_name()))
        
        # Verify points still exist
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)

    def test_delete_segment_by_nonexistent_name(self):
        """Test deleting a segment with a non-existent name returns False and doesn't cause errors."""
        # Test deleting a segment that doesn't exist
        result = self.canvas.delete_segment_by_name('NonexistentSegment')
        self.assertFalse(result, "delete_segment_by_name should return False for non-existent names")
        
        # Create a segment and verify normal deletion still works
        segment = self.canvas.create_segment(10, 10, 20, 20)
        self.assertIsNotNone(self.canvas.get_segment_by_name(segment.name))
        
        # Verify the non-existent deletion didn't affect existing segments
        self.assertIn(segment, self.canvas.get_drawables_by_class_name('Segment'))
        
        # Delete the segment and verify it was removed
        self.assertTrue(self.canvas.delete_segment_by_name(segment.name))
        self.assertIsNone(self.canvas.get_segment_by_name(segment.name))

    def test_any_segment_part_visible_in_canvas_area(self):
        center = self.canvas.center
        width = self.canvas.width
        height = self.canvas.height
        visible = self.canvas.any_segment_part_visible_in_canvas_area(0, 0, width, height)
        self.assertTrue(visible)
        visible = self.canvas.any_segment_part_visible_in_canvas_area(center.x, height + 100, width + 100, center.y)
        self.assertTrue(visible)
        not_visible = self.canvas.any_segment_part_visible_in_canvas_area(width + 10, height + 10, height + 100, width + 100)
        self.assertFalse(not_visible)

    def test_delete_segments_depending_on_point(self):
        segment = self.canvas.create_segment(10, 10, 30, 30)
        self.assertIsNotNone(segment)
        self.assertIn(segment, self.canvas.get_drawables_by_class_name(segment.get_class_name()))
        self.canvas.drawable_manager.point_manager._delete_point_dependencies(10, 10)
        self.assertNotIn(segment, self.canvas.get_drawables_by_class_name(segment.get_class_name()))

    def test_remove_segment_from_parents(self):
        segment = self.canvas.create_segment(10, 20, 30, 20)
        point = self.canvas.create_point(20, 20)
        dm = self.canvas.drawable_manager.dependency_manager
        children = dm.get_children(segment)
        self.assertEquals(len(children), 2, "Segment should have 2 children.")
        child = list(children)[0]
        dm.remove_drawable(child)
        children_after = dm.get_children(segment)
        self.assertEquals(len(children_after), 1, "Segment should have 1 child.")

    def test_delete_segment_children(self):
        ad = self.canvas.create_segment(0, 0, 30, 0)
        self.canvas.create_point(10, 0)
        self.canvas.create_point(20, 0)
        self.assertEquals(len(self.canvas.drawable_manager.dependency_manager.get_children(ad)), 5, "Parent segment should have 5 children.")
        # Execute: Delete AD segment's children
        self.canvas.drawable_manager.segment_manager._delete_segment_dependencies(0, 0, 30, 0, delete_children=True, delete_parents=False)
        # Verify: All contained child segments should be deleted
        self.assertEquals(len(self.canvas.drawable_manager.dependency_manager.get_children(ad)), 0, "Parent segment should have no children.")
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 1, "There should be one segment left.")

    def test_delete_segment_parents(self):
        s = self.canvas.create_segment(50, 0, 60, 0) # distinct segment
        self.canvas.create_segment(0, 0, 30, 0)  # root segment
        self.canvas.create_point(10, 0)
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 4, "There should be 4 segments in total.")
        self.canvas.create_point(20, 0)
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 7, "There should be 7 segments in total.")
        # Delete segment's parents
        self.canvas.drawable_manager.segment_manager._delete_segment_dependencies(0, 0, 10, 0, delete_children=False, delete_parents=True)
        # Verify: Segment parents should be deleted
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 1, "There should be one segment left - deleting the parent also deletes its children.")
        self.assertIn(s, self.canvas.get_drawables_by_class_name('Segment'), "Distinct segment should not be deleted.")

    def test_are_points_connected(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        s2 = self.canvas.create_segment(20, 20, 30, 30)
        p1 = self.canvas.get_point(10, 10)
        p2 = self.canvas.get_point(20, 20)
        p3 = self.canvas.get_point(30, 30)
        points = [p1.name, p2.name, p3.name]
        # Check if the points are not connected
        are_not_connected = GeometryUtils.is_fully_connected_graph(points, self.canvas.drawable_manager.drawables.Segments)
        self.assertFalse(are_not_connected, "All points should not be connected.")
        # Create a segment connecting the points
        s3 = self.canvas.create_segment(30, 30, 10, 10)
        # Check again if the points are fully connected
        are_connected = GeometryUtils.is_fully_connected_graph(points, self.canvas.drawable_manager.drawables.Segments)
        self.assertTrue(are_connected, "The points should be fully connected.")

    # Vector tests
    def test_create_vector_existing(self):
        v1 = self.canvas.create_vector(10, 10, 20, 20)
        v2 = self.canvas.create_vector(10, 10, 20, 20)
        self.assertEqual(v2, v1)

    def test_create_vector_new(self):
        vector = self.canvas.create_vector(100, 100, 300, 300)
        p1 = vector.segment.point1
        p2 = vector.segment.point2
        self.assertIsNotNone(vector)
        self.assertIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))
        self.assertEqual(p1.x, 100)
        self.assertEqual(p1.y, -100)
        self.assertEqual(p2.x, 300)
        self.assertEqual(p2.y, -300)

    def test_get_vector(self):
        p1 = self.mock_point1
        p2 = self.mock_point2
        created_vector = self.canvas.create_vector(p1.x, p1.y, p2.x, p2.y)
        retrieved_vector = self.canvas.get_vector(p1.x, p1.y, p2.x, p2.y)
        self.assertEqual(created_vector, retrieved_vector)
        # Test retrieving a non-existent vector by coordinates
        vector = self.canvas.get_vector(100, 100, 200, 200)
        self.assertIsNone(vector, "Retrieved a vector when expected none.")

    def test_delete_vector(self):
        vector = self.canvas.create_vector(10, 10, 20, 20)
        self.canvas.delete_vector(10, 10, 20, 20)
        self.assertNotIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))
        # Check points are still present after deleting the vector
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)

    def test_delete_vector_by_nonexistent_coordinates(self):
        """Test deleting a vector with non-existent coordinates returns False and doesn't cause errors."""
        # Test deleting a vector that doesn't exist
        result = self.canvas.delete_vector(100, 100, 200, 200)
        self.assertFalse(result, "delete_vector should return False for non-existent coordinates")
        
        # Create a vector and verify normal deletion still works
        vector = self.canvas.create_vector(10, 10, 20, 20)
        self.assertIsNotNone(self.canvas.get_vector(10, 10, 20, 20))
        
        # Verify the non-existent deletion didn't affect existing vectors
        self.assertIn(vector, self.canvas.get_drawables_by_class_name('Vector'))
        
        # Delete the vector and verify it was removed
        self.assertTrue(self.canvas.delete_vector(10, 10, 20, 20))
        self.assertIsNone(self.canvas.get_vector(10, 10, 20, 20))

    def test_delete_vectors_depending_on_point(self):
        vector = self.canvas.create_vector(10, 10, 20, 20)
        self.assertIsNotNone(vector)
        self.assertIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))
        self.canvas.drawable_manager.point_manager._delete_point_dependencies(10, 10)
        self.assertNotIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))

    # Triangle tests
    def test_create_triangle_existing(self):
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        retrieved_triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.assertEqual(triangle, retrieved_triangle)

    def test_create_triangle_new(self):
        new_triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.assertIsNotNone(new_triangle)
        self.assertIn(new_triangle, self.canvas.get_drawables_by_class_name('Triangle'))

    def test_get_triangle(self):
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        retrieved_triangle = self.canvas.get_triangle(10, 10, 20, 20, 30, 30)
        self.assertEqual(triangle, retrieved_triangle)
        # Test retrieving a non-existent triangle
        non_existent_triangle = self.canvas.get_triangle(100, 100, 200, 200, 300, 300)
        self.assertIsNone(non_existent_triangle)

    def test_delete_triangle(self):
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.canvas.delete_triangle(10, 10, 20, 20, 30, 30)
        self.assertNotIn(triangle, self.canvas.get_drawables_by_class_name(triangle.get_class_name()))
        # Verifying segments and points still exist after deleting the triangle
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertTrue(all(p in points for p in [self.canvas.get_point(10, 10), self.canvas.get_point(20, 20), self.canvas.get_point(30, 30)]))

    def test_delete_triangle_by_nonexistent_coordinates(self):
        """Test deleting a triangle with non-existent coordinates returns False and doesn't cause errors."""
        # Test deleting a triangle that doesn't exist
        result = self.canvas.delete_triangle(100, 100, 200, 200, 300, 300)
        self.assertFalse(result, "delete_triangle should return False for non-existent coordinates")
        
        # Create a triangle and verify normal deletion still works
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.assertIsNotNone(self.canvas.get_triangle(10, 10, 20, 20, 30, 30))
        
        # Verify the non-existent deletion didn't affect existing triangles
        self.assertIn(triangle, self.canvas.get_drawables_by_class_name('Triangle'))
        
        # Delete the triangle and verify it was removed
        self.assertTrue(self.canvas.delete_triangle(10, 10, 20, 20, 30, 30))
        self.assertIsNone(self.canvas.get_triangle(10, 10, 20, 20, 30, 30))

    def test_create_triangle_from_connected_segments(self):
        # Setup: Create segments that form a triangle
        self.canvas.create_segment(10, 10, 20, 20, name="AB", extra_graphics=False)
        self.canvas.create_segment(20, 20, 10, 30, name="BC", extra_graphics=False)
        self.canvas.create_segment(10, 30, 10, 10, name="CA", extra_graphics=False)
        # Verify initial conditions
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Segment")), 3, "Canvas should initially have 3 segments.")
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Triangle")), 0, "Canvas should initially have no triangles.")
        # Execute: Attempt to create new triangles from connected segments
        self.canvas.drawable_manager.triangle_manager.create_new_triangles_from_connected_segments()
        # Verify: A triangle should be created from the three segments
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Triangle")), 1, "Canvas should have 1 triangle after operation.")

    def test_no_triangle_from_unconnected_segments(self):
        # Setup: Create segments that do not form a triangle
        self.canvas.create_segment(10, 10, 20, 20)
        self.canvas.create_segment(20, 20, 30, 20)
        self.canvas.create_segment(40, 40, 50, 50)
        # Execute: Attempt to create new triangles from unconnected segments
        self.canvas.drawable_manager.triangle_manager.create_new_triangles_from_connected_segments()
        # Verify: No triangle should be created as the segments are not connected
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Triangle")), 0, "Canvas should have no triangles as segments are unconnected.")

    # Rectangle tests
    def test_create_rectangle_new(self):
        # Directly test creating a new rectangle without previous setup
        new_rectangle = self.canvas.create_rectangle(10, 10, 40, 40)
        self.assertIsNotNone(new_rectangle, "Failed to create a new rectangle.")
        self.assertIn(new_rectangle, self.canvas.get_drawables_by_class_name('Rectangle'), "New rectangle should be in canvas.")

    def test_get_rectangle_by_diagonal_points(self):
        # Create a rectangle for this test
        rectangle_created = self.canvas.create_rectangle(10, 10, 30, 30)
        # Test retrieving an existing rectangle
        rectangle_retrieved = self.canvas.get_rectangle_by_diagonal_points(10, 10, 30, 30)
        self.assertIsNotNone(rectangle_retrieved, "Rectangle should exist.")
        self.assertEqual(rectangle_created, rectangle_retrieved, "Retrieved rectangle should be the same as the created one.")
        # Test retrieving a non-existent rectangle
        non_existent_rectangle = self.canvas.get_rectangle_by_diagonal_points(100, 100, 200, 200)
        self.assertIsNone(non_existent_rectangle, "Should not retrieve a non-existent rectangle.")

    def test_get_rectangle_by_name(self):
        # Create a rectangle for this test
        rectangle_created = self.canvas.create_rectangle(10, 10, 20, 20)
        # Test retrieving an existing rectangle by name
        rectangle_retrieved = self.canvas.get_rectangle_by_name(rectangle_created.name)
        self.assertIsNotNone(rectangle_retrieved, "Rectangle should exist.")
        self.assertEqual(rectangle_created, rectangle_retrieved, "Retrieved rectangle should be the same as the created one.")
        # Test retrieving a non-existent rectangle by name
        non_existent_rectangle = self.canvas.get_rectangle_by_name("NonExistent")
        self.assertIsNone(non_existent_rectangle, "Should not retrieve a non-existent rectangle by name.")

    def test_create_rectangle_existing(self):
        # Create a rectangle to test reusing existing rectangles
        created_rectangle = self.canvas.create_rectangle(10, 10, 30, 30)
        # Test creating a rectangle with the same coordinates
        retrieved_rectangle = self.canvas.create_rectangle(10, 10, 30, 30)
        self.assertEqual(created_rectangle, retrieved_rectangle, "Should reuse the existing rectangle.")

    def test_delete_rectangle(self):
        # Create a rectangle to test deletion
        rectangle = self.canvas.create_rectangle(10, 10, 30, 30, name="ABCD")
        # Test deleting the rectangle
        self.canvas.delete_rectangle(rectangle.name)
        self.assertIsNone(self.canvas.get_rectangle_by_diagonal_points(10, 10, 30, 30), "Rectangle should be deleted.")
        self.assertIsNone(self.canvas.get_rectangle_by_name("ABCD"), "Rectangle should be deleted.")

    def test_delete_rectangle_by_nonexistent_name(self):
        """Test deleting a rectangle with a non-existent name returns False and doesn't cause errors."""
        # Test deleting a rectangle that doesn't exist
        result = self.canvas.delete_rectangle('NonexistentRectangle')
        self.assertFalse(result, "delete_rectangle should return False for non-existent names")
        
        # Create a rectangle and verify normal deletion still works
        rectangle = self.canvas.create_rectangle(10, 10, 30, 30)
        self.assertIsNotNone(self.canvas.get_rectangle_by_name(rectangle.name))
        
        # Verify the non-existent deletion didn't affect existing rectangles
        self.assertIn(rectangle, self.canvas.get_drawables_by_class_name('Rectangle'))
        
        # Delete the rectangle and verify it was removed
        self.assertTrue(self.canvas.delete_rectangle(rectangle.name))
        self.assertIsNone(self.canvas.get_rectangle_by_name(rectangle.name))

    def test_delete_rectangles_depending_on_point(self):
        rectangle = self.canvas.create_rectangle(10, 10, 30, 30)
        self.assertIsNotNone(rectangle)
        self.assertIn(rectangle, self.canvas.get_drawables_by_class_name(rectangle.get_class_name()))
        self.canvas.drawable_manager.point_manager._delete_point_dependencies(10, 10)
        self.assertNotIn(rectangle, self.canvas.get_drawables_by_class_name(rectangle.get_class_name()))

    # Circle tests
    def test_create_circle_new(self):
        center_x, center_y, radius = 100, 100, 50
        # Directly test creating a new circle
        new_circle = self.canvas.create_circle(center_x, center_y, radius)
        self.assertIsNotNone(new_circle, "Failed to create a new circle.")
        self.assertIn(new_circle, self.canvas.get_drawables_by_class_name('Circle'), "New circle should be in canvas.")

    def test_get_circle(self):
        center_x, center_y, radius = 150, 150, 30
        # Create a circle for this test
        self.canvas.create_circle(center_x, center_y, radius)
        # Test retrieving an existing circle
        circle = self.canvas.get_circle(center_x, center_y, radius)
        self.assertIsNotNone(circle, "Circle should exist.")
        # Test retrieving a non-existent circle
        non_existent_circle = self.canvas.get_circle(200, 200, 30)
        self.assertIsNone(non_existent_circle, "Should not retrieve a non-existent circle.")

    def test_get_circle_by_name(self):
        center_x, center_y, radius = 120, 120, 25
        # Create a circle for this test
        self.canvas.create_circle(center_x, center_y, radius)
        # Test retrieving an existing circle by name
        circle = self.canvas.get_circle_by_name("A(25)")
        self.assertIsNotNone(circle, "Circle should exist.")
        # Test retrieving a non-existent circle by name
        non_existent_circle = self.canvas.get_circle_by_name("NonExistent")
        self.assertIsNone(non_existent_circle, "Should not retrieve a non-existent circle by name.")

    def test_create_circle_existing(self):
        center_x, center_y, radius = 130, 130, 40
        # Create a circle to test reusing existing circles
        created_circle = self.canvas.create_circle(center_x, center_y, radius)
        # Test creating a circle with the same parameters
        retrieved_circle = self.canvas.create_circle(center_x, center_y, radius)
        self.assertEqual(created_circle, retrieved_circle, "Should reuse the existing circle.")

    def test_delete_circle(self):
        center_x, center_y, radius = 140, 140, 35
        # Create a circle to test deletion
        circle = self.canvas.create_circle(center_x, center_y, radius)
        # Test deleting the circle
        self.canvas.delete_circle(circle.name)
        self.assertIsNone(self.canvas.get_circle(center_x, center_y, radius), "Circle should be deleted.")
        self.assertIsNone(self.canvas.get_circle_by_name('A(35)'), "Circle should be deleted.")

    def test_delete_circle_by_nonexistent_name(self):
        """Test deleting a circle with a non-existent name returns False and doesn't cause errors."""
        # Test deleting a circle that doesn't exist
        result = self.canvas.delete_circle('NonexistentCircle')
        self.assertFalse(result, "delete_circle should return False for non-existent names")
        
        # Create a circle and verify normal deletion still works
        circle = self.canvas.create_circle(10, 10, 25)
        self.assertIsNotNone(self.canvas.get_circle_by_name(circle.name))
        
        # Verify the non-existent deletion didn't affect existing circles
        self.assertIn(circle, self.canvas.get_drawables_by_class_name('Circle'))
        
        # Delete the circle and verify it was removed
        self.assertTrue(self.canvas.delete_circle(circle.name))
        self.assertIsNone(self.canvas.get_circle_by_name(circle.name))

    def test_delete_circles_depending_on_point(self):
        center_x, center_y, radius = 130, 130, 40
        circle = self.canvas.create_circle(center_x, center_y, radius)
        self.assertIsNotNone(circle)
        self.assertIn(circle, self.canvas.get_drawables_by_class_name(circle.get_class_name()))
        self.canvas.drawable_manager.point_manager._delete_point_dependencies(center_x, center_y) # Keep original args
        self.assertNotIn(circle, self.canvas.get_drawables_by_class_name(circle.get_class_name()))

    # Ellipse tests
    def test_create_ellipse_new(self):
        center_x, center_y, radius_x, radius_y = 100, 100, 50, 30
        # Directly test creating a new ellipse
        new_ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(new_ellipse, "Failed to create a new ellipse.")
        self.assertIn(new_ellipse, self.canvas.get_drawables_by_class_name(new_ellipse.get_class_name()), "New ellipse should be in canvas.")

    def test_create_ellipse_with_rotation(self):
        center_x, center_y = 100, 100
        radius_x, radius_y = 50, 30
        rotation_angle = 45
        
        new_ellipse = self.canvas.create_ellipse(
            center_x, center_y, radius_x, radius_y, 
            rotation_angle=rotation_angle
        )
        
        self.assertIsNotNone(new_ellipse, "Failed to create a new rotated ellipse.")
        self.assertEqual(new_ellipse.rotation_angle, rotation_angle, 
                        "Ellipse rotation angle does not match specified angle.")
        self.assertIn(new_ellipse, 
                     self.canvas.get_drawables_by_class_name(new_ellipse.get_class_name()),
                     "New rotated ellipse should be in canvas.")

    def test_create_ellipse_existing(self):
        center_x, center_y, radius_x, radius_y = 130, 130, 40, 25
        # Create an ellipse to test reusing existing ellipses
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(ellipse, "Ellipse should exist.")
        # Test creating an ellipse with the same parameters
        retrieved_ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(retrieved_ellipse, "Ellipse should exist.")
        self.assertEqual(ellipse, retrieved_ellipse, "Should reuse the existing ellipse.")

    def test_get_ellipse(self):
        center_x, center_y, radius_x, radius_y = 150, 150, 30, 20
        # Create an ellipse for this test
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        # Test retrieving an existing ellipse
        retrieved_ellipse = self.canvas.get_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(ellipse, "Ellipse should exist.")
        self.assertIsNotNone(retrieved_ellipse, "Ellipse should exist.")
        self.assertEqual(ellipse, retrieved_ellipse, "Retrieved ellipse should be the same as the created one.")
        # Test retrieving a non-existent ellipse
        non_existent_ellipse = self.canvas.get_ellipse(200, 200, 30, 20)
        self.assertIsNone(non_existent_ellipse, "Should not retrieve a non-existent ellipse.")

    def test_get_ellipse_by_name(self):
        center_x, center_y, radius_x, radius_y = 120, 120, 25, 15
        # Create an ellipse for this test
        self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        # Test retrieving an existing ellipse by name
        ellipse = self.canvas.get_ellipse_by_name("A(25, 15)")
        self.assertIsNotNone(ellipse, "Ellipse should exist.")
        # Test retrieving a non-existent ellipse by name
        non_existent_ellipse = self.canvas.get_ellipse_by_name("B(50, 100)")
        self.assertIsNone(non_existent_ellipse, "Should not retrieve a non-existent ellipse by name.")

    def test_delete_ellipse(self):
        center_x, center_y, radius_x, radius_y = 140, 140, 35, 20
        # Create an ellipse to test deletion
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        # Test deleting the ellipse
        self.canvas.delete_ellipse("A(35, 20)")
        self.assertIsNone(self.canvas.get_ellipse(center_x, center_y, radius_x, radius_y), "Ellipse should be deleted.")
        self.assertIsNone(self.canvas.get_ellipse_by_name(ellipse.name), "Ellipse should be deleted.")

    def test_delete_ellipse_by_nonexistent_name(self):
        """Test deleting an ellipse with a non-existent name returns False and doesn't cause errors."""
        # Test deleting an ellipse that doesn't exist
        result = self.canvas.delete_ellipse('NonexistentEllipse')
        self.assertFalse(result, "delete_ellipse should return False for non-existent names")
        
        # Create an ellipse and verify normal deletion still works
        ellipse = self.canvas.create_ellipse(10, 10, 25, 15)
        self.assertIsNotNone(self.canvas.get_ellipse_by_name(ellipse.name))
        
        # Verify the non-existent deletion didn't affect existing ellipses
        self.assertIn(ellipse, self.canvas.get_drawables_by_class_name('Ellipse'))
        
        # Delete the ellipse and verify it was removed
        self.assertTrue(self.canvas.delete_ellipse(ellipse.name))
        self.assertIsNone(self.canvas.get_ellipse_by_name(ellipse.name))

    def test_delete_ellipses_depending_on_point(self):
        center_x, center_y, radius_x, radius_y = 130, 130, 40, 20
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(ellipse)
        self.assertIn(ellipse, self.canvas.get_drawables_by_class_name(ellipse.get_class_name()))
        self.canvas.drawable_manager.point_manager._delete_point_dependencies(center_x, center_y)
        self.assertNotIn(ellipse, self.canvas.get_drawables_by_class_name(ellipse.get_class_name()))

    # Function tests
    def test_draw_function_new(self):
        function_string, name = "x^2", "Quadratic"
        left_bound, right_bound = -10, 10
        # Directly test drawing a new math function
        f = self.canvas.draw_function(function_string, name, left_bound, right_bound)
        self.assertIsNotNone(f, "Failed to draw a new math function.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "New function should be in canvas.")
        self.assertEqual(f.function_string, "x^2", "Function string should match.")
        self.assertEqual(f.left_bound, left_bound, "Left bound should match.")
        self.assertEqual(f.right_bound, right_bound, "Right bound should match.")
        self.assertEqual(f, f, "Retrieved function should be the same as the created one.")

    def test_draw_function_update(self):
        function_string, name = "x^2", "Quadratic"
        f = self.canvas.draw_function(function_string, name)
        # Update the function
        updated_function_string = "x^3"
        new_f = self.canvas.draw_function(updated_function_string, f.name, -5, 5)
        self.assertIsNotNone(new_f, "Math function should exist.")
        self.assertEqual(new_f.function_string, "x^3", "Function string should be updated.")
        self.assertEqual(new_f.left_bound, -5, "Left bound should be updated.")
        self.assertEqual(new_f.right_bound, 5, "Right bound should be updated.")

    def test_delete_math_function(self):
        function_string, name = "sin(x)", "SineWave"
        f = self.canvas.draw_function(function_string, name)
        # Ensure the function exists before deletion
        self.assertIsNotNone(f, "Math function should exist before deletion.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "Math function should exist before deletion.")
        # Test deleting the math function
        self.canvas.delete_function(f.name)
        deleted_function = self.canvas.get_function(f.name)
        self.assertIsNone(deleted_function, "Math function should be deleted.")

    def test_delete_function_by_nonexistent_name(self):
        """Test deleting a function with a non-existent name returns False and doesn't cause errors."""
        # Test deleting a function that doesn't exist
        result = self.canvas.delete_function('NonexistentFunction')
        self.assertFalse(result, "delete_function should return False for non-existent names")
        
        # Create a function and verify normal deletion still works
        func = self.canvas.draw_function("x^2", "f1")
        self.assertIsNotNone(self.canvas.get_function(func.name))
        
        # Verify the non-existent deletion didn't affect existing functions
        self.assertIn(func, self.canvas.get_drawables_by_class_name('Function'))
        
        # Delete the function and verify it was removed
        self.assertTrue(self.canvas.delete_function(func.name))
        self.assertIsNone(self.canvas.get_function(func.name))

    def test_draw_invalid_function_name_error(self):
        function_string, name = "invalid_function", "Invalid"
        with self.assertRaises(NameError, msg="Should raise a NameError for an invalid function string."):
            f = self.canvas.draw_function(function_string, name)
            f.function(10)

    def test_draw_invalid_function_value_error(self):
        function_string, name = "x = 1", "Invalid"
        with self.assertRaises(ValueError, msg="Should raise a ValueError for an invalid function string."):
            f = self.canvas.draw_function(function_string, name)
            f.function(10)

    def test_draw_valid_identity_function(self):
        function_string, name = "x", "Identity"
        f = self.canvas.draw_function(function_string, name)
        self.assertIsNotNone(f, "Math function should exist.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "Math function should exist.")
        self.assertEqual(f.function(10), 10, "Function should return the input value.")

    def test_draw_function_default_bounds(self):
        function_string, name = "x^2 - 2*x + 1", "Parabola"
        # Test drawing a function without specifying bounds
        f = self.canvas.draw_function(function_string, name)
        self.assertIsNotNone(f, "Math function should be drawn.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "Function should be in canvas.")
        self.assertIsNone(f.left_bound, "Left bound should be None for default bounds.")
        self.assertIsNone(f.right_bound, "Right bound should be None for default bounds.")

    # Other canvas tests
    def test_find_segment_children(self):
        s1 = self.canvas.create_segment(0, 0, 10, 0, name="", extra_graphics=False)
        s2 = self.canvas.create_segment(10, 0, 20, 0, name="", extra_graphics=False)
        s3 = self.canvas.create_segment(0, 0, 20, 0, name="", extra_graphics=False)
        s3_children = self.canvas.drawable_manager.dependency_manager._find_segment_children(s3)
        self.assertIn(s1, s3_children, "Segment s1 should be a child of s3.")
        self.assertIn(s2, s3_children, "Segment s2 should be a child of s3.")
        self.assertNotIn(s3, s3_children, "Segment s3 should not be a child of itself.")
        self.assertEquals(len(s3_children), 2, "Segment s3 should have 2 children.")
    
    def test_get_segment_parents(self):
        original_segment = self.canvas.create_segment(0, 0, 30, 0) # AB: A(0,0), B(30,0)
        point_c = self.canvas.create_point(10, 0) # C(10,0) on AB
        
        dm = self.canvas.drawable_manager.dependency_manager
        children = list(dm.get_children(original_segment))
        
        self.assertEqual(len(children), 2, "Original segment should have 2 children after split.")
        
        # Retrieve child segments by their expected coordinates for reliable checking
        child_ac = self.canvas.get_segment_by_coordinates(0, 0, 10, 0) # A(0,0) to C(10,0)
        child_cb = self.canvas.get_segment_by_coordinates(10, 0, 30, 0) # C(10,0) to B(30,0)

        self.assertIsNotNone(child_ac, "Child segment AC should exist.")
        self.assertIsNotNone(child_cb, "Child segment CB should exist.")

        parents_ac = dm.get_parents(child_ac)
        parents_cb = dm.get_parents(child_cb)

        # Verify parents of child_ac (A to C)
        self.assertEqual(len(parents_ac), 3, "Child AC should have 3 parents.")
        self.assertIn(original_segment, parents_ac, "AB should be a parent of AC.")
        self.assertIn(original_segment.point1, parents_ac, "Point A should be a parent of AC.")
        self.assertIn(point_c, parents_ac, "Point C should be a parent of AC.")

        # Verify parents of child_cb (C to B)
        self.assertEqual(len(parents_cb), 3, "Child CB should have 3 parents.")
        self.assertIn(original_segment, parents_cb, "AB should be a parent of CB.")
        self.assertIn(original_segment.point2, parents_cb, "Point B should be a parent of CB.")
        self.assertIn(point_c, parents_cb, "Point C should be a parent of CB.")

    def test_add_segment_to_parents(self):
        ab = self.canvas.create_segment(0, 0, 30, 0, name="AB", extra_graphics=True)
        cd = self.canvas.create_segment(40, 0, 60, 0, name="CD", extra_graphics=True)
        ef = self.canvas.create_segment(70, 0, 90, 0, name="EF", extra_graphics=True)
        dm = self.canvas.drawable_manager.dependency_manager
        dm.register_dependency(child=cd, parent=ab)
        dm.register_dependency(child=ef, parent=cd)
        ef_parents = dm.get_all_parents(ef)
        self.assertIn(ab, ef_parents, "Segment AB should be a transitive parent of EF.")
        self.assertIn(cd, ef_parents, "Segment CD should be a direct parent of EF.")

    def test_split_segment(self):
        segment = self.canvas.create_segment(0, 0, 30, 0)
        self.canvas.drawable_manager.segment_manager._split_segments_with_point(20, 0)
        self.assertEqual(len(self.canvas.drawable_manager.dependency_manager.get_children(segment)), 2, "Segment should have 2 children.")
        
        segments = self.canvas.get_drawables_by_class_name("Segment")
        points = self.canvas.get_drawables_by_class_name("Point")
        self.assertEqual(len(segments), 3, "Canvas should have 3 segments.")
        self.assertEqual(len(points), 3, "Canvas should have 3 points.")

    def test_split_segment_with_specific_coordinates(self):
        """Test splitting a segment with specific coordinates."""
        # Define segment endpoints and interpolation factor
        x1, y1 = -122.0, -69.0
        x2, y2 = 311.0, 154.0
        t = 0.51  # fraction along the segment (slightly past halfway)
        point_c_x = x1 * (1 - t) + x2 * t
        point_c_y = y1 * (1 - t) + y2 * t
        
        print(f"Placing point C at ({point_c_x}, {point_c_y}) which should be on segment AB")
        
        # Create a segment AB with the specific coordinates
        segment_ab = self.canvas.create_segment(x1, y1, x2, y2, name="AB", extra_graphics=False)
        
        # Verify segment creation
        self.assertIsNotNone(segment_ab, "Segment AB should be created")
        self.assertEqual(segment_ab.point1.original_position.x, -122.0)
        self.assertEqual(segment_ab.point1.original_position.y, -69.0)
        self.assertEqual(segment_ab.point2.original_position.x, 311.0)
        self.assertEqual(segment_ab.point2.original_position.y, 154.0)
        
        # Split the segment by adding the point we calculated
        self.canvas.drawable_manager.segment_manager._split_segments_with_point(point_c_x, point_c_y)
        
        # Verify that the original segment has two children
        self.assertEqual(len(self.canvas.drawable_manager.dependency_manager.get_children(segment_ab)), 2, "Segment AB should have 2 children after splitting")
        
        # Get the child segments (AC and CB)
        ac_segment = self.canvas.get_segment_by_coordinates(x1, y1, point_c_x, point_c_y)
        cb_segment = self.canvas.get_segment_by_coordinates(point_c_x, point_c_y, x2, y2)
        
        # Verify the child segments exist
        self.assertIsNotNone(ac_segment, "Segment AC should exist")
        self.assertIsNotNone(cb_segment, "Segment CB should exist")
        
        # Verify the child segments are in the parent's children
        children_ab = self.canvas.drawable_manager.dependency_manager.get_children(segment_ab)
        self.assertIn(ac_segment, children_ab, "Segment AC should be a child of AB")
        self.assertIn(cb_segment, children_ab, "Segment CB should be a child of AB")
        
        # Verify point C is on the line AB (to confirm proper splitting)
        # Using MathUtil to check that C is collinear with A and B
        from drawables.point import Position
        from utils.math_utils import MathUtils
        
        a_pos = segment_ab.point1.original_position
        b_pos = segment_ab.point2.original_position
        c_pos = Position(point_c_x, point_c_y)
        
        is_point_on_segment = MathUtils.is_point_on_segment(
            c_pos.x, c_pos.y, 
            a_pos.x, a_pos.y, 
            b_pos.x, b_pos.y
        )
        
        self.assertTrue(is_point_on_segment, "Point C should be on segment AB")
        
        # Verify the total number of segments
        all_segments = self.canvas.get_drawables_by_class_name("Segment")
        self.assertEqual(len(all_segments), 3, "There should be 3 segments total: AB, AC, and CB")
        
        # Verify the total number of points
        all_points = self.canvas.get_drawables_by_class_name("Point")
        self.assertEqual(len(all_points), 3, "There should be 3 points total: A, B, and C")

    def test_split_segment_comprehensive(self):
        """Test that _split_segments_with_point correctly handles all aspects of segment splitting."""
        # Create a parent segment AB
        ab = self.canvas.create_segment(0, 0, 40, 0, name="AB", extra_graphics=False)
        
        # Split the segment by adding point C at one-quarter of the segment
        self.canvas.drawable_manager.segment_manager._split_segments_with_point(10, 0)
        
        # Original segment AB should have two direct children after splitting
        self.assertEqual(len(self.canvas.drawable_manager.dependency_manager.get_children(ab)), 2, "Original segment AB should have 2 children after adding point C")
        
        # Get the child segments (AC and CB)
        segments = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(segments), 3, "Should have 3 segments total: AB (parent), AC, CB")
        
        # Find the child segments 
        ac_segment = self.canvas.get_segment_by_coordinates(0, 0, 10, 0)
        cb_segment = self.canvas.get_segment_by_coordinates(10, 0, 40, 0)
        
        self.assertIsNotNone(ac_segment, "Segment AC should exist")
        self.assertIsNotNone(cb_segment, "Segment CB should exist")
        
        # Verify parent-child relationships
        children_ab = self.canvas.drawable_manager.dependency_manager.get_children(ab)
        self.assertIn(ac_segment, children_ab, "Segment AC should be a child of AB")
        self.assertIn(cb_segment, children_ab, "Segment CB should be a child of AB")
        
        # Now split one of the child segments by adding point D
        self.canvas.drawable_manager.segment_manager._split_segments_with_point(25, 0)
        
        # Check if the segment CB was properly split into CD and DB
        cd_segment = self.canvas.get_segment_by_coordinates(10, 0, 25, 0)
        db_segment = self.canvas.get_segment_by_coordinates(25, 0, 40, 0)
        
        self.assertIsNotNone(cd_segment, "Segment CD should exist")
        self.assertIsNotNone(db_segment, "Segment DB should exist")
        
        # The original child segment CB should now have two children of its own
        self.assertEqual(len(self.canvas.drawable_manager.dependency_manager.get_children(cb_segment)), 2, "Segment CB should have 2 children (CD and DB)")
        
        # But the original parent AB should still have CD and DB as grandchildren
        # Check that AB is in the parent chain of both CD and DB
        dm = self.canvas.drawable_manager.dependency_manager
        cd_parents = dm.get_parents(cd_segment)
        db_parents = dm.get_parents(db_segment)
        
        self.assertTrue(any(p == cb_segment for p in cd_parents), "CB should be a parent of CD")
        self.assertTrue(any(p == cb_segment for p in db_parents), "CB should be a parent of DB")
        
        # Verify the total number of segments
        segments_after = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(segments_after), 6, "Should have 6 segments total after splitting twice: AB (parent), AC, CB (children), CD, DB (grandchildren), and AD (additional segment between existing points)")
        
        # Check that the additional segment AD exists
        ad_segment = self.canvas.get_segment_by_coordinates(0, 0, 25, 0)
        self.assertIsNotNone(ad_segment, "Segment AD should also exist as all possible segments between points are created")
        
        # Delete point C and verify consequences
        c_point = self.canvas.get_point(10, 0)
        self.canvas.delete_point(10, 0)
        
        # After deleting C, we should lose AC and CD, but AB, AD, and DB should still exist
        # AB's children should be updated
        segments_after_delete = self.canvas.get_drawables_by_class_name('Segment')
        
        # We should have 3 segments left: AB, AD, and DB
        self.assertEqual(len(segments_after_delete), 3, "Should have 3 segments left after deleting C: AB (parent), AD, and DB")
        
        # AB should still exist
        ab_after = self.canvas.get_segment_by_name("AB")
        self.assertIsNotNone(ab_after, "Segment AB should still exist after deleting C")
        
        # DB should still exist
        d_to_b = self.canvas.get_segment_by_coordinates(25, 0, 40, 0)
        self.assertIsNotNone(d_to_b, "Segment DB should still exist after deleting C")

    def test_segment_preservation_with_one_point(self):
        """Test segment preservation and child registration when one point is added to a segment."""
        # 1. Create parent segment AB
        ab = self.canvas.create_segment(0, 0, 100, 0, name="AB", extra_graphics=False)
        
        # 2. Add point C on AB
        c_point = self.canvas.create_point(25, 0, name="C", extra_graphics=True)
        
        # 3. Check total number of segments
        all_segments = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(all_segments), 3, "Should have 3 segments total: AB, AC, CB")
        
        # 4. Get child segments AC and CB
        ac_segment = self.canvas.get_segment_by_coordinates(0, 0, 25, 0)
        cb_segment = self.canvas.get_segment_by_coordinates(25, 0, 100, 0)
        
        self.assertIsNotNone(ac_segment, "Segment AC should exist")
        self.assertIsNotNone(cb_segment, "Segment CB should exist")
        
        # 5. Check children of AB
        children_ab = self.canvas.drawable_manager.dependency_manager.get_children(ab)
        self.assertEqual(len(children_ab), 2, "Original segment AB should have 2 children (AC and CB)")
        
        # Ensure children_ab contains the actual segment objects
        # If ac_segment or cb_segment are None, this will fail earlier, which is fine.
        self.assertIn(ac_segment, children_ab, "Segment AC should be a child of AB")
        self.assertIn(cb_segment, children_ab, "Segment CB should be a child of AB")

        # 6. Delete point C
        self.canvas.delete_point(25, 0) # Deleting point C by coordinates

        # 7. Verify AB still exists
        ab_after_delete = self.canvas.get_segment_by_name("AB")
        self.assertIsNotNone(ab_after_delete, "Segment AB should still exist after deleting point C")
        self.assertEqual(ab, ab_after_delete, "The retrieved AB segment should be the same object as the original")

        # 8. Verify segments AC and CB are gone
        ac_after_delete = self.canvas.get_segment_by_coordinates(0, 0, 25, 0)
        cb_after_delete = self.canvas.get_segment_by_coordinates(25, 0, 100, 0)
        self.assertIsNone(ac_after_delete, "Segment AC should be deleted after point C is deleted")
        self.assertIsNone(cb_after_delete, "Segment CB should be deleted after point C is deleted")

        # 9. Verify AB has no segment children
        children_ab_after_delete = self.canvas.drawable_manager.dependency_manager.get_children(ab_after_delete) # Use ab_after_delete to be safe
        self.assertEqual(len(children_ab_after_delete), 0, "Segment AB should have 0 segment children after point C is deleted")

        # 10. Verify points A and B still exist, but C is gone
        pointA_after_delete = self.canvas.get_point(0,0)
        pointB_after_delete = self.canvas.get_point(100,0)
        pointC_after_delete = self.canvas.get_point(25,0)
        self.assertIsNotNone(pointA_after_delete, "Point A should still exist")
        self.assertIsNotNone(pointB_after_delete, "Point B should still exist")
        self.assertIsNone(pointC_after_delete, "Point C should be deleted")
        
        # 11. Verify total number of segments is 1 (only AB)
        all_segments_after_delete = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(all_segments_after_delete), 1, "Should have 1 segment (AB) left after deleting point C")
        self.assertIn(ab_after_delete, all_segments_after_delete, "The remaining segment should be AB")

    def test_segment_preservation_with_multiple_points(self):
        """Test segment preservation and child registration when multiple points are added and then deleted."""
        # 1. Create parent segment AB
        ab = self.canvas.create_segment(0, 0, 100, 0, name="AB", extra_graphics=False)
        
        # 2. Add point C, then point D on AB
        c_point = self.canvas.create_point(25, 0, name="C", extra_graphics=True)
        d_point = self.canvas.create_point(50, 0, name="D", extra_graphics=True)

        # 3. Initial Checks (after adding C and D)
        # Points: A(0,0), C(25,0), D(50,0), B(100,0)
        all_segments_initial = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(all_segments_initial), 6, "Should have 6 segments total: AB, AC, AD, CD, CB, DB")

        ac_initial = self.canvas.get_segment_by_coordinates(0, 0, 25, 0)
        ad_initial = self.canvas.get_segment_by_coordinates(0, 0, 50, 0)
        cd_initial = self.canvas.get_segment_by_coordinates(25, 0, 50, 0)
        cb_initial = self.canvas.get_segment_by_coordinates(25, 0, 100, 0)
        db_initial = self.canvas.get_segment_by_coordinates(50, 0, 100, 0)

        self.assertIsNotNone(ac_initial, "Segment AC should exist initially")
        self.assertIsNotNone(ad_initial, "Segment AD should exist initially")
        self.assertIsNotNone(cd_initial, "Segment CD should exist initially")
        self.assertIsNotNone(cb_initial, "Segment CB should exist initially")
        self.assertIsNotNone(db_initial, "Segment DB should exist initially")

        children_ab_initial = self.canvas.drawable_manager.dependency_manager.get_children(ab)
        self.assertEqual(len(children_ab_initial), 5, "AB should have 5 children initially (AC, AD, CD, CB, DB)")
        for seg in [ac_initial, ad_initial, cd_initial, cb_initial, db_initial]:
            self.assertIn(seg, children_ab_initial, f"{seg.name if seg else 'A segment'} should be a child of AB initially")

        # 4. Delete point C
        self.canvas.delete_point(25, 0) # Deleting point C

        # 5. Checks after deleting C
        # Remaining points: A(0,0), D(50,0), B(100,0)
        all_segments_after_c_delete = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(all_segments_after_c_delete), 3, "Should have 3 segments after deleting C (AB, AD, DB)")

        ab_after_c = self.canvas.get_segment_by_name("AB")
        ad_after_c = self.canvas.get_segment_by_coordinates(0, 0, 50, 0)
        db_after_c = self.canvas.get_segment_by_coordinates(50, 0, 100, 0)

        self.assertIsNotNone(ab_after_c, "AB should still exist after C deletion")
        self.assertIsNotNone(ad_after_c, "AD should still exist after C deletion")
        self.assertIsNotNone(db_after_c, "DB should still exist after C deletion")

        # Segments involving C should be gone
        self.assertIsNone(self.canvas.get_segment_by_coordinates(0, 0, 25, 0), "AC should be deleted")
        self.assertIsNone(self.canvas.get_segment_by_coordinates(25, 0, 50, 0), "CD should be deleted")
        self.assertIsNone(self.canvas.get_segment_by_coordinates(25, 0, 100, 0), "CB should be deleted")

        children_ab_after_c_delete = self.canvas.drawable_manager.dependency_manager.get_children(ab)
        self.assertEqual(len(children_ab_after_c_delete), 2, "AB should have 2 children after C deletion (AD, DB)")
        self.assertIn(ad_after_c, children_ab_after_c_delete, "AD should be a child of AB after C deletion")
        self.assertIn(db_after_c, children_ab_after_c_delete, "DB should be a child of AB after C deletion")

        # 6. Delete point D
        self.canvas.delete_point(50, 0) # Deleting point D

        # 7. Final Checks (after deleting C and D)
        # Remaining points: A(0,0), B(100,0)
        all_segments_final = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(all_segments_final), 1, "Should have 1 segment (AB) after C and D deletion")

        ab_final = self.canvas.get_segment_by_name("AB")
        self.assertIsNotNone(ab_final, "AB should still exist in the end")
        self.assertIn(ab_final, all_segments_final, "The final segment should be AB")

        # Segments involving D should be gone
        self.assertIsNone(self.canvas.get_segment_by_coordinates(0, 0, 50, 0), "AD should be deleted")
        self.assertIsNone(self.canvas.get_segment_by_coordinates(50, 0, 100, 0), "DB should be deleted")

        children_ab_final = self.canvas.drawable_manager.dependency_manager.get_children(ab)
        self.assertEqual(len(children_ab_final), 0, "AB should have 0 children in the end")

    def test_translate_point(self):
        # Test translating a point
        point = self.canvas.create_point(10, 10, "A")
        self.canvas.translate_object("A", 5, -5)
        
        # Check new position
        self.assertEqual(point.original_position.x, 15)
        self.assertEqual(point.original_position.y, 5)

    def test_translate_segment(self):
        # Test translating a segment
        segment = self.canvas.create_segment(0, 0, 10, 10)
        original_p1_x = segment.point1.original_position.x
        original_p1_y = segment.point1.original_position.y
        original_p2_x = segment.point2.original_position.x
        original_p2_y = segment.point2.original_position.y
        
        self.canvas.translate_object(segment.name, 5, 5)
        
        # Check both points were translated
        self.assertEqual(segment.point1.original_position.x, original_p1_x + 5)
        self.assertEqual(segment.point1.original_position.y, original_p1_y + 5)
        self.assertEqual(segment.point2.original_position.x, original_p2_x + 5)
        self.assertEqual(segment.point2.original_position.y, original_p2_y + 5)

    def test_translate_vector(self):
        # Test translating a vector
        vector = self.canvas.create_vector(0, 0, 10, 10, "V", True)
        
        original_p1_x = vector.segment.point1.original_position.x
        original_p1_y = vector.segment.point1.original_position.y
        original_p2_x = vector.segment.point2.original_position.x
        original_p2_y = vector.segment.point2.original_position.y
        
        self.canvas.translate_object(vector.name, 5, 5)
        
        # Check both points were translated
        self.assertEqual(vector.segment.point1.original_position.x, original_p1_x + 5)
        self.assertEqual(vector.segment.point1.original_position.y, original_p1_y + 5)
        self.assertEqual(vector.segment.point2.original_position.x, original_p2_x + 5)
        self.assertEqual(vector.segment.point2.original_position.y, original_p2_y + 5)

    def test_translate_circle(self):
        # Test translating a circle
        circle = self.canvas.create_circle(100, 100, 50)
        original_center_x = circle.center.original_position.x
        original_center_y = circle.center.original_position.y
        
        self.canvas.translate_object(circle.name, -10, 20)
        
        # Check center was translated
        self.assertEqual(circle.center.original_position.x, original_center_x - 10)
        self.assertEqual(circle.center.original_position.y, original_center_y + 20)

    def test_translate_nonexistent_object(self):
        # Test attempting to translate an object that doesn't exist
        with self.assertRaises(ValueError):
            self.canvas.translate_object("NonexistentObject", 10, 10)

    def test_translate_multiple_objects(self):
        # Test translating multiple objects and checking their relative positions
        p1 = self.canvas.create_point(0, 0, name="A")
        p2 = self.canvas.create_point(10, 10, name="B")
        segment = self.canvas.create_segment(0, 0, 10, 10, name="AB")

        # Store original distances
        original_dx = p2.original_position.x - p1.original_position.x
        original_dy = p2.original_position.y - p1.original_position.y
        
        # Translate each object
        self.canvas.translate_object("A", 5, 5)
        self.canvas.translate_object("B", 5, 5)
        self.canvas.translate_object(segment.name, 5, 5)
        
        # Check relative distances are maintained
        new_dx = p2.original_position.x - p1.original_position.x
        new_dy = p2.original_position.y - p1.original_position.y
        
        self.assertEqual(original_dx, new_dx)
        self.assertEqual(original_dy, new_dy)

    def test_translate_with_zero_offset(self):
        # Test translating with zero offset doesn't change position
        point = self.canvas.create_point(10, 10, "C")
        original_x = point.original_position.x
        original_y = point.original_position.y
        
        self.canvas.translate_object("C", 0, 0)
        
        self.assertEqual(point.original_position.x, original_x)
        self.assertEqual(point.original_position.y, original_y)

    def test_translate_undo_redo(self):
        # Test that translation can be undone and redone
        point = self.canvas.create_point(10, 10, "A")
        original_x = point.original_position.x
        original_y = point.original_position.y
        
        # Perform translation
        self.canvas.translate_object("A", 5, 5)
        point = self.canvas.get_point_by_name("A")  # Get fresh reference
        translated_x = point.original_position.x
        translated_y = point.original_position.y
        
        # Undo translation
        self.canvas.undo()
        point = self.canvas.get_point_by_name("A")  # Get fresh reference
        self.assertEqual(point.original_position.x, original_x)
        self.assertEqual(point.original_position.y, original_y)
        
        # Redo translation
        self.canvas.redo()
        point = self.canvas.get_point_by_name("A")  # Get fresh reference
        self.assertEqual(point.original_position.x, translated_x)
        self.assertEqual(point.original_position.y, translated_y)

    def test_translate_triangle(self):
        # Create a triangle with initial points
        triangle = self.canvas.create_triangle(0, 0, 10, 0, 5, 10)
        
        # Store original positions of all points
        original_points = [
            (triangle.segment1.point1.original_position.x, triangle.segment1.point1.original_position.y),
            (triangle.segment1.point2.original_position.x, triangle.segment1.point2.original_position.y),
            (triangle.segment2.point2.original_position.x, triangle.segment2.point2.original_position.y)
        ]
        
        # Translate triangle
        x_offset, y_offset = 5, 5
        self.canvas.translate_object(triangle.name, x_offset, y_offset)
        
        # Get points after translation
        translated_points = [
            (triangle.segment1.point1.original_position.x, triangle.segment1.point1.original_position.y),
            (triangle.segment1.point2.original_position.x, triangle.segment1.point2.original_position.y),
            (triangle.segment2.point2.original_position.x, triangle.segment2.point2.original_position.y)
        ]
        
        # Verify each point was translated correctly
        for i in range(3):
            self.assertEqual(translated_points[i][0], original_points[i][0] + x_offset,
                        f"Point {i+1} x-coordinate not translated correctly")
            self.assertEqual(translated_points[i][1], original_points[i][1] + y_offset,
                        f"Point {i+1} y-coordinate not translated correctly")

    def test_translate_function(self):
        def replace_x(func_str, x_offset):
            import re
            protected_funcs = sorted(ExpressionValidator.ALLOWED_FUNCTIONS, key=len, reverse=True)
            func_pattern = '|'.join(map(re.escape, protected_funcs))
            pattern = rf'\b(x)\b|({func_pattern})'
            
            def replace_match(match):
                if match.group(1):
                    return f'(x - {x_offset})'
                elif match.group(2):
                    return match.group(2)
                return match.group(0)
                
            return re.sub(pattern, replace_match, func_str)

        # Test basic function translations
        test_cases = [
            ("x + 1", 2, 3),           # Linear function with positive offset
            ("sin(x)", -1, 2),         # Trigonometric function with negative x offset
            ("x^2", -3, 0),            # Quadratic function with negative x offset
            ("1/x", -2, -1),           # Rational function with negative offsets
            ("sqrt(x)", 1, -1),        # Root function with negative y offset
            ("2*x + 3", -2, 2),        # Linear function with negative x offset
            ("exp(x)", -1, 0),         # Exponential function with negative x offset
            ("log(x)", -2, -3),        # Logarithmic function with negative offsets
        ]

        for func_str, x_offset, y_offset in test_cases:
            with self.subTest(func_str=func_str, x_offset=x_offset, y_offset=y_offset):
                # Create function and store original bounds
                f = self.canvas.draw_function(func_str, f"f_{func_str}", -10, 10)
                original_left = f.left_bound
                original_right = f.right_bound
                
                # Translate function
                self.canvas.translate_object(f.name, x_offset, y_offset)
                
                # Verify bounds were translated correctly for x_offset
                if x_offset != 0:
                    self.assertEqual(f.left_bound, original_left + x_offset, 
                        f"Left bound incorrect for {func_str} with x_offset {x_offset}")
                    self.assertEqual(f.right_bound, original_right + x_offset,
                        f"Right bound incorrect for {func_str} with x_offset {x_offset}")
                
                # Get expected function string after translation
                expected = func_str
                if x_offset != 0:
                    expected = replace_x(expected, x_offset)
                if y_offset != 0:
                    expected = f"({expected}) + {y_offset}"
                
                # Verify function string was updated correctly
                actual = f.function_string
                self.assertEqual(
                    actual, 
                    ExpressionValidator.fix_math_expression(expected),
                    f"Function string incorrect for {func_str} with offsets ({x_offset}, {y_offset})\n"
                    f"Expected: {ExpressionValidator.fix_math_expression(expected)}\n"
                    f"Actual: {actual}"
                )

                # Test function evaluation at sample points
                try:
                    test_points = [-5, 0, 5]  # Test multiple points
                    original_f = ExpressionValidator.parse_function_string(func_str)
                    
                    for x in test_points:
                        try:
                            # Ensure x is a valid input for the original function
                            if func_str.startswith('sqrt') and (x - x_offset) < 0:
                                continue  # Skip negative inputs for sqrt
                            if func_str.startswith('log') and (x - x_offset) <= 0:
                                continue  # Skip non-positive inputs for log
                            if '1/x' in func_str and (x - x_offset) == 0:
                                continue  # Skip zero for division
                            
                            # Calculate expected result
                            orig_result = float(original_f(x - x_offset))
                            expected_result = orig_result + y_offset
                            
                            # Calculate actual result
                            actual_result = float(f.function(x))
                            
                            self.assertAlmostEqual(
                                actual_result,
                                expected_result,
                                places=10,
                                msg=f"Failed for function {func_str} at x={x} with offsets ({x_offset}, {y_offset})\n"
                                    f"Expected: {expected_result}\n"
                                    f"Actual: {actual_result}"
                            )
                        except (ValueError, ZeroDivisionError):
                            # Skip points where function is undefined
                            continue
                        except Exception as e:
                            self.fail(f"Error evaluating {func_str} at x={x} with offsets ({x_offset}, {y_offset}): {str(e)}")
                except Exception as e:
                    self.fail(f"Error setting up function evaluation for {func_str}: {str(e)}")

        # Test zero translation has no effect
        f = self.canvas.draw_function("x^2", "f_zero", -10, 10)
        original_string = f.function_string
        original_left = f.left_bound
        original_right = f.right_bound
        self.canvas.translate_object(f.name, 0, 0)
        self.assertEqual(f.function_string, original_string)
        self.assertEqual(f.left_bound, original_left)
        self.assertEqual(f.right_bound, original_right)

        # Test translation with no bounds
        f = self.canvas.draw_function("x^2", "f_no_bounds")
        self.canvas.translate_object(f.name, 2, 3)
        self.assertIsNone(f.left_bound)
        self.assertIsNone(f.right_bound)

        # Test invalid function translation
        f = self.canvas.draw_function("1/0", "f_invalid")
        try:
            self.canvas.translate_object(f.name, 1, 1)
        except Exception as e:
            self.fail(f"Translation of invalid function should not raise an exception: {str(e)}")

    def test_segment_rotation(self):
        """Test segment rotation around its midpoint"""
        segment = self.canvas.create_segment(0, 0, 30, 0, name="AB")
        
        segment.rotate(90)  # Rotate 90 degrees around midpoint
        
        # Point 1 should be at (0, 0)
        self.assertAlmostEqual(segment.point1.original_position.x, 15, places=6)
        self.assertAlmostEqual(segment.point1.original_position.y, -15, places=6)

        # Point 2 should now be approximately at (0, 30)
        self.assertAlmostEqual(segment.point2.original_position.x, 15, places=6)
        self.assertAlmostEqual(segment.point2.original_position.y, 15, places=6)

    def test_segment_multiple_rotations(self):
        """Test multiple rotations on a segment"""
        segment = self.canvas.create_segment(0, 0, 30, 0, name="AB")
        initial_points = {
            (round(p.original_position.x, 6), round(p.original_position.y, 6))
            for p in [segment.point1, segment.point2]
        }
        
        # Full rotation should return to original position
        segment.rotate(360)
        final_points = {
            (round(p.original_position.x, 6), round(p.original_position.y, 6))
            for p in [segment.point1, segment.point2]
        }
        self.assertEqual(initial_points, final_points)

    def test_triangle_rotation(self):
        """Test triangle rotation around its center"""
        triangle = self.canvas.create_triangle(0, 0, 30, 0, 15, 30)
        initial_points = {
            (p.original_position.x, p.original_position.y) 
            for p in [triangle.segment1.point1, triangle.segment1.point2, triangle.segment2.point2]
        }
        
        triangle.rotate(120)
        
        rotated_points = {
            (p.original_position.x, p.original_position.y) 
            for p in [triangle.segment1.point1, triangle.segment1.point2, triangle.segment2.point2]
        }
        self.assertNotEqual(initial_points, rotated_points)

    def test_triangle_full_rotation(self):
        """Test that a full rotation returns to original position"""
        triangle = self.canvas.create_triangle(0, 0, 30, 0, 15, 30)
        initial_points = {
            (round(p.original_position.x, 6), round(p.original_position.y, 6))
            for p in [triangle.segment1.point1, triangle.segment1.point2, triangle.segment2.point2]
        }
        
        triangle.rotate(360)
        
        final_points = {
            (round(p.original_position.x, 6), round(p.original_position.y, 6))
            for p in [triangle.segment1.point1, triangle.segment1.point2, triangle.segment2.point2]
        }
        self.assertEqual(initial_points, final_points)

    def test_rectangle_rotation(self):
        """Test rectangle rotation around its center"""
        rectangle = self.canvas.create_rectangle(0, 0, 30, 20)
        initial_points = {
            (p.original_position.x, p.original_position.y) 
            for p in [rectangle.segment1.point1, rectangle.segment1.point2,
                    rectangle.segment2.point2, rectangle.segment3.point2]
        }
        
        rectangle.rotate(45)
        
        rotated_points = {
            (p.original_position.x, p.original_position.y) 
            for p in [rectangle.segment1.point1, rectangle.segment1.point2,
                    rectangle.segment2.point2, rectangle.segment3.point2]
        }
        self.assertNotEqual(initial_points, rotated_points)

    def test_rectangle_multiple_rotations(self):
        """Test multiple rotations on a rectangle"""
        rectangle = self.canvas.create_rectangle(0, 0, 30, 20)
        
        # Define points for easier reference
        p1 = rectangle.segment1.point1
        p2 = rectangle.segment1.point2
        p3 = rectangle.segment3.point1
        p4 = rectangle.segment3.point2
        
        # Store original positions
        original_points = [
            (p1.original_position.x, p1.original_position.y),
            (p2.original_position.x, p2.original_position.y),
            (p3.original_position.x, p3.original_position.y),
            (p4.original_position.x, p4.original_position.y)
        ]
        
        # Test cumulative rotations
        rectangle.rotate(45)
        # Store new positions after first rotation
        new_points_after_first_rotation = [
            (p1.original_position.x, p1.original_position.y),
            (p2.original_position.x, p2.original_position.y),
            (p3.original_position.x, p3.original_position.y),
            (p4.original_position.x, p4.original_position.y)
        ]
        
        rectangle.rotate(45)
        # Store new positions after second rotation
        new_points_after_second_rotation = [
            (p1.original_position.x, p1.original_position.y),
            (p2.original_position.x, p2.original_position.y),
            (p3.original_position.x, p3.original_position.y),
            (p4.original_position.x, p4.original_position.y)
        ]
        
        # Verify that the points have changed after rotations
        self.assertNotEqual(original_points, new_points_after_first_rotation)
        self.assertNotEqual(new_points_after_first_rotation, new_points_after_second_rotation)

    def test_ellipse_rotation(self):
        """Test ellipse rotation around its center"""
        ellipse = self.canvas.create_ellipse(100, 100, 50, 30, rotation_angle=0)
        
        ellipse.rotate(60)
        
        self.assertEqual(ellipse.rotation_angle, 60)
        self.assertEqual(ellipse.ellipse_formula, 
                        MathUtils.get_ellipse_formula(100, 100, 50, 30, 60))

    def test_ellipse_formula_after_rotation(self):
        """Test that ellipse formula updates correctly after rotation"""
        ellipse = self.canvas.create_ellipse(100, 100, 50, 30)
        initial_formula = ellipse.ellipse_formula
        
        ellipse.rotate(45)
        
        self.assertNotEqual(ellipse.ellipse_formula, initial_formula)
        self.assertEqual(ellipse.ellipse_formula,
                        MathUtils.get_ellipse_formula(100, 100, 50, 30, 45))
        
    def test_non_rotatable_objects(self):
        """Test that appropriate objects cannot be rotated"""
        # Test point (should do nothing)
        point = self.canvas.create_point(0, 0)
        point.rotate(45)  # Should not raise an exception or change state
        
        # Test circle (should do nothing)
        circle = self.canvas.create_circle(100, 100, 50)
        circle.rotate(45)  # Should not raise an exception or change state
            
        # Test function (should do nothing)
        function = self.canvas.draw_function("x^2", "f")
        function.rotate(45)  # Should not raise an exception or change state

    def test_undo_redo_rotation(self):
        """Test undo/redo functionality for rotation operations"""
        # Create an ellipse and store initial state
        initial_angle = 10
        rotation_angle = 45
        ellipse = self.canvas.create_ellipse(100, 100, 50, 30, initial_angle)
        initial_formula = ellipse.ellipse_formula
        
        # Rotate the ellipse
        self.canvas.rotate_object(ellipse.name, rotation_angle)
        
        # Verify rotation occurred
        self.assertEqual(ellipse.rotation_angle, initial_angle + rotation_angle)
        self.assertNotEqual(ellipse.ellipse_formula, initial_formula)
        
        # Undo rotation
        self.canvas.undo()
        
        # Verify state is restored
        ellipse = self.canvas.get_ellipse(100, 100, 50, 30)
        self.assertEqual(ellipse.rotation_angle, initial_angle)
        self.assertEqual(ellipse.ellipse_formula, initial_formula)
        
        # Redo rotation
        self.canvas.redo()
        ellipse = self.canvas.get_ellipse(100, 100, 50, 30)
        self.assertEqual(ellipse.rotation_angle, initial_angle + rotation_angle)

    def test_computations(self):
        # Test adding computations
        self.canvas.add_computation(
            expression="|sqrt((100-0)^2 + (0-0)^2)| + |sqrt((50-100)^2 + (86-0)^2)| + |sqrt((0-50)^2 + (0-86)^2)|",
            result=300
        )
        
        # Test computation appears in canvas state
        state = self.canvas.get_canvas_state()
        self.assertIn('computations', state)
        self.assertEqual(len(state['computations']), 1)
        self.assertEqual(state['computations'][0]['expression'], "|sqrt((100-0)^2 + (0-0)^2)| + |sqrt((50-100)^2 + (86-0)^2)| + |sqrt((0-50)^2 + (0-86)^2)|")
        self.assertEqual(state['computations'][0]['result'], 300)
        
        # Test duplicate prevention - try to add the same computation again
        self.canvas.add_computation(
            expression="|sqrt((100-0)^2 + (0-0)^2)| + |sqrt((50-100)^2 + (86-0)^2)| + |sqrt((0-50)^2 + (0-86)^2)|",
            result=300
        )
        # Verify the duplicate was not added
        self.assertEqual(len(self.canvas.computations), 1)
        
        # Add a different computation
        self.canvas.add_computation(
            expression="300/(2*pi)",
            result=47.75
        )
        
        # Verify both unique computations exist
        self.assertEqual(len(self.canvas.computations), 2)
        
        # Test that undo/redo operations don't affect computations
        point = self.canvas.create_point(0, 0, "A")  # Create a drawable to undo
        self.canvas.undo()  # Undo the point creation
        
        # Verify computations are preserved after undo
        self.assertEqual(len(self.canvas.computations), 2)
        self.assertEqual(self.canvas.computations[0]['expression'], "|sqrt((100-0)^2 + (0-0)^2)| + |sqrt((50-100)^2 + (86-0)^2)| + |sqrt((0-50)^2 + (0-86)^2)|")
        self.assertEqual(self.canvas.computations[1]['expression'], "300/(2*pi)")
        
        # Test redo also preserves computations
        self.canvas.redo()  # Redo the point creation
        self.assertEqual(len(self.canvas.computations), 2)
        self.assertEqual(self.canvas.computations[0]['expression'], "|sqrt((100-0)^2 + (0-0)^2)| + |sqrt((50-100)^2 + (86-0)^2)| + |sqrt((0-50)^2 + (0-86)^2)|")
        self.assertEqual(self.canvas.computations[1]['expression'], "300/(2*pi)")

    def test_delete_point_on_segment_preserves_parents(self):
        """Test that deleting a point on a segment preserves parent segments."""
        # Create a parent segment AB
        ab = self.canvas.create_segment(0, 0, 30, 0, name="AB", extra_graphics=False)
        
        # Create a point D on AB
        d = self.canvas.create_point(10, 0, name="D", extra_graphics=True)
        
        # Create a point E on AB
        e = self.canvas.create_point(20, 0, name="E", extra_graphics=True)
        
        # At this point we should have segments: AB, AD, DB, AE, EB
        segments = self.canvas.get_drawables_by_class_name('Segment')
        self.assertEqual(len(segments), 6, "Should have 6 segments: AB, AD, DB, AE, EB, DE")
        
        # Get the segment AB to check later
        ab_after_points = self.canvas.get_segment_by_name("AB")
        self.assertIsNotNone(ab_after_points, "Segment AB should exist")
        
        # Delete point D
        self.canvas.delete_point_by_name("D")
        
        # After deletion, AB should still exist
        segments_after_deletion = self.canvas.get_drawables_by_class_name('Segment')
        self.assertIn(ab_after_points, segments_after_deletion, "Segment AB should still exist after deleting point D")
        
        # Segments AD, DB, DE should be deleted
        ad = self.canvas.get_segment_by_coordinates(0, 0, 10, 0)
        db = self.canvas.get_segment_by_coordinates(10, 0, 30, 0)
        
        self.assertIsNone(ad, "Segment AD should be deleted")
        self.assertIsNone(db, "Segment DB should be deleted")
        
        # Segments AE and EB should still exist
        ae = self.canvas.get_segment_by_coordinates(0, 0, 20, 0)
        eb = self.canvas.get_segment_by_coordinates(20, 0, 30, 0)
        
        self.assertIsNotNone(ae, "Segment AE should still exist")
        self.assertIsNotNone(eb, "Segment EB should still exist")

    def test_delete_point_on_triangle_segment_preserves_parents(self):
        """Test that deleting a point on a triangle segment preserves the triangle structure."""

        # Create a triangle with vertices A(0,0), B(30,0), C(15,20)
        triangle = self.canvas.create_triangle(0, 0, 30, 0, 15, 20, name="ABC", extra_graphics=False)
        
        # Get the segments of the triangle
        segments_before = self.canvas.get_drawables_by_class_name('Segment')
        
        segment_ab = self.canvas.get_segment_by_coordinates(0, 0, 30, 0)
        segment_bc = self.canvas.get_segment_by_coordinates(30, 0, 15, 20)
        segment_ca = self.canvas.get_segment_by_coordinates(15, 20, 0, 0)
        
        self.assertIsNotNone(segment_ab, "Segment AB should exist")
        self.assertIsNotNone(segment_bc, "Segment BC should exist")
        self.assertIsNotNone(segment_ca, "Segment CA should exist")
        
        # Store the actual count of segments before adding point D
        segments_count_before = len(segments_before)
        
        # Create point D on segment AB
        pointD = self.canvas.create_point(15, 0, name="D", extra_graphics=True)
        
        # Get the segments after adding point D
        segments_after_d = self.canvas.get_drawables_by_class_name("Segment")
        
        # Check that the expected segments exist
        ad_segment = self.canvas.get_segment_by_coordinates(0, 0, 15, 0)
        db_segment = self.canvas.get_segment_by_coordinates(15, 0, 30, 0)
        
        self.assertIsNotNone(ad_segment, "Segment AD should exist after adding D")
        self.assertIsNotNone(db_segment, "Segment DB should exist after adding D")
        
        # Verify the number of segments increased
        self.assertEqual(len(segments_after_d), 5, "Adding point D should result in 5 segments (AB, BC, CA, DA, DB)")
        
        # Now delete point D and verify the parent segment is preserved
        self.canvas.delete_point(15, 0)
        
        # Get segments after deletion
        segments_after_deletion = self.canvas.get_drawables_by_class_name("Segment")
        
        # Check that the original triangle segments still exist
        ab_segment_after = self.canvas.get_segment_by_name("AB")
        bc_segment_after = self.canvas.get_segment_by_name("BC")
        ca_segment_after = self.canvas.get_segment_by_name("CA")
        
        # Verify the triangle itself is still there
        triangles_after = self.canvas.get_drawables_by_class_name('Triangle')
        self.assertEqual(len(triangles_after), 1, "Triangle should still exist after deleting point D")
        self.assertEqual(triangles_after[0].name, "ABC", "Triangle ABC should still exist after deleting D")

    def test_basic_undo_redo(self):
        """Test the most basic undo/redo functionality with minimal operations."""
        # Create a point and verify it exists
        point_coords = (42, 42)
        point = self.canvas.create_point(point_coords[0], point_coords[1], "TestPoint")
        
        # Get a fresh reference to verify the point exists
        point_after_create = self.canvas.get_point(point_coords[0], point_coords[1])
        self.assertIsNotNone(point_after_create)
        
        # Delete the point to test undo
        self.canvas.delete_point(point_coords[0], point_coords[1])
        
        # Verify point is gone
        self.assertIsNone(self.canvas.get_point(point_coords[0], point_coords[1]))
        
        # Undo the deletion
        self.canvas.undo()
        
        # Verify point is back
        point_after_undo = self.canvas.get_point(point_coords[0], point_coords[1])
        self.assertIsNotNone(point_after_undo)
        
        # Redo the deletion
        self.canvas.redo()
        
        # Verify point is gone again
        self.assertIsNone(self.canvas.get_point(point_coords[0], point_coords[1]))

    def test_multiple_undo_levels(self):
        """Test that multiple undo operations work correctly in sequence."""
        # Create three points with distinct coordinates
        p1_coords = (11, 11)
        p2_coords = (22, 22)
        p3_coords = (33, 33)
        
        # Create the points
        self.canvas.create_point(p1_coords[0], p1_coords[1], "P1")
        self.canvas.create_point(p2_coords[0], p2_coords[1], "P2")
        self.canvas.create_point(p3_coords[0], p3_coords[1], "P3")
        
        # Delete the points in reverse order
        self.canvas.delete_point(p3_coords[0], p3_coords[1])
        self.canvas.delete_point(p2_coords[0], p2_coords[1])
        self.canvas.delete_point(p1_coords[0], p1_coords[1])
        
        # Verify all points are gone
        self.assertIsNone(self.canvas.get_point(p1_coords[0], p1_coords[1]))
        self.assertIsNone(self.canvas.get_point(p2_coords[0], p2_coords[1]))
        self.assertIsNone(self.canvas.get_point(p3_coords[0], p3_coords[1]))
        
        # Undo deletions one by one
        self.canvas.undo()  # Undo P1 deletion
        self.assertIsNotNone(self.canvas.get_point(p1_coords[0], p1_coords[1]))
        self.assertIsNone(self.canvas.get_point(p2_coords[0], p2_coords[1]))
        self.assertIsNone(self.canvas.get_point(p3_coords[0], p3_coords[1]))
        
        self.canvas.undo()  # Undo P2 deletion
        self.assertIsNotNone(self.canvas.get_point(p1_coords[0], p1_coords[1]))
        self.assertIsNotNone(self.canvas.get_point(p2_coords[0], p2_coords[1]))
        self.assertIsNone(self.canvas.get_point(p3_coords[0], p3_coords[1]))
        
        self.canvas.undo()  # Undo P3 deletion
        self.assertIsNotNone(self.canvas.get_point(p1_coords[0], p1_coords[1]))
        self.assertIsNotNone(self.canvas.get_point(p2_coords[0], p2_coords[1]))
        self.assertIsNotNone(self.canvas.get_point(p3_coords[0], p3_coords[1]))

    def test_undo_redo_branching(self):
        """Test that creating new objects after undo clears the redo stack."""
        # Create first point
        p1_coords = (15, 15)
        point1 = self.canvas.create_point(p1_coords[0], p1_coords[1], "PA")
        
        # Create second point
        p2_coords = (25, 25)
        point2 = self.canvas.create_point(p2_coords[0], p2_coords[1], "PB")
        
        # Delete second point
        self.canvas.delete_point(p2_coords[0], p2_coords[1])
        
        # Verify second point is gone
        self.assertIsNone(self.canvas.get_point(p2_coords[0], p2_coords[1]))
        
        # Undo the deletion to restore second point
        self.canvas.undo()
        self.assertIsNotNone(self.canvas.get_point(p2_coords[0], p2_coords[1]))
        
        # Delete second point again
        self.canvas.delete_point(p2_coords[0], p2_coords[1])
        
        # Create a different point (branching)
        p3_coords = (35, 35)
        point3 = self.canvas.create_point(p3_coords[0], p3_coords[1], "PC")
        
        # Try to redo - should not do anything because we branched
        self.canvas.redo()
        
        # Verify first and third points exist, but not second
        self.assertIsNotNone(self.canvas.get_point(p1_coords[0], p1_coords[1]))
        self.assertIsNotNone(self.canvas.get_point(p3_coords[0], p3_coords[1]))
        self.assertIsNone(self.canvas.get_point(p2_coords[0], p2_coords[1]))

    def test_undo_redo_edge_cases(self):
        """Test undo/redo edge cases like empty history."""
        # Test undo with no history
        initial_count = len(self.canvas.get_drawables())
        self.canvas.undo()  # Should not crash
        self.assertEqual(len(self.canvas.get_drawables()), initial_count)
        
        # Test redo with no future states
        self.canvas.redo()  # Should not crash
        self.assertEqual(len(self.canvas.get_drawables()), initial_count)
        
        # Test creating some state and then testing limits
        point = self.canvas.create_point(10, 10, "A")
        self.canvas.undo()  # Undo creation
        self.assertIsNone(self.canvas.get_point_by_name("A"))
        
        # Try multiple undos beyond history
        for _ in range(5):
            self.canvas.undo()  # Should not crash
        
        # Try multiple redos beyond future
        for _ in range(5):
            self.canvas.redo()  # Should not crash

    def test_delete_colored_area_by_existing_name(self):
        """Test deleting an existing colored area by name."""
        # Create functions for colored area
        f1 = self.canvas.draw_function("x", "f1")
        f2 = self.canvas.draw_function("x^2", "f2")
        
        # Create a colored area between functions
        colored_area = self.canvas.create_colored_area(f1.name, f2.name, left_bound=-5, right_bound=5, color="red")
        self.assertIsNotNone(colored_area)
        
        # Verify it exists
        self.assertIn(colored_area, self.canvas.get_drawables_by_class_name(colored_area.get_class_name()))
        
        # Delete by name
        result = self.canvas.delete_colored_area(colored_area.name)
        self.assertTrue(result, "delete_colored_area should return True for existing areas")
        
        # Verify it's deleted
        self.assertNotIn(colored_area, self.canvas.get_drawables())

    def test_delete_colored_area_by_nonexistent_name(self):
        """Test deleting a colored area with a non-existent name returns False and doesn't cause errors."""
        # Test deleting a colored area that doesn't exist
        result = self.canvas.delete_colored_area('NonexistentColoredArea')
        self.assertFalse(result, "delete_colored_area should return False for non-existent names")
        
        # Create a colored area and verify normal deletion still works
        f1 = self.canvas.draw_function("x", "f1")
        f2 = self.canvas.draw_function("x^2", "f2")
        colored_area = self.canvas.create_colored_area(f1.name, f2.name, left_bound=-3, right_bound=3, color="blue")
        self.assertIsNotNone(colored_area)
        
        # Verify the non-existent deletion didn't affect existing colored areas
        self.assertIn(colored_area, self.canvas.get_drawables())
        
        # Delete the colored area and verify it was removed
        self.assertTrue(self.canvas.delete_colored_area(colored_area.name))
        self.assertNotIn(colored_area, self.canvas.get_drawables())

    def test_angle_deletion_on_point_deletion(self):
        """Test that angles are automatically deleted when their constituent points are deleted."""
        # Create points for angle
        pointA = self.canvas.create_point(0, 0, name="A")
        pointB = self.canvas.create_point(10, 0, name="B") 
        pointC = self.canvas.create_point(0, 10, name="C")
        
        # Create segments
        segmentAB = self.canvas.create_segment(0, 0, 10, 0)
        segmentAC = self.canvas.create_segment(0, 0, 0, 10)
        
        # Create angle
        angle = self.canvas.create_angle(0, 0, 10, 0, 0, 10)
        
        # Verify angle was created
        self.assertIsNotNone(angle)
        angles = self.canvas.get_drawables_by_class_name('Angle')
        self.assertEqual(len(angles), 1)
        self.assertIn(angle, angles)
        
        # Delete vertex point A - this should also delete the angle
        self.canvas.delete_point(0, 0)
        
        # Verify angle was automatically deleted
        angles_after = self.canvas.get_drawables_by_class_name('Angle')
        self.assertEqual(len(angles_after), 0)
        self.assertNotIn(angle, angles_after)

    def test_angle_deletion_on_segment_deletion(self):
        """Test that angles are automatically deleted when their constituent segments are deleted.""" 
        # Create points for angle
        pointA = self.canvas.create_point(0, 0, name="A")
        pointB = self.canvas.create_point(10, 0, name="B")
        pointC = self.canvas.create_point(0, 10, name="C")
        
        # Create segments
        segmentAB = self.canvas.create_segment(0, 0, 10, 0)
        segmentAC = self.canvas.create_segment(0, 0, 0, 10)
        
        # Create angle
        angle = self.canvas.create_angle(0, 0, 10, 0, 0, 10)
        
        # Verify angle was created
        self.assertIsNotNone(angle)
        angles = self.canvas.get_drawables_by_class_name('Angle')
        self.assertEqual(len(angles), 1)
        self.assertIn(angle, angles)
        
        # Delete one of the segments - this should also delete the angle
        self.canvas.delete_segment(0, 0, 10, 0)  # Delete segment AB
        
        # Verify angle was automatically deleted
        angles_after = self.canvas.get_drawables_by_class_name('Angle')
        self.assertEqual(len(angles_after), 0)
        self.assertNotIn(angle, angles_after)