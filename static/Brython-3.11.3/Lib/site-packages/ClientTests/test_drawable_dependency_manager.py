import unittest
from managers.drawable_dependency_manager import DrawableDependencyManager
from ClientTests.simple_mock import SimpleMock
import inspect
import re


class TestDrawableDependencyManager(unittest.TestCase):
    """
    Unit tests for the DrawableDependencyManager class.
    These tests verify dependency tracking, parent/child relationships,
    and canvas reference propagation.
    """
    
    def _create_mock_point(self, name, x=0, y=0):
        """Factory function to create a point mock with SimpleMock"""
        return SimpleMock(
            name=name,
            x=x, 
            y=y,
            canvas=None,
            get_class_name=SimpleMock(return_value='Point'),
            __str__=SimpleMock(return_value=f"Point({name})"),
            __repr__=SimpleMock(return_value=f"Point({name})")
        )

    def _create_mock_segment(self, name, point1, point2):
        """Factory function to create a segment mock with SimpleMock"""
        return SimpleMock(
            name=name,
            point1=point1,
            point2=point2,
            canvas=None,
            get_class_name=SimpleMock(return_value='Segment'),
            __str__=SimpleMock(return_value=f"Segment({name})"),
            __repr__=SimpleMock(return_value=f"Segment({name})")
        )

    def _create_mock_drawable(self, name, class_name="MockDrawable"):
        """Factory function to create a generic drawable mock with SimpleMock"""
        return SimpleMock(
            name=name,
            _class_name=class_name,
            canvas=None,
            get_class_name=SimpleMock(return_value=class_name),
            __str__=SimpleMock(return_value=f"{class_name}({name})"),
            __repr__=SimpleMock(return_value=f"{class_name}({name})")
        )
    
    def setUp(self):
        """Set up test environment before each test"""
        self.manager = DrawableDependencyManager()
        
        # Create mock drawables using private factory methods
        self.point1 = self._create_mock_point("P1", 100, 100)
        self.point2 = self._create_mock_point("P2", 200, 100)
        self.point3 = self._create_mock_point("P3", 200, 200)
        self.segment1 = self._create_mock_segment("S1", self.point1, self.point2)
        self.segment2 = self._create_mock_segment("S2", self.point2, self.point3)
        self.segment3 = self._create_mock_segment("S3", self.point3, self.point1)
        self.triangle = self._create_mock_drawable("T1", "Triangle")
        
    def test_register_dependency(self):
        """Test registering dependencies between drawables"""
        # Register segment1 depends on point1 and point2
        self.manager.register_dependency(child=self.segment1, parent=self.point1)
        self.manager.register_dependency(child=self.segment1, parent=self.point2)
        
        # Check that segment1 has two parents
        parents = self.manager.get_parents(self.segment1)
        self.assertEqual(len(parents), 2, "Segment1 should have 2 parents")
        self.assertIn(self.point1, parents, "Point1 should be a parent of Segment1")
        self.assertIn(self.point2, parents, "Point2 should be a parent of Segment1")
        
        # Check that point1 and point2 each have segment1 as a child
        children_of_point1 = self.manager.get_children(self.point1)
        self.assertEqual(len(children_of_point1), 1, "Point1 should have 1 child")
        self.assertIn(self.segment1, children_of_point1, "Segment1 should be a child of Point1")
        
        children_of_point2 = self.manager.get_children(self.point2)
        self.assertEqual(len(children_of_point2), 1, "Point2 should have 1 child")
        self.assertIn(self.segment1, children_of_point2, "Segment1 should be a child of Point2")
    
    def test_get_all_parents(self):
        """Test getting all parents recursively"""
        # Set up a hierarchical dependency structure
        # Points are parents of segments
        self.manager.register_dependency(child=self.segment1, parent=self.point1)
        self.manager.register_dependency(child=self.segment1, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point1)
        
        # Check that segment1 has points as parents
        all_parents = self.manager.get_all_parents(self.segment1)
        self.assertEqual(len(all_parents), 2, "Segment1 should have 2 total parents")
        self.assertIn(self.point1, all_parents, "Point1 should be in Segment1's all parents")
        self.assertIn(self.point2, all_parents, "Point2 should be in Segment1's all parents")
    
    def test_get_all_children(self):
        """Test getting all children recursively"""
        # Set up a hierarchical dependency structure
        # Points are parents of segments
        self.manager.register_dependency(child=self.segment1, parent=self.point1)
        self.manager.register_dependency(child=self.segment1, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point1)
        
        # Check that point1 has segment1 and segment3 as children
        all_children = self.manager.get_all_children(self.point1)
        self.assertEqual(len(all_children), 2, "Point1 should have 2 total children")
        self.assertIn(self.segment1, all_children, "Segment1 should be in Point1's all children")
        self.assertIn(self.segment3, all_children, "Segment3 should be in Point1's all children")
    
    def test_remove_drawable(self):
        """Test removing a drawable and its dependencies"""
        # Set up dependencies
        self.manager.register_dependency(child=self.segment1, parent=self.point1)
        self.manager.register_dependency(child=self.segment1, parent=self.point2)
        
        # Remove segment1
        self.manager.remove_drawable(self.segment1)
        
        # Check that segment1 is removed from point1's children
        children_of_point1 = self.manager.get_children(self.point1)
        self.assertEqual(len(children_of_point1), 0, "Point1 should have no children after removal")
        
        # Check that segment1 is removed from point2's children
        children_of_point2 = self.manager.get_children(self.point2)
        self.assertEqual(len(children_of_point2), 0, "Point2 should have no children after removal")
        
        # Check that segment1 has no parents
        parents = self.manager.get_parents(self.segment1)
        self.assertEqual(len(parents), 0, "Segment1 should have no parents after removal")
    
    def test_update_canvas_references_parent_propagation(self):
        """Test updating canvas references with propagation to parents"""
        # Arrange: Set up a structure where segments depend on points
        self.manager.register_dependency(child=self.segment1, parent=self.point1)
        self.manager.register_dependency(child=self.segment1, parent=self.point2)
        
        # Mock canvases
        original_canvas = self._create_mock_drawable("OriginalCanvas", "Canvas")
        new_canvas = self._create_mock_drawable("NewCanvas", "Canvas")
        
        # Set initial canvas references
        self.point1.canvas = original_canvas
        self.point2.canvas = original_canvas
        self.segment1.canvas = original_canvas
        
        # Act: Update point1's canvas
        self.manager.update_canvas_references(self.point1, new_canvas)
        
        # Assert: All connected objects should be updated
        self.assertEqual(self.point1.canvas, new_canvas, "Point1's canvas should be updated")
        # We no longer test that segment1 remains unchanged, since we now propagate to children too
        self.assertEqual(self.segment1.canvas, new_canvas, "Segment1's canvas should also be updated")
        # Point2 should be updated via segment1 (childâ†’parent propagation)
        self.assertEqual(self.point2.canvas, new_canvas, "Point2's canvas should be updated via segment1")
    
    def test_update_canvas_references_segment_special_case(self):
        """Test that updating a segment's canvas updates its points (special case)"""
        # Create simplified test objects with clear canvas references
        point1 = self._create_mock_point("TestPoint1")
        point2 = self._create_mock_point("TestPoint2")
        segment = self._create_mock_segment("TestSegment", point1, point2)
        
        # Create canvases
        original_canvas = self._create_mock_drawable("OriginalCanvas", "Canvas")
        new_canvas = self._create_mock_drawable("NewCanvas", "Canvas")
        
        # Set initial canvas references
        point1.canvas = original_canvas
        point2.canvas = original_canvas
        segment.canvas = original_canvas
        
        # Register dependencies
        self.manager.register_dependency(child=segment, parent=point1)
        self.manager.register_dependency(child=segment, parent=point2)
        
        # Update segment's canvas
        self.manager.update_canvas_references(segment, new_canvas)
        
        # Verify both segment and points have updated canvas
        self.assertEqual(segment.canvas, new_canvas, "Segment's canvas should be updated")
        self.assertEqual(point1.canvas, new_canvas, "Point1's canvas should be updated")
        self.assertEqual(point2.canvas, new_canvas, "Point2's canvas should be updated")
    
    def test_resolve_dependency_order(self):
        """Test resolving dependencies in the correct order"""
        # Set up dependencies: Segments -> Points (points are parents of segments)
        self.manager.register_dependency(child=self.segment1, parent=self.point1)
        self.manager.register_dependency(child=self.segment1, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point1)
        
        # Resolve the order (points should come before segments)
        drawables = [self.segment1, self.point2, self.point1, self.segment3, self.segment2, self.point3]
        ordered = self.manager.resolve_dependency_order(drawables)
        
        # Check that points come before their segments
        for point in [self.point1, self.point2, self.point3]:
            point_index = ordered.index(point)
            for segment in [self.segment1, self.segment2, self.segment3]:
                if point in self.manager.get_parents(segment):
                    segment_index = ordered.index(segment)
                    self.assertLess(point_index, segment_index, 
                                   f"Point {point.name} should come before its segment {segment.name}")
    
    def test_circular_dependencies(self):
        """Test handling of circular dependencies"""
        # Create a circular dependency: A -> B -> C -> A
        a = self._create_mock_drawable("A")
        b = self._create_mock_drawable("B")
        c = self._create_mock_drawable("C")
        
        self.manager.register_dependency(child=b, parent=a)
        self.manager.register_dependency(child=c, parent=b)
        self.manager.register_dependency(child=a, parent=c)
        
        # Attempting to get all parents should not cause an infinite loop
        try:
            all_parents_a = self.manager.get_all_parents(a)
            self.assertIn(b, all_parents_a, "B should be in A's all parents")
            self.assertIn(c, all_parents_a, "C should be in A's all parents")
            # A should also be in its own all_parents due to the circular reference
            self.assertIn(a, all_parents_a, "A should be in its own all_parents (circular)")
        except RecursionError:
            self.fail("get_all_parents failed to handle circular dependency")
        
        # Test dependency order resolution with circular dependencies
        drawables = [a, b, c]
        try:
            ordered = self.manager.resolve_dependency_order(drawables)
            # We just care that it completes without infinite recursion
            # The exact order might vary based on implementation details for cycles
            self.assertEqual(len(ordered), 3, "All three drawables should be in the result")
        except RecursionError:
            self.fail("resolve_dependency_order failed to handle circular dependency")
    
    def test_analyze_drawable_for_dependencies(self):
        """Test analyzing drawable for dependencies"""
        # Test Segment
        segment = self._create_mock_segment("TestSegment", self.point1, self.point2)
        dependencies = self.manager.analyze_drawable_for_dependencies(segment)
        self.assertEqual(len(dependencies), 2, "Segment should have 2 dependencies")
        self.assertIn(self.point1, dependencies, "Point1 should be a dependency of segment")
        self.assertIn(self.point2, dependencies, "Point2 should be a dependency of segment")
        
        # Test Vector
        vector_segment = self._create_mock_segment("VectorSegment", self.point1, self.point2)
        vector = self._create_mock_drawable("TestVector", "Vector")
        vector.segment = vector_segment
        vector_dependencies = self.manager.analyze_drawable_for_dependencies(vector)
        self.assertEqual(len(vector_dependencies), 1, "Vector should have 1 dependency")
        self.assertIn(vector_segment, vector_dependencies, "Segment should be a dependency of vector")
        
        # Test Triangle
        triangle = self._create_mock_drawable("TestTriangle", "Triangle")
        triangle.segment1 = self.segment1
        triangle.segment2 = self.segment2
        triangle.segment3 = self.segment3
        triangle_dependencies = self.manager.analyze_drawable_for_dependencies(triangle)
        self.assertEqual(len(triangle_dependencies), 3, "Triangle should have 3 segment dependencies")
        self.assertIn(self.segment1, triangle_dependencies, "segment1 should be a dependency of triangle")
        self.assertIn(self.segment2, triangle_dependencies, "segment2 should be a dependency of triangle")
        self.assertIn(self.segment3, triangle_dependencies, "segment3 should be a dependency of triangle")
        
        # Test Rectangle
        rectangle = self._create_mock_drawable("TestRectangle", "Rectangle")
        rectangle.segment1 = self.segment1
        rectangle.segment2 = self.segment2
        rectangle.segment3 = self.segment3
        rectangle.segment4 = self._create_mock_segment("S4", self.point1, self.point3)
        rectangle_dependencies = self.manager.analyze_drawable_for_dependencies(rectangle)
        self.assertEqual(len(rectangle_dependencies), 4, "Rectangle should have 4 segment dependencies")
        self.assertIn(self.segment1, rectangle_dependencies, "segment1 should be a dependency of rectangle")
        self.assertIn(self.segment2, rectangle_dependencies, "segment2 should be a dependency of rectangle")
        self.assertIn(self.segment3, rectangle_dependencies, "segment3 should be a dependency of rectangle")
        self.assertIn(rectangle.segment4, rectangle_dependencies, "segment4 should be a dependency of rectangle")
        
        # Test Circle
        circle_center = self._create_mock_point("CenterPoint")
        circle = self._create_mock_drawable("TestCircle", "Circle")
        circle.center = circle_center
        circle_dependencies = self.manager.analyze_drawable_for_dependencies(circle)
        self.assertEqual(len(circle_dependencies), 1, "Circle should have 1 dependency")
        self.assertIn(circle_center, circle_dependencies, "Center point should be a dependency of circle")
        
        # Test Ellipse
        ellipse_center = self._create_mock_point("EllipseCenter")
        ellipse = self._create_mock_drawable("TestEllipse", "Ellipse")
        ellipse.center = ellipse_center
        ellipse_dependencies = self.manager.analyze_drawable_for_dependencies(ellipse)
        self.assertEqual(len(ellipse_dependencies), 1, "Ellipse should have 1 dependency")
        self.assertIn(ellipse_center, ellipse_dependencies, "Center point should be a dependency of ellipse")
        
        # Test Function
        function = self._create_mock_drawable("TestFunction", "Function")
        function_dependencies = self.manager.analyze_drawable_for_dependencies(function)
        self.assertEqual(len(function_dependencies), 0, "Function should have no dependencies")
        
        # Test SegmentsBoundedColoredArea
        segments_area = self._create_mock_drawable("TestSegmentsArea", "SegmentsBoundedColoredArea")
        segments_area.segment1 = self.segment1
        segments_area.segment2 = self.segment2
        segments_area_dependencies = self.manager.analyze_drawable_for_dependencies(segments_area)
        self.assertEqual(len(segments_area_dependencies), 2, "SegmentsBoundedColoredArea should have 2 dependencies")
        self.assertIn(self.segment1, segments_area_dependencies, "segment1 should be a dependency of area")
        self.assertIn(self.segment2, segments_area_dependencies, "segment2 should be a dependency of area")
        
        # Test FunctionSegmentBoundedColoredArea
        func_seg_area = self._create_mock_drawable("TestFuncSegArea", "FunctionSegmentBoundedColoredArea")
        func_seg_area.func = function
        func_seg_area.segment = self.segment1
        func_seg_area_dependencies = self.manager.analyze_drawable_for_dependencies(func_seg_area)
        self.assertEqual(len(func_seg_area_dependencies), 2, "FunctionSegmentBoundedColoredArea should have 2 dependencies")
        self.assertIn(function, func_seg_area_dependencies, "function should be a dependency of area")
        self.assertIn(self.segment1, func_seg_area_dependencies, "segment should be a dependency of area")
        
        # Test FunctionsBoundedColoredArea
        funcs_area = self._create_mock_drawable("TestFuncsArea", "FunctionsBoundedColoredArea")
        funcs_area.func1 = function
        function2 = self._create_mock_drawable("TestFunction2", "Function")
        funcs_area.func2 = function2
        funcs_area_dependencies = self.manager.analyze_drawable_for_dependencies(funcs_area)
        self.assertEqual(len(funcs_area_dependencies), 2, "FunctionsBoundedColoredArea should have 2 dependencies")
        self.assertIn(function, funcs_area_dependencies, "func1 should be a dependency of area")
        self.assertIn(function2, funcs_area_dependencies, "func2 should be a dependency of area")
        
        # Test object with missing get_class_name method
        obj_without_method = SimpleMock(name="NoMethod")
        dependencies = self.manager.analyze_drawable_for_dependencies(obj_without_method)
        self.assertEqual(len(dependencies), 0, "Object without get_class_name should return empty dependencies list")
    
    def test_update_canvas_references_bidirectional(self):
        """Test updating canvas references with bidirectional propagation (parents and children)"""
        # Arrange: Create a structure with parents and children
        #   Point1 <- Segment1 -> Point2
        #      ^                    ^
        #      |                    |
        #   Segment3              Segment2
        #      |                    |
        #      v                    v
        #   Point3 --------------> Point3
        
        # Set up dependencies
        self.manager.register_dependency(child=self.segment1, parent=self.point1)
        self.manager.register_dependency(child=self.segment1, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point2)
        self.manager.register_dependency(child=self.segment2, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point3)
        self.manager.register_dependency(child=self.segment3, parent=self.point1)
        
        # Mock canvases
        canvas_class = "Canvas"  # Get class_name right
        original_canvas = self._create_mock_drawable("OriginalCanvas", canvas_class)
        new_canvas = self._create_mock_drawable("NewCanvas", canvas_class)
        
        # Set initial canvas references
        self.point1.canvas = original_canvas
        self.point2.canvas = original_canvas
        self.point3.canvas = original_canvas
        self.segment1.canvas = original_canvas
        self.segment2.canvas = original_canvas
        self.segment3.canvas = original_canvas
        
        # Verify we've set up correctly
        self.assertEqual(self.point1.canvas, original_canvas, "Point1's initial canvas should be original_canvas")
        self.assertEqual(self.point2.canvas, original_canvas, "Point2's initial canvas should be original_canvas")
        
        # Act: Update point1's canvas - should propagate to all connected objects
        self.manager.update_canvas_references(self.point1, new_canvas)
        
        # Assert: All objects should be updated since they're all connected
        self.assertEqual(self.point1.canvas, new_canvas, "Point1's canvas should be updated")
        self.assertEqual(self.point2.canvas, new_canvas, "Point2's canvas should be updated")
        self.assertEqual(self.point3.canvas, new_canvas, "Point3's canvas should be updated")
        self.assertEqual(self.segment1.canvas, new_canvas, "Segment1's canvas should be updated")
        self.assertEqual(self.segment2.canvas, new_canvas, "Segment2's canvas should be updated")
        self.assertEqual(self.segment3.canvas, new_canvas, "Segment3's canvas should be updated")
    
    def test_drawable_types_completeness(self):
        """Test that analyze_drawable_for_dependencies has cases for all drawable types"""
        # Use _type_hierarchy as the source of truth for drawable types
        drawable_types = set(self.manager._type_hierarchy.keys())
        
        # Inspect the analyze_drawable_for_dependencies method to extract the class names it handles
        handled_classes = set()
        
        # Get the source code of the analyze_drawable_for_dependencies method
        method_source = inspect.getsource(self.manager.analyze_drawable_for_dependencies)
        
        # More robust detection of class names in conditionals
        class_patterns = [
            r"if\s+class_name\s*==\s*['\"]([^'\"]+)['\"]",  # if class_name == 'Type'
            r"elif\s+class_name\s*==\s*['\"]([^'\"]+)['\"]"  # elif class_name == 'Type'
        ]
        
        for pattern in class_patterns:
            for match in re.finditer(pattern, method_source):
                class_name = match.group(1)
                handled_classes.add(class_name)
        
        # Check for the generic ColoredArea handler
        if re.search(r"class_name\.endswith\(['\"]ColoredArea['\"]\)", method_source):
            # If we have the generic handler, it covers all ColoredArea classes
            handled_classes.add('ColoredArea')
            # Also mark any remaining *ColoredArea classes as handled by the generic handler
            for class_name in drawable_types:
                if class_name.endswith('ColoredArea'):
                    handled_classes.add(class_name)
        
        # Check for missing implementations
        missing_implementations = drawable_types - handled_classes
        
        # Print debug info
        print(f"All drawable types to check: {sorted(drawable_types)}")
        print(f"Handled classes: {sorted(handled_classes)}")
        print(f"Missing implementations: {sorted(missing_implementations)}")
        
        # Assert that all types are handled
        self.assertEqual(len(missing_implementations), 0, 
                         f"Missing analyze_drawable_for_dependencies cases for: {', '.join(missing_implementations)}")

    def test_error_handling_none_values(self):
        """Test handling of None values in various methods"""
        # Test register_dependency with None values
        # Neither should raise exceptions, but should have no effect
        self.manager.register_dependency(None, self.point1)
        self.manager.register_dependency(self.segment1, None)
        
        # Test get_parents and get_children with None
        self.assertEqual(len(self.manager.get_parents(None)), 0, "get_parents should return empty set for None")
        self.assertEqual(len(self.manager.get_children(None)), 0, "get_children should return empty set for None")
        
        # Test get_all_parents and get_all_children with None
        self.assertEqual(len(self.manager.get_all_parents(None)), 0, "get_all_parents should return empty set for None")
        self.assertEqual(len(self.manager.get_all_children(None)), 0, "get_all_children should return empty set for None")
        
        # Test remove_drawable with None
        try:
            self.manager.remove_drawable(None)  # Should not raise exception
        except Exception as e:
            self.fail(f"remove_drawable failed with None: {e}")
            
        # Test update_canvas_references with None
        dummy_canvas = self._create_mock_drawable("DummyCanvas", "Canvas")
        try:
            self.manager.update_canvas_references(None, dummy_canvas)  # Should not raise exception
        except Exception as e:
            self.fail(f"update_canvas_references failed with None drawable: {e}")
            
        # Test analyze_drawable_for_dependencies with None
        dependencies = self.manager.analyze_drawable_for_dependencies(None)
        self.assertEqual(len(dependencies), 0, "analyze_drawable_for_dependencies should return empty list for None")
        
        # Test resolve_dependency_order with None in list
        ordered = self.manager.resolve_dependency_order([self.point1, None, self.point2])
        self.assertEqual(len(ordered), 2, "resolve_dependency_order should filter out None values")
        self.assertNotIn(None, ordered, "None should not appear in ordered results")
    
    def test_edge_cases(self):
        """Test edge cases like empty inputs and non-existent drawables"""
        # Test empty list for resolve_dependency_order
        ordered = self.manager.resolve_dependency_order([])
        self.assertEqual(len(ordered), 0, "Empty input should produce empty output")
        
        # Test removing non-existent drawable
        non_existent = self._create_mock_drawable("NonExistent")
        try:
            self.manager.remove_drawable(non_existent)  # Should not raise exception
        except Exception as e:
            self.fail(f"remove_drawable failed with non-existent drawable: {e}")
            
        # Test get_parents and get_children for non-existent drawable
        self.assertEqual(len(self.manager.get_parents(non_existent)), 0, 
                         "get_parents should return empty set for non-existent drawable")
        self.assertEqual(len(self.manager.get_children(non_existent)), 0, 
                         "get_children should return empty set for non-existent drawable")
    
    def test_verify_get_class_name_method(self):
        """Test the _verify_get_class_name_method helper directly"""
        # Object with get_class_name method
        obj_with_method = self._create_mock_drawable("HasMethod")
        
        # Object without get_class_name method
        obj_without_method = SimpleMock(name="NoMethod")
        
        # Direct testing of the helper method
        try:
            # Should not raise exception, just print warning
            self.manager._verify_get_class_name_method(obj_with_method, "TestObject")
            self.manager._verify_get_class_name_method(obj_without_method, "TestObject")
            self.manager._verify_get_class_name_method(None, "TestObject")
        except Exception as e:
            self.fail(f"_verify_get_class_name_method raised unexpected exception: {e}")
        
        # We've successfully called the method without errors, which is the main test
        # The method primarily logs warnings, so we don't have much else to assert