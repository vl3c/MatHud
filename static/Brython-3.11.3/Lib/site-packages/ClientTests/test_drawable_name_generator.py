import unittest
from name_generator.drawable import DrawableNameGenerator
from .simple_mock import SimpleMock


class TestDrawableNameGenerator(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock()
        # Ensure canvas has the get_drawables_by_class_name method from the start
        self.canvas.get_drawables_by_class_name = SimpleMock(return_value=[])
        self.generator = DrawableNameGenerator(self.canvas)

    def test_get_drawable_names(self):
        # Here, get_drawables_by_class_name is expected to be a callable that returns a list of mocks when called
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='Point1'), SimpleMock(name='Point2')]
        )
        result = self.generator.get_drawable_names('Point')
        self.assertEqual(result, ['Point1', 'Point2'])

    def test_filter_string(self):
        # Test with a string that contains letters, digits, apostrophes, and parentheses
        result = self.generator.filter_string("Test(123)'")
        self.assertEqual(result, "Test(123)'")
        # Test with a string that contains special characters
        result = self.generator.filter_string("Hello, World!")
        self.assertEqual(result, "HelloWorld")
        # Test with a string that contains whitespace
        result = self.generator.filter_string("Hello World")
        self.assertEqual(result, "HelloWorld")
        # Test with a string that contains only disallowed characters
        result = self.generator.filter_string("!@#$%^&*")
        self.assertEqual(result, "")
        # Test with an empty string
        result = self.generator.filter_string("")
        self.assertEqual(result, "")

    def test_print_names(self):
        """Test the print_names method outputs the expected information."""
        # Create a completely fresh generator with a new mock canvas
        mock_canvas = SimpleMock()
        
        # Define predictable returns for each class name
        mock_returns = {
            'Point': [SimpleMock(name='Point1'), SimpleMock(name='Point2')],
            'Segment': [SimpleMock(name='Segment1'), SimpleMock(name='Segment2')],
            'Triangle': [SimpleMock(name='Triangle1'), SimpleMock(name='Triangle2')],
            'Rectangle': [SimpleMock(name='Rectangle1'), SimpleMock(name='Rectangle2')],
            'Circle': [SimpleMock(name='Circle1'), SimpleMock(name='Circle2')],
            'Ellipse': [SimpleMock(name='Ellipse1'), SimpleMock(name='Ellipse2')],
            'Function': [SimpleMock(name='Function1'), SimpleMock(name='Function2')]
        }
        
        # Set up the canvas.get_drawables_by_class_name to return the appropriate mock objects
        def mock_get_drawables(class_name):
            return mock_returns.get(class_name, [])
            
        mock_canvas.get_drawables_by_class_name = mock_get_drawables
        
        # Create a test generator with our fully controlled mock canvas
        test_generator = DrawableNameGenerator(mock_canvas)
        
        # Capture print output
        original_print = __builtins__.print
        printed_lines = []
        
        def mock_print(*args, **kwargs):
            line = ' '.join(str(arg) for arg in args)
            printed_lines.append(line)
        
        # Replace print with our mock
        __builtins__.print = mock_print
        
        try:
            # Call the method being tested
            test_generator.print_names()
        finally:
            # Restore original print function
            __builtins__.print = original_print
        
        # Check the output
        expected_lines = [
            "Point names: ['Point1', 'Point2']",
            "Segment names: ['Segment1', 'Segment2']",
            "Triangle names: ['Triangle1', 'Triangle2']",
            "Rectangle names: ['Rectangle1', 'Rectangle2']",
            "Circle names: ['Circle1', 'Circle2']",
            "Ellipse names: ['Ellipse1', 'Ellipse2']",
            "Function names: ['Function1', 'Function2']"
        ]
        
        # Compare line by line for easier debugging
        self.assertEqual(len(printed_lines), len(expected_lines), 
                         f"Expected {len(expected_lines)} lines but got {len(printed_lines)}")
        for i, (actual, expected) in enumerate(zip(printed_lines, expected_lines)):
            self.assertEqual(actual, expected, f"Line {i+1} doesn't match: {actual} != {expected}")

    def test_split_point_names_basic(self):
        result = self.generator.split_point_names("A'B'CD", 4)
        self.assertEqual(result, ["A'", "B'", "C", "D"])
    
    def test_split_point_names_empty(self):
        # Test with empty expression
        result = self.generator.split_point_names("", 3)
        self.assertEqual(result, ["", "", ""])
        
        # Test with None expression
        result = self.generator.split_point_names(None, 2)
        self.assertEqual(result, ["", ""])
    
    def test_split_point_names_with_special_chars(self):
        # Test with expression containing special characters
        result = self.generator.split_point_names("A@B#C", 3)
        self.assertEqual(result, ["A", "B", "C"])
    
    def test_split_point_names_with_repeated_calls(self):
        # First call should return first n letters
        result1 = self.generator.split_point_names("ABCDE", 2)
        self.assertEqual(result1, ["A", "B"])
        
        # Second call with same expression should return next n letters
        result2 = self.generator.split_point_names("ABCDE", 2)
        self.assertEqual(result2, ["C", "D"])
        
        # Third call with same expression should return remaining letters and empty strings if needed
        result3 = self.generator.split_point_names("ABCDE", 2)
        self.assertEqual(result3, ["E", ""])
    
    def test_generate_unique_point_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(return_value=[])
        point_names = []
        for _ in range(52):
            new_name = self.generator._generate_unique_point_name()
            point_names.append(new_name)
            # Update the return_value of get_drawables_by_class_name with each new name
            self.canvas.get_drawables_by_class_name.return_value.append(SimpleMock(name=new_name))
        # The next point name should be 'A'' (A with two apostrophes)
        result = self.generator._generate_unique_point_name()
        self.assertEqual(result, "A''")

    def test_generate_point_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A')]
        )
        result = self.generator.generate_point_name(None)
        self.assertEqual(result, 'B')

    def test_generate_point_name_with_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A')]
        )
        result = self.generator.generate_point_name('B')
        self.assertEqual(result, 'B')

    def test_generate_point_name_with_used_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A'), SimpleMock(name='B')]
        )
        result = self.generator.generate_point_name('B')
        self.assertNotEqual(result, 'B')

    def test_generate_point_name_with_complex_preferred_name(self):
        # When we pass "AB'C" as preferred_name, and 'A' is already used,
        # the code should attempt to generate 'A'' (A with an apostrophe)
        # rather than moving to next letter 'B''
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A'), SimpleMock(name="B'")]
        )
        
        # Reset the dictionary for a clean test
        self.generator.used_letters_from_names = {}
        
        result = self.generator.generate_point_name("AB'C")
        # The algorithm tries A first, but it's taken
        # So it adds an apostrophe to get A', which is not taken
        self.assertEqual(result, "A'")  # Should return A', not C

    def test_increment_function_name(self):
        # Test with a function name that ends with a number
        result = self.generator._increment_function_name('f4')
        self.assertEqual(result, 'f5')
        # Test with a function name that does not end with a number
        result = self.generator._increment_function_name('f')
        self.assertEqual(result, 'f1')
        # Test with a function name that ends with a large number
        result = self.generator._increment_function_name('f99')
        self.assertEqual(result, 'f100')
        # Test with a function name that ends with a number and has other numbers in it
        result = self.generator._increment_function_name('f4f4')
        self.assertEqual(result, 'f4f5')
        # Test with a function name that does not end with a number and has other numbers in it
        result = self.generator._increment_function_name('f4f')
        self.assertEqual(result, 'f4f1')

    def test_generate_unique_function_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(return_value=[])
        function_names = []
        for _ in range(42):
            new_name = self.generator._generate_unique_function_name()
            function_names.append(new_name)
            # Update the return_value of get_drawables_by_class_name with each new name
            self.canvas.get_drawables_by_class_name.return_value.append(SimpleMock(name=new_name))
        # The next function name should be 'r1'
        result = self.generator._generate_unique_function_name()
        self.assertEqual(result, "v1")

    def test_generate_function_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f'), SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name(None)
        self.assertEqual(result, 'g')

    def test_generate_function_name_with_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name('f2')
        self.assertEqual(result, 'f2')

    def test_generate_function_name_with_used_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1'), SimpleMock(name='f2')]
        )
        result = self.generator.generate_function_name('f2')
        self.assertEqual(result, 'f3')

    def test_generate_function_name_with_preferred_name_and_parentheses(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name('f2(x)')
        self.assertEqual(result, 'f2')

    def test_generate_function_name_with_used_preferred_name_and_parentheses(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1'), SimpleMock(name='f2')]
        )
        result = self.generator.generate_function_name('f2(x)')
        self.assertEqual(result, 'f3')

    def test_generate_function_name_with_complex_expression(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1'), SimpleMock(name='f2')]
        )
        result = self.generator.generate_function_name('g(x) = sin(x)')
        self.assertEqual(result, 'g')
