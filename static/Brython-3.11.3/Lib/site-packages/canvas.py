from itertools import combinations
from browser import document
from point import Position, Point
from math_geometry import Segment, Vector, Triangle, Rectangle
from cartesian_system_2axis import Cartesian2Axis
from drawable import DrawableNameGenerator
from collections import defaultdict
from math_util import Utilities

class Canvas:
    def __init__(self):
        self.drawables = {}
        self.name_generator = DrawableNameGenerator()
        math_viewport = document['math-svg'].getBoundingClientRect()
        self.width = math_viewport.width
        self.height = math_viewport.height
        self.center = Position(self.width / 2, self.height / 2)
        self.scale_factor = 1  # Default scale factor is 1 (no scaling)
        self.zoom_point = Position(0, 0)  # Default zoom point is at origin
        self.zoom_direction = 0  # Default zoom direction is 0 (no zoom)
        self.zoom_step = 0.1  # Default zoom step is 0.1 (10%)
        self.dragging = False
        self.offset = Position(0, 0)  # Default offset is 0
        self.cartesian2axis = Cartesian2Axis(self)
        self.cartesian2axis.origin = Point(x=0, y=0, canvas=self, name="o")
        self.cartesian2axis.draw()

    def add_drawable(self, drawable):
        drawable.canvas = self  # Set the drawable's canvas reference
        category = drawable.get_class_name()
        if category not in self.drawables:
            self.drawables[category] = []
        self.drawables[category].append(drawable)

    def draw(self, apply_zoom=False):
        svg_container = document["math-svg"]
        svg_container.clear()
        self._draw_cartesian(apply_zoom)
        for drawable in self.get_drawables():
            drawable.pan()
            if apply_zoom:
                drawable.zoom()
            drawable.draw()  # Draw each drawable
        self.offset = Position(0, 0)  # Reset the offset

    def _draw_cartesian(self, apply_zoom=False):
        self.cartesian2axis.pan()
        if apply_zoom:
            self.cartesian2axis.zoom()
        self.cartesian2axis.draw()

    def clear(self):
        self.reset()
        self.drawables = {}
        self.name_generator.clear()
        self.draw()

    def reset(self):
        self.center = Position(self.width / 2, self.height / 2)
        self.scale_factor = 1
        self.offset = Position(0, 0)
        self.zoom_direction = 0
        self.dragging = False
        self.cartesian2axis.reset()
        for drawable in self.get_drawables():
            drawable.reset()
        self.draw()
    
    def get_drawables(self):
        return [drawable for category in self.drawables for drawable in self.drawables[category]]
    
    def get_drawables_state(self):
        state_dict = {}
        for category, drawables in self.drawables.items():
            state_dict[category + 's'] = [drawable.get_state() for drawable in drawables]
        return state_dict
    
    def _point_matches_coords(self, point, x, y):
        return point.original_position.x == x and point.original_position.y == y

    def _segment_matches_coords(self, segment, x1, y1, x2, y2):
        return ((self._point_matches_coords(segment.point1, x1, y1) and self._point_matches_coords(segment.point2, x2, y2)) or
               (self._point_matches_coords(segment.point1, x2, y2) and self._point_matches_coords(segment.point2, x1, y1)))

    def _segment_matches_point_names(self, segment, point1_name, point2_name):
        return ((segment.point1.name == point1_name and segment.point2.name == point2_name) or
               (segment.point1.name == point2_name and segment.point2.name == point1_name))

    def _segment_has_point(self, segment, x, y):
            return self._point_matches_coords(segment.point1, x, y) or self._point_matches_coords(segment.point2, x, y)

    def _delete_point_dependencies(self, x, y):
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles.copy():
            if any(self._segment_has_point(segment, x, y) for segment in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                rectangles.remove(rectangle)
                self.name_generator.delete_rectangle_name(rectangle.name)
        triangles = self.drawables.get('Triangle', [])
        for triangle in triangles.copy():
            if any(self._segment_has_point(segment, x, y) for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                triangles.remove(triangle)
                self.name_generator.delete_triangle_name(triangle.name)
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            if self._segment_has_point(segment, x, y):
                self.delete_segment(segment.point1.original_position.x, segment.point1.original_position.y, 
                                    segment.point2.original_position.x, segment.point2.original_position.y,
                                    delete_children=True, delete_parents=False)
        vectors = self.drawables.get('Vector', [])
        for vector in vectors.copy():
            if self._segment_has_point(vector.segment, x, y):
                self.delete_vector(vector)

    def _delete_segment_dependencies(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        segment = self.get_segment(x1, y1, x2, y2)
        if segment:
            # Delete the segment's children
            if delete_children:
                print("Deleting segment's children")
                for child_segment in segment.children:
                    self.delete_segment(child_segment.point1.original_position.x, 
                                        child_segment.point1.original_position.y, 
                                        child_segment.point2.original_position.x, 
                                        child_segment.point2.original_position.y, 
                                        delete_children=True,
                                        delete_parents=False)
            # If it's not part of a recursive call, delete the parents
            if delete_parents:
                print("Deleting segment's parents")
                segments = self.drawables.get('Segment', [])
                for s in segments.copy():
                    if segment in s.children:
                        self.delete_segment(s.point1.original_position.x, 
                                            s.point1.original_position.y, 
                                            s.point2.original_position.x, 
                                            s.point2.original_position.y, 
                                            delete_children=False,
                                            delete_parents=True)
        # Delete the segment's vectors
        self.delete_vector(x1, y1, x2, y2)
        self.delete_vector(x2, y2, x1, y1)
        # Delete the rectangles and triangles that contain the segment
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles.copy():
            if any(self._segment_matches_coords(segment, x1, y1, x2, y2) for segment in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                rectangles.remove(rectangle)
                self.name_generator.delete_rectangle_name(rectangle.name)
        triangles = self.drawables.get('Triangle', [])
        for triangle in triangles.copy():
            if any(self._segment_matches_coords(segment, x1, y1, x2, y2) for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                triangles.remove(triangle)
                self.name_generator.delete_triangle_name(triangle.name)

    def _remove_segment_from_parents(self, segment_to_remove):
        segments = self.drawables.get('Segment', [])
        for s in segments:
            # If segment_to_remove is found in the children list of segment s, remove it
            if segment_to_remove in s.children:
                s.children.remove(segment_to_remove)

    def get_point(self, x, y):
        points = self.drawables.get('Point', [])
        for point in points:
            if self._point_matches_coords(point, x, y):
                return point
        return None
    
    def get_point_by_name(self, name):
        points = self.drawables.get('Point', [])
        for point in points:
            if point.name == name:
                return point
        return None

    def create_point(self, x, y, name=""):
        point = self.get_point(x, y)
        if point and name != "":
            self.name_generator.delete_point_name(point.name)
            point.name = self.name_generator.get_unique_point_name(name)
        elif not point:
            point = Point(x, y, canvas=self, name=name)
            self.add_drawable(point)
            self._create_drawables_from_new_connections()
        self.draw()

    def delete_point(self, x, y):
        points = self.drawables.get('Point', [])
        for point in points.copy():
            if self._point_matches_coords(point, x, y):
                self._delete_point_dependencies(x, y)
                points.remove(point)
                self.name_generator.delete_point_name(point.name)
                self.draw()
                break
    
    def get_segment(self, x1, y1, x2, y2):
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            if self._segment_has_point(segment, x1, y1) and self._segment_has_point(segment, x2, y2):
                return segment
        return None

    def create_segment(self, x1, y1, x2, y2, name=""):
        existing_segment = self.get_segment(x1, y1, x2, y2)
        if existing_segment:
            return
        segment = Segment(x1, y1, x2, y2, canvas=self, name=name)
        self.add_drawable(segment)
        self._create_drawables_from_new_connections()
        self.draw()

    def delete_segment(self, x1, y1, x2, y2, delete_children=True, delete_parents=True):
        segment = self.get_segment(x1, y1, x2, y2)
        if segment:
            print(f"Actually deleting segment {segment.name}")
            self._delete_segment_dependencies(x1, y1, x2, y2, delete_children, delete_parents)
            self._remove_segment_from_parents(segment)
            self.drawables['Segment'].remove(segment)
            self.name_generator.delete_segment_name(segment.name)
            self.draw()
        print("Segment not found")

    def get_vector(self, x1, y1, x2, y2):
        vectors = self.drawables.get('Vector', [])
        for vector in vectors.copy():
            if self._segment_has_point(vector.segment, x1, y1) and self._segment_has_point(vector.segment, x2, y2):
                return vector
        return None

    def create_vector(self, origin_x, origin_y, tip_x, tip_y, name=""):
        existing_vector = self.get_vector(origin_x, origin_y, tip_x, tip_y)
        if existing_vector:
            return
        vector = Vector(origin_x, origin_y, tip_x, tip_y, canvas=self, name=name)
        self.add_drawable(vector)
        self.draw()

    def delete_vector(self, origin_x, origin_y, tip_x, tip_y,):
        vector = self.get_vector(origin_x, origin_y, tip_x, tip_y,)
        if vector:
            self.drawables['Vector'].remove(vector)
            self.draw()

    def get_triangle(self, x1, y1, x2, y2, x3, y3):
        triangles = self.drawables.get('Triangle', [])
        for drawable in triangles.copy():
            if all(self._segment_matches_coords(segment, x1, y1, x2, y2) or
                self._segment_matches_coords(segment, x1, y1, x3, y3) or
                self._segment_matches_coords(segment, x2, y2, x3, y3) for segment in [drawable.segment1, drawable.segment2, drawable.segment3]):
                return drawable
        return None

    def create_triangle(self, x1, y1, x2, y2, x3, y3, name=""):
        existing_triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if existing_triangle:
            return
        triangle = Triangle(x1, y1, x2, y2, x3, y3, canvas=self, name=name)
        self.add_drawable(triangle)
        self._create_drawables_from_new_connections()
        self.draw()

    def delete_triangle(self, x1, y1, x2, y2, x3, y3):     
        triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if not triangle:
            return
        self.drawables['Triangle'].remove(triangle)
        self.name_generator.delete_triangle_name(triangle.name)
        self.delete_segment(x1, y1, x2, y2)
        self.delete_segment(x2, y2, x3, y3)
        self.delete_segment(x3, y3, x1, y1)
        self.draw()

    def get_rectangle_by_diagonal_points(self, px, py, opposite_px, opposite_py):
        rectangles = self.drawables.get('Rectangle', [])
        for drawable in rectangles.copy():
            if all(self._segment_matches_coords(segment, px, py, opposite_px, opposite_py) 
                for segment in [drawable.segment1, drawable.segment2, drawable.segment3, drawable.segment4]):
                return drawable
        return None

    def get_rectangle_by_name(self, name):
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles:
            if rectangle.name == name:
                return rectangle
        return None

    def create_rectangle(self, p_x, p_y, opposite_x, opposite_y, name=""):
        existing_rectangle = self.get_rectangle_by_diagonal_points(p_x, p_y, opposite_x, opposite_y)
        if existing_rectangle:
            return
        rectangle = Rectangle(p_x, p_y, opposite_x, opposite_y, canvas=self, name=name)
        self.add_drawable(rectangle)
        self._create_drawables_from_new_connections()
        self.draw()

    def delete_rectangle(self, name):
        rectangle = self.get_rectangle_by_name(name)
        if not rectangle:
            return
        self.drawables['Rectangle'].remove(rectangle)
        self.name_generator.delete_rectangle_name(rectangle.name)
        # delete all 4 segments
        self.delete_segment(rectangle.segment1.point1.original_position.x, rectangle.segment1.point1.original_position.y, 
                                rectangle.segment1.point2.original_position.x, rectangle.segment1.point2.original_position.y)
        self.delete_segment(rectangle.segment2.point1.original_position.x, rectangle.segment2.point1.original_position.y, 
                                rectangle.segment2.point2.original_position.x, rectangle.segment2.point2.original_position.y)
        self.delete_segment(rectangle.segment3.point1.original_position.x, rectangle.segment3.point1.original_position.y, 
                                rectangle.segment3.point2.original_position.x, rectangle.segment3.point2.original_position.y)
        self.delete_segment(rectangle.segment4.point1.original_position.x, rectangle.segment4.point1.original_position.y, 
                                rectangle.segment4.point2.original_position.x, rectangle.segment4.point2.original_position.y)
        self.draw()

    @staticmethod
    def _get_unique_points(segments):
        # Flatten the list of points from each segment and extract the names
        points = [point for segment in segments for point in [segment.point1.name, segment.point2.name]]
        # Remove duplicates by converting the list to a set, then convert it back to a sorted list
        unique_points = sorted(set(points))
        return unique_points

    def _are_points_connected(self, list_of_point_names):
        # Iterate over all pairs of points
        for point_pair in combinations(list_of_point_names, 2):
            # Check if there's a segment connecting the pair
            if not any(self._segment_matches_point_names(segment, *point_pair) for segment in self.drawables.get('Segment', [])):
                return False
        return True

    def _create_new_triangles_from_connected_segments(self):
        # Segment indexing
        point_to_segments = defaultdict(list)
        for segment in self.drawables.get('Segment', []):
            for point in [segment.point1, segment.point2]:
                point_to_segments[point.name].append(segment)
        # Triangle existence check
        existing_triangles = set(triangle.name for triangle in self.drawables.get('Triangle', []))
        # Avoid unnecessary checks
        segments = list(self.drawables.get('Segment', []))
        for i in range(len(segments)):
            for j in range(i+1, len(segments)):
                for k in range(j+1, len(segments)):
                    s1, s2, s3 = segments[i], segments[j], segments[k]
                    # Get the unique points in the three segments
                    unique_points = self._get_unique_points([s1, s2, s3])
                    # If the segments share exactly three unique points, check if they form a triangle
                    if len(unique_points) == 3 and self._are_points_connected(unique_points):
                        # Create a triangle if it doesn't exist
                        triangle_name = ''.join(sorted(unique_points))
                        if triangle_name not in existing_triangles:
                            ps = [p.original_position for p in [self.get_point_by_name(point) for point in unique_points]]
                            new_triangle = Triangle(ps[0].x, ps[0].y,
                                                    ps[1].x, ps[1].y,
                                                    ps[2].x, ps[2].y,
                                                    canvas=self,
                                                    name=triangle_name)
                            self.add_drawable(new_triangle)
                            existing_triangles.add(triangle_name)

    def _split_canvas_segments_if_needed(self, x, y):
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            sp1, sp2 = segment.point1.original_position, segment.point2.original_position
            if Utilities.is_point_on_segment(x, y, sp1.x, sp1.y, sp2.x, sp2.y):
                # If the new point is either of the segment's endpoints, we don't need to create new segments
                if (x, y) != (sp1.x, sp1.y) and (x, y) != (sp2.x, sp2.y):
                    print(f"Splitting segment {segment.name} at {x}, {y}")
                    # Create new segments
                    segment1 = Segment(x, y, sp1.x, sp1.y, canvas=self)
                    segment2 = Segment(x, y, sp2.x, sp2.y, canvas=self)
                    segment.children.extend([segment1, segment2])
                    self.add_drawable(segment1)
                    self.add_drawable(segment2)

    def _create_drawables_from_new_connections(self):
        points = self.drawables.get('Point', [])
        for point in points:
            self._split_canvas_segments_if_needed(point.original_position.x, point.original_position.y)
        self._create_new_triangles_from_connected_segments()