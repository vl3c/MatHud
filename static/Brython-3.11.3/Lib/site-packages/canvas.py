from browser import document
from point import Position, Point
from math_geometry import Segment, Vector, Triangle, Rectangle
from cartesian_system_2axis import Cartesian2Axis
from drawable import DrawableNameGenerator
from collections import defaultdict

class Canvas:
    def __init__(self):
        self.drawables = {}
        self.name_generator = DrawableNameGenerator()
        math_viewport = document['math-svg'].getBoundingClientRect()
        self.width = math_viewport.width
        self.height = math_viewport.height
        self.center = Position(self.width / 2, self.height / 2)
        self.scale_factor = 1  # Default scale factor is 1 (no scaling)
        self.zoom_point = Position(0, 0)  # Default zoom point is at origin
        self.zoom_direction = 0  # Default zoom direction is 0 (no zoom)
        self.zoom_step = 0.1  # Default zoom step is 0.1 (10%)
        self.dragging = False
        self.offset = Position(0, 0)  # Default offset is 0
        self.cartesian2axis = Cartesian2Axis(self)
        self.cartesian2axis.origin = Point(x=0, y=0, canvas=self, name="o")
        self.cartesian2axis.draw()

    def add_drawable(self, drawable):
        drawable.canvas = self  # Set the drawable's canvas reference
        category = drawable.get_class_name()
        if category not in self.drawables:
            self.drawables[category] = []
        self.drawables[category].append(drawable)

    def draw(self, apply_zoom=False):
        svg_container = document["math-svg"]
        svg_container.clear()
        self._draw_cartesian(apply_zoom)
        for drawable in self.get_drawables():
            drawable.pan()
            if apply_zoom:
                drawable.zoom()
            drawable.draw()  # Draw each drawable
        self.offset = Position(0, 0)  # Reset the offset

    def _draw_cartesian(self, apply_zoom=False):
        self.cartesian2axis.pan()
        if apply_zoom:
            self.cartesian2axis.zoom()
        self.cartesian2axis.draw()

    def clear(self):
        for drawable in self.get_drawables():
            drawable.canvas = None  # Clear the drawable's canvas reference
        self.drawables = {}  # Clear the list of drawables

    def reset(self):
        self.scale_factor = 1
        self.offset = Position(0, 0)
        self.zoom_direction = 0
        for drawable in self.get_drawables():
            drawable.reset()
    
    def get_drawables(self):
        return [drawable for category in self.drawables for drawable in self.drawables[category]]
    
    def get_drawables_state(self):
        state_dict = {}
        for category, drawables in self.drawables.items():
            state_dict[category + 's'] = [drawable.get_state() for drawable in drawables]
        return state_dict
    
    def _point_matches_coords(self, point, x, y):
        return point.original_position.x == x and point.original_position.y == y

    def _segment_matches_coords(self, segment, x1, y1, x2, y2):
        return ((self._point_matches_coords(segment.point1, x1, y1) and self._point_matches_coords(segment.point2, x2, y2)) or
               (self._point_matches_coords(segment.point1, x2, y2) and self._point_matches_coords(segment.point2, x1, y1)))

    def _segment_has_point(self, segment, x, y):
            return self._point_matches_coords(segment.point1, x, y) or self._point_matches_coords(segment.point2, x, y)

    def _delete_point_dependencies(self, x, y):
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles.copy():
            if any(self._segment_has_point(segment, x, y) for segment in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                rectangles.remove(rectangle)
                self.name_generator.delete_rectangle_name(rectangle.name)
        triangles = self.drawables.get('Triangle', [])
        for triangle in triangles.copy():
            if any(self._segment_has_point(segment, x, y) for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                triangles.remove(triangle)
                self.name_generator.delete_triangle_name(triangle.name)
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            if self._segment_has_point(segment, x, y):
                self._delete_segment_dependencies(segment.point1.original_position.x, segment.point1.original_position.y, segment.point2.original_position.x, segment.point2.original_position.y)
                segments.remove(segment)
                self.name_generator.delete_segment_name(segment.name)
        vectors = self.drawables.get('Vector', [])
        for vector in vectors.copy():
            if self._segment_has_point(vector.segment, x, y):
                vectors.remove(vector)

    def _delete_segment_dependencies(self, x1, y1, x2, y2):
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles.copy():
            if any(self._segment_matches_coords(segment, x1, y1, x2, y2) for segment in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                rectangles.remove(rectangle)
                self.name_generator.delete_rectangle_name(rectangle.name)
        triangles = self.drawables.get('Triangle', [])
        for triangle in triangles.copy():
            if any(self._segment_matches_coords(segment, x1, y1, x2, y2) for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                triangles.remove(triangle)
                self.name_generator.delete_triangle_name(triangle.name)

    def get_point(self, x, y):
        points = self.drawables.get('Point', [])
        for point in points:
            if self._point_matches_coords(point, x, y):
                return point
        return None

    def create_point(self, x, y, name=""):
        point = self.get_point(x, y)
        if point and name != "":
            self.name_generator.delete_point_name(point.name)
            point.name = self.name_generator.get_unique_point_name(name)
        else:
            point = Point(x, y, canvas=self, name=name)
            self.add_drawable(point)
        self.draw()

    def delete_point(self, x, y):
        points = self.drawables.get('Point', [])
        for point in points.copy():
            if self._point_matches_coords(point, x, y):
                self._delete_point_dependencies(x, y)
                points.remove(point)
                self.name_generator.delete_point_name(point.name)
                self.draw()
                break
    
    def get_segment(self, x1, y1, x2, y2):
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            if self._segment_has_point(segment, x1, y1) and self._segment_has_point(segment, x2, y2):
                return segment
        return None

    def create_segment(self, x1, y1, x2, y2, name=""):
        existing_segment = self.get_segment(x1, y1, x2, y2)
        if existing_segment:
            return
        segment = Segment(x1, y1, x2, y2, canvas=self, name=name)
        self.add_drawable(segment)
        self._create_new_triangles_from_connected_segments()
        self.draw()

    def delete_segment(self, x1, y1, x2, y2):
        segment = self.get_segment(x1, y1, x2, y2)
        if segment:
            self._delete_segment_dependencies(x1, y1, x2, y2)
            self.drawables['Segment'].remove(segment)
            self.name_generator.delete_segment_name(segment.name)
            self.draw()

    def get_vector(self, x1, y1, x2, y2):
        vectors = self.drawables.get('Vector', [])
        for vector in vectors.copy():
            if self._segment_has_point(vector.segment, x1, y1) and self._segment_has_point(vector.segment, x2, y2):
                return vector
        return None

    def create_vector(self, origin_x, origin_y, tip_x, tip_y, name=""):
        existing_vector = self.get_vector(origin_x, origin_y, tip_x, tip_y)
        if existing_vector:
            return
        vector = Vector(origin_x, origin_y, tip_x, tip_y, canvas=self, name=name)
        self.add_drawable(vector)
        self.draw()

    def delete_vector(self, origin_x, origin_y, tip_x, tip_y,):
        vector = self.get_vector(origin_x, origin_y, tip_x, tip_y,)
        if vector:
            self.drawables['Vector'].remove(vector)
            self.draw()

    def get_triangle(self, x1, y1, x2, y2, x3, y3):
        triangles = self.drawables.get('Triangle', [])
        for drawable in triangles.copy():
            if all(self._segment_matches_coords(segment, x1, y1, x2, y2) or
                self._segment_matches_coords(segment, x1, y1, x3, y3) or
                self._segment_matches_coords(segment, x2, y2, x3, y3) for segment in [drawable.segment1, drawable.segment2, drawable.segment3]):
                return drawable
        return None

    def create_triangle(self, x1, y1, x2, y2, x3, y3, name=""):
        existing_triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if existing_triangle:
            return
        triangle = Triangle(x1, y1, x2, y2, x3, y3, canvas=self, name=name)
        self.add_drawable(triangle)
        self._create_new_triangles_from_connected_segments()
        self.draw()

    def delete_triangle(self, x1, y1, x2, y2, x3, y3):     
        triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if triangle:
            self.drawables['Triangle'].remove(triangle)
            self.name_generator.delete_triangle_name(triangle.name)
            self._delete_segment_dependencies(x1, y1, x2, y2)
            self._delete_segment_dependencies(x2, y2, x3, y3)
            self._delete_segment_dependencies(x3, y3, x1, y1)
            self.draw()

    def get_rectangle(self, diag_point_x, diag_point_y, opposite_diag_point_x, opposite_diag_point_y):
        rectangles = self.drawables.get('Rectangle', [])
        for drawable in rectangles.copy():
            if all(self._segment_matches_coords(segment, diag_point_x, diag_point_y, opposite_diag_point_x, opposite_diag_point_y) 
                for segment in [drawable.segment1, drawable.segment2, drawable.segment3, drawable.segment4]):
                return drawable
        return None

    def create_rectangle(self, px, py, opposite_px, opposite_py, name=""):
        existing_rectangle = self.get_rectangle(px, py, opposite_px, opposite_py)
        if existing_rectangle:
            return
        rectangle = Rectangle(px, py, opposite_px, opposite_py, canvas=self, name=name)
        self.add_drawable(rectangle)
        self._create_new_triangles_from_connected_segments()
        self.draw()

    def delete_rectangle(self, diag_point_x, diag_point_y, opposite_diag_point_x, opposite_diag_point_y):     
        rectangle = self.get_rectangle(diag_point_x, diag_point_y, opposite_diag_point_x, opposite_diag_point_y)
        if not rectangle:
            return
        self.drawables['Rectangle'].remove(rectangle)
        self.name_generator.delete_rectangle_name(rectangle.name)
        # delete dependencies for all 4 segments
        self._delete_segment_dependencies(rectangle.segment1.point1.x, rectangle.segment1.point1.y, rectangle.segment1.point2.x, rectangle.segment1.point2.y)
        self._delete_segment_dependencies(rectangle.segment2.point1.x, rectangle.segment2.point1.y, rectangle.segment2.point2.x, rectangle.segment2.point2.y)
        self._delete_segment_dependencies(rectangle.segment3.point1.x, rectangle.segment3.point1.y, rectangle.segment3.point2.x, rectangle.segment3.point2.y)
        self._delete_segment_dependencies(rectangle.segment4.point1.x, rectangle.segment4.point1.y, rectangle.segment4.point2.x, rectangle.segment4.point2.y)
        self.draw()

    @staticmethod
    def _get_unique_points(segments):
        # Flatten the list of points from each segment and extract the names
        points = [point for segment in segments for point in [segment.point1.name, segment.point2.name]]
        # Remove duplicates by converting the list to a set, then convert it back to a sorted list
        unique_points = sorted(set(points))
        return unique_points

    def _create_new_triangles_from_connected_segments(self):
        # Segment indexing
        point_to_segments = defaultdict(list)
        for segment in self.drawables.get('Segment', []):
            for point in [segment.point1, segment.point2]:
                point_to_segments[point.name].append(segment)
        # Triangle existence check
        existing_triangles = set(triangle.name for triangle in self.drawables.get('Triangle', []))
        # Avoid unnecessary checks
        segments = list(self.drawables.get('Segment', []))
        for i in range(len(segments)):
            for j in range(i+1, len(segments)):
                for k in range(j+1, len(segments)):
                    s1, s2, s3 = segments[i], segments[j], segments[k]
                    # Get the unique points in the three segments
                    unique_points = self._get_unique_points([s1, s2, s3])
                    # If the segments share exactly three unique points, they form a triangle
                    if len(unique_points) == 3:
                        # Create a triangle if it doesn't exist
                        triangle_name = ''.join(sorted(unique_points))
                        if triangle_name not in existing_triangles:
                            print(f"triangle name: {triangle_name}")
                            print(f"existing triangles: {existing_triangles}")
                            new_triangle = Triangle(s1.point1.original_position.x,
                                                    s1.point1.original_position.y,
                                                    s2.point1.original_position.x,
                                                    s2.point1.original_position.y,
                                                    s3.point1.original_position.x,
                                                    s3.point1.original_position.y,
                                                    canvas=self,
                                                    name=triangle_name)
                            self.add_drawable(new_triangle)
                            existing_triangles.add(triangle_name)