from browser import document
from geometry import Point, Position
from cartesian_system_2axis import Cartesian2Axis
from utils.math_utils import MathUtils
from utils.style_utils import StyleUtils
from utils.geometry_utils import GeometryUtils
from utils.computation_utils import ComputationUtils
from managers.undo_redo_manager import UndoRedoManager
from managers.drawable_manager import DrawableManager
from managers.transformations_manager import TransformationsManager


class Canvas:
    def __init__(self, width, height, draw_enabled=True):
        self.computations = []  # Store computation history
        self.width = width
        self.height = height
        self.center = Position(self.width / 2, self.height / 2)
        self.scale_factor = 1  # no scaling
        self.zoom_point = Position(0, 0)  # Default zoom point is at origin
        self.zoom_direction = 0  # no zoom
        self.zoom_step = 0.1  # 10% zoom step
        self.dragging = False
        self.offset = Position(0, 0)  # Default offset is 0
        self.cartesian2axis = Cartesian2Axis(self)
        self.cartesian2axis.origin = Point(x=0, y=0, canvas=self, name="o") # initializing a point requires a cartesian2axis object
        self.draw_enabled = draw_enabled
        
        # Add managers
        self.undo_redo_manager = UndoRedoManager(self)
        self.drawable_manager = DrawableManager(self)
        self.transformations_manager = TransformationsManager(self)
        
        if self.draw_enabled:
            self.cartesian2axis.draw()

    def add_drawable(self, drawable):
        drawable.canvas = self  # Set the drawable's canvas reference
        self.drawable_manager.drawables.add(drawable)

    def draw(self, apply_zoom=False):
        if not self.draw_enabled:
            return
        svg_container = document["math-svg"]
        svg_container.clear()
        self._draw_cartesian(apply_zoom)
        
        # Draw all drawables
        for drawable in self.drawable_manager.get_drawables():
            drawable.pan()
            if apply_zoom:
                drawable.zoom()
            drawable.draw()  # Draw each drawable
        self.offset = Position(0, 0)  # Reset the offset

    def _draw_cartesian(self, apply_zoom=False):
        self.cartesian2axis.pan()
        if apply_zoom:
            self.cartesian2axis.zoom()
        self.cartesian2axis.draw()

    def _fix_drawable_canvas_references(self):
        for drawable in self.drawable_manager.get_drawables():
            drawable.canvas = self

    def clear(self):
        """Clear all drawables"""
        self.archive()
        self.drawable_manager.drawables.clear()
        self.reset()

    def reset(self):
        """Reset the canvas to its initial state"""
        self.center = Position(self.width / 2, self.height / 2)
        self.scale_factor = 1
        self.offset = Position(0, 0)
        self.zoom_direction = 0
        self.dragging = False
        self.cartesian2axis.reset()
        for drawable in self.get_drawables():
            drawable.reset()
        self.draw()

    def archive(self):
        """Archive the current state for undo functionality"""
        self.undo_redo_manager.archive()

    def undo(self):
        """Restores the last archived state from the undo stack"""
        return self.undo_redo_manager.undo()

    def redo(self):
        """Restores the last undone state from the redo stack"""
        return self.undo_redo_manager.redo()

    def get_drawables(self):
        """Get all drawables as a flat list"""
        return self.drawable_manager.get_drawables()

    def get_drawables_state(self):
        return self.drawable_manager.drawables.get_state()

    def get_drawables_by_class_name(self, class_name):
        """Get drawables of a specific class name"""
        return self.drawable_manager.drawables.get_by_class_name(class_name)

    def get_cartesian2axis_state(self):
        return self.cartesian2axis.get_state()

    def get_canvas_state(self):
        state = self.get_drawables_state()
        cartesian_state = self.get_cartesian2axis_state()
        if cartesian_state is not None:
            state.update(cartesian_state)
        if self.computations:  # Add computations to state if they exist
            state["computations"] = self.computations
        return state

    def _delete_point_dependencies(self, x, y):
        # Delete the segments that contain the point
        rectangles = self.drawable_manager.drawables.Rectangles
        for rectangle in rectangles.copy():
            if any(MathUtils.segment_has_end_point(segment, x, y) for segment in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                self.drawable_manager.drawables.remove(rectangle)
                
        # Delete the triangles that contain the point
        triangles = self.drawable_manager.drawables.Triangles
        for triangle in triangles.copy():
            if any(MathUtils.segment_has_end_point(segment, x, y) for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                self.drawable_manager.drawables.remove(triangle)
        
        # Collect all segments that contain the point
        segments_to_delete = []
        segments = self.drawable_manager.drawables.Segments
        for segment in segments.copy():
            if MathUtils.segment_has_end_point(segment, x, y):
                segments_to_delete.append(segment)
        
        # Create a set of all parent segments that should be preserved
        segments_to_preserve = set()
        for segment in segments_to_delete:
            # Get all parents of this segment
            parents = self._get_segment_parents(segment)
            for parent in parents:
                if not MathUtils.segment_has_end_point(parent, x, y):
                    segments_to_preserve.add(parent)
        
        # Delete segments that contain the point, but not if they're in the preserve list
        for segment in segments_to_delete:
            if segment not in segments_to_preserve:
                p1x = segment.point1.original_position.x
                p1y = segment.point1.original_position.y
                p2x = segment.point2.original_position.x
                p2y = segment.point2.original_position.y
                self.delete_segment(p1x, p1y, p2x, p2y, 
                                   delete_children=True, delete_parents=False)
        
        # Delete the vectors that contain the point
        vectors = self.drawable_manager.drawables.Vectors
        for vector in vectors.copy():
            if MathUtils.segment_has_end_point(vector.segment, x, y):
                origin_x = vector.segment.point1.original_position.x
                origin_y = vector.segment.point1.original_position.y
                tip_x = vector.segment.point2.original_position.x
                tip_y = vector.segment.point2.original_position.y
                self.delete_vector(origin_x, origin_y, tip_x, tip_y)
                
        # Delete the circles that contain the point
        circles = self.drawable_manager.drawables.Circles
        for circle in circles.copy():
            if MathUtils.point_matches_coordinates(circle.center, x, y):
                self.delete_circle(circle.name)
                
        # Delete the ellipses that contain the point
        ellipses = self.drawable_manager.drawables.Ellipses
        for ellipse in ellipses.copy():
            if MathUtils.point_matches_coordinates(ellipse.center, x, y):
                self.delete_ellipse(ellipse.name)

    def _delete_segment_dependencies(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if not segment:
            return
            
        # Get all parents of this segment for proper relationship management
        parents = self._get_segment_parents(segment)
        
        # Recursively delete the segment's children
        if delete_children:
            self._delete_segment_children(segment)
            
        # If it's not part of a recursive call, delete the parents
        if delete_parents:
            self._delete_segment_parents(segment)
        else:
            # Just remove this segment from its parents
            for parent in parents:
                if segment in parent.children:
                    parent.children.remove(segment)
                    
        # Delete the segment's vectors
        self.delete_vector(x1, y1, x2, y2)
        self.delete_vector(x2, y2, x1, y1)
                    
        # Delete the rectangles that contain the segment
        rectangles = self.drawable_manager.drawables.Rectangles
        for rectangle in rectangles.copy():
            if any(MathUtils.segment_matches_coordinates(s, x1, y1, x2, y2) for s in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                self.drawable_manager.drawables.remove(rectangle)
              
        # Delete the triangles that contain the segment
        triangles = self.drawable_manager.drawables.Triangles
        for triangle in triangles.copy():
            if any(MathUtils.segment_matches_coordinates(s, x1, y1, x2, y2) for s in [triangle.segment1, triangle.segment2, triangle.segment3]):
                self.drawable_manager.drawables.remove(triangle)

    def get_point(self, x, y):
        """Get a point at the specified coordinates"""
        return self.drawable_manager.get_point(x, y)

    def get_point_by_name(self, name):
        """Get a point by its name"""
        return self.drawable_manager.get_point_by_name(name)

    def create_point(self, x, y, name="", extra_graphics=True):
        """Create a point at the specified coordinates"""
        return self.drawable_manager.create_point(x, y, name, extra_graphics)

    def delete_point(self, x, y):
        """Delete a point at the specified coordinates"""
        return self.drawable_manager.delete_point(x, y)

    def delete_point_by_name(self, name):
        """Delete a point by its name"""
        return self.drawable_manager.delete_point_by_name(name)

    def is_point_within_canvas_visible_area(self, x, y):
        """Check if a point is within the visible area of the canvas"""
        return (0 <= x <= self.width) and (0 <= y <= self.height)

    def get_segment_by_coordinates(self, x1, y1, x2, y2):
        """Get a segment by its endpoint coordinates"""
        return self.drawable_manager.get_segment_by_coordinates(x1, y1, x2, y2)

    def get_segment_by_name(self, name):
        """Get a segment by its name"""
        return self.drawable_manager.get_segment_by_name(name)

    def get_segment_by_points(self, p1, p2):
        """Get a segment by its endpoint points"""
        return self.drawable_manager.get_segment_by_points(p1, p2)

    def create_segment(self, x1, y1, x2, y2, name="", extra_graphics=True):
        """Create a segment between two points"""
        return self.drawable_manager.create_segment(x1, y1, x2, y2, name, extra_graphics)

    def delete_segment(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        """Delete a segment by its endpoint coordinates"""
        return self.drawable_manager.delete_segment(x1, y1, x2, y2, delete_children, delete_parents)

    def delete_segment_by_name(self, name, delete_children=True, delete_parents=False):
        """Delete a segment by its name"""
        return self.drawable_manager.delete_segment_by_name(name, delete_children, delete_parents)

    def any_segment_part_visible_in_canvas_area(self, x1, y1, x2, y2):
        """Check if any part of a segment is visible in the canvas area"""
        intersect_top = MathUtils.segments_intersect(x1, y1, x2, y2, 0, 0, self.width, 0)
        intersect_right = MathUtils.segments_intersect(x1, y1, x2, y2, self.width, 0, self.width, self.height)
        intersect_bottom = MathUtils.segments_intersect(x1, y1, x2, y2, self.width, self.height, 0, self.height)
        intersect_left = MathUtils.segments_intersect(x1, y1, x2, y2, 0, self.height, 0, 0)
        return intersect_top or intersect_right or intersect_bottom or intersect_left

    def get_vector(self, x1, y1, x2, y2):
        """Get a vector by its origin and tip coordinates"""
        return self.drawable_manager.get_vector(x1, y1, x2, y2)

    def create_vector(self, origin_x, origin_y, tip_x, tip_y, name="", extra_graphics=True):
        """Create a vector from origin to tip"""
        return self.drawable_manager.create_vector(origin_x, origin_y, tip_x, tip_y, name, extra_graphics)

    def delete_vector(self, origin_x, origin_y, tip_x, tip_y):
        """Delete a vector by its origin and tip coordinates"""
        return self.drawable_manager.delete_vector(origin_x, origin_y, tip_x, tip_y)

    def get_triangle(self, x1, y1, x2, y2, x3, y3):
        """Get a triangle by its vertex coordinates"""
        return self.drawable_manager.get_triangle(x1, y1, x2, y2, x3, y3)

    def create_triangle(self, x1, y1, x2, y2, x3, y3, name="", extra_graphics=True):
        """Create a triangle with the specified vertices"""
        return self.drawable_manager.create_triangle(x1, y1, x2, y2, x3, y3, name, extra_graphics)

    def delete_triangle(self, x1, y1, x2, y2, x3, y3):
        """Delete a triangle by its vertex coordinates"""
        return self.drawable_manager.delete_triangle(x1, y1, x2, y2, x3, y3)

    def get_rectangle_by_diagonal_points(self, px, py, opposite_px, opposite_py):
        """Get a rectangle by its diagonal points"""
        return self.drawable_manager.get_rectangle_by_diagonal_points(px, py, opposite_px, opposite_py)

    def get_rectangle_by_name(self, name):
        """Get a rectangle by its name"""
        return self.drawable_manager.get_rectangle_by_name(name)

    def create_rectangle(self, px, py, opposite_px, opposite_py, name="", extra_graphics=True):
        """Create a rectangle with the specified diagonal points"""
        return self.drawable_manager.create_rectangle(px, py, opposite_px, opposite_py, name, extra_graphics)

    def delete_rectangle(self, name):
        """Delete a rectangle by its name"""
        return self.drawable_manager.delete_rectangle(name)

    def get_circle(self, center_x, center_y, radius):
        """Get a circle by its center coordinates and radius"""
        return self.drawable_manager.get_circle(center_x, center_y, radius)

    def get_circle_by_name(self, name):
        """Get a circle by its name"""
        return self.drawable_manager.get_circle_by_name(name)

    def create_circle(self, center_x, center_y, radius, name="", extra_graphics=True):
        """Create a circle with the specified center and radius"""
        return self.drawable_manager.create_circle(center_x, center_y, radius, name, extra_graphics)

    def delete_circle(self, name):
        """Delete a circle by its name"""
        return self.drawable_manager.delete_circle(name)

    def get_ellipse(self, center_x, center_y, radius_x, radius_y):
        """Get an ellipse by its center coordinates and radii"""
        return self.drawable_manager.get_ellipse(center_x, center_y, radius_x, radius_y)

    def get_ellipse_by_name(self, name):
        """Get an ellipse by its name"""
        return self.drawable_manager.get_ellipse_by_name(name)

    def create_ellipse(self, center_x, center_y, radius_x, radius_y, rotation_angle=0, name="", extra_graphics=True):
        """Create an ellipse with the specified center, radii, and rotation"""
        return self.drawable_manager.create_ellipse(center_x, center_y, radius_x, radius_y, rotation_angle, name, extra_graphics)

    def delete_ellipse(self, name):
        """Delete an ellipse by its name"""
        return self.drawable_manager.delete_ellipse(name)

    def get_function(self, name):
        """Get a function by its name"""
        return self.drawable_manager.get_function(name)

    def draw_function(self, function_string, name, left_bound=None, right_bound=None):
        """Draw a function on the canvas"""
        return self.drawable_manager.draw_function(function_string, name, left_bound, right_bound)

    def delete_function(self, name):
        """Delete a function by its name"""
        return self.drawable_manager.delete_function(name)

    def _get_unique_point_names_from_segments(self, segments):
        return GeometryUtils.get_unique_point_names_from_segments(segments)

    def _is_fully_connected_graph(self, list_of_point_names):
        return GeometryUtils.is_fully_connected_graph(list_of_point_names, self.drawable_manager.drawables.Segments)

    def _create_new_triangles_from_connected_segments(self):
        segments = list(self.drawable_manager.drawables.Segments)
        for i in range(len(segments)):
            for j in range(i+1, len(segments)):
                for k in range(j+1, len(segments)):
                    s1, s2, s3 = segments[i], segments[j], segments[k]
                    # Get the unique points in the three segments
                    unique_points = self._get_unique_point_names_from_segments([s1, s2, s3])
                    # If the segments share exactly three unique points, check if they form a triangle
                    if len(unique_points) == 3 and self._is_fully_connected_graph(unique_points):
                        p1 = self.get_point_by_name(unique_points[0])
                        p2 = self.get_point_by_name(unique_points[1])
                        p3 = self.get_point_by_name(unique_points[2])
                        # Create a triangle if it doesn't exist
                        self.create_triangle(p1.original_position.x, p1.original_position.y, 
                                             p2.original_position.x, p2.original_position.y, 
                                             p3.original_position.x, p3.original_position.y, 
                                             extra_graphics=False)

    def _split_segments_with_point(self, x, y):
        segments = self.drawable_manager.drawables.Segments
        for segment in segments.copy():
            sp1, sp2 = segment.point1.original_position, segment.point2.original_position
            # If the new point is either of the segment's endpoints, we don't need to create new segments
            if (x, y) == (sp1.x, sp1.y) or (x, y) == (sp2.x, sp2.y):
                continue
            if MathUtils.is_point_on_segment(x, y, sp1.x, sp1.y, sp2.x, sp2.y):
                print(f"Splitting segment {segment.name} from ({sp1.x}, {sp1.y}) to ({sp2.x}, {sp2.y}) at {x}, {y}")
                # Create new segments
                segment1 = self.create_segment(x, y, sp1.x, sp1.y, extra_graphics=False) 
                segment2 = self.create_segment(x, y, sp2.x, sp2.y, extra_graphics=False)
                # Add segments to parents
                segment.children.add(segment1)
                segment.children.add(segment2)
                self._add_segment_to_parents(segment1)
                self._add_segment_to_parents(segment2)
                # Also have to add smaller segments to the new segment's children
                segment1.children = {c for c in self._find_segment_children(segment1)}
                segment2.children = {c for c in self._find_segment_children(segment2)}

    def _get_segment_parents(self, segment):
        parents = []
        segments = self.drawable_manager.drawables.Segments
        for s in segments:
            if segment in s.children:
                parents.append(s)
        return parents

    def _find_segment_children(self, segment):
        sp1, sp2 = segment.point1.original_position, segment.point2.original_position
        children = []
        segments = self.drawable_manager.drawables.Segments
        for s in segments:
            if s == segment:
                continue
            p1, p2 = s.point1.original_position, s.point2.original_position
            if MathUtils.is_point_on_segment(p1.x, p1.y, sp1.x, sp1.y, sp2.x, sp2.y) and MathUtils.is_point_on_segment(p2.x, p2.y, sp1.x, sp1.y, sp2.x, sp2.y):
                children.append(s)
        return children

    def _add_segment_to_parents(self, segment_to_add, current_parent=None):
        if current_parent is None:
            # Initially, find the direct parents of the segment to add
            parents = self._get_segment_parents(segment_to_add)
        else:
            # In recursive calls, work with the current parent's parents
            parents = self._get_segment_parents(current_parent)
        for parent in parents:
            # Add the segment to the current parent's children
            parent.children.add(segment_to_add)
            # Recursively add the segment to this parent's parents
            self._add_segment_to_parents(segment_to_add, parent)

    def _delete_segment_parents(self, segment):
        print(f"Deleting segment {segment.name} parents")
        parents = self._get_segment_parents(segment)
        for parent in parents:
            p1x = parent.point1.original_position.x
            p1y = parent.point1.original_position.y
            p2x = parent.point2.original_position.x
            p2y = parent.point2.original_position.y
            self.delete_segment(p1x, p1y, p2x, p2y, delete_children=True, delete_parents=True)

    def _delete_segment_children(self, segment):
        print(f"Deleting segment {segment.name} children")
        for child_segment in list(segment.children):
            # Check if this child has other parents
            all_parents = self._get_segment_parents(child_segment)
            # Only delete the child if this segment is its only parent
            if len(all_parents) <= 1:  # The only parent is the segment we're currently processing
                p1x = child_segment.point1.original_position.x
                p1y = child_segment.point1.original_position.y
                p2x = child_segment.point2.original_position.x
                p2y = child_segment.point2.original_position.y
                self.delete_segment(p1x, p1y, p2x, p2y, delete_children=True, delete_parents=False)
            else:
                # Just remove the current segment from the child's parents
                # The child will still exist and be associated with other parents
                if segment in all_parents:
                    segment.children.remove(child_segment)

    def _remove_segment_from_parents(self, segment_to_remove):
        segments = self.drawable_manager.drawables.Segments
        for s in segments:
            # If segment_to_remove is found in the children list of segment s, remove it
            if segment_to_remove in s.children:
                s.children.remove(segment_to_remove)

    def _create_drawables_from_new_connections(self):
        self._create_new_triangles_from_connected_segments()

    def translate_object(self, name, x_offset, y_offset):
        """Translates a drawable object by the specified offset"""
        return self.transformations_manager.translate_object(name, x_offset, y_offset)
        
    def rotate_object(self, name, angle):
        """Rotates a drawable object by the specified angle"""
        return self.transformations_manager.rotate_object(name, angle)

    def has_computation(self, expression):
        """Check if a computation with the given expression already exists."""
        return ComputationUtils.has_computation(self.computations, expression)

    def add_computation(self, expression, result):
        """Add a computation to the history if it doesn't already exist."""
        self.computations = ComputationUtils.add_computation(self.computations, expression, result)

    def find_largest_connected_shape(self, shape):
        """Find the largest shape that shares segments with the given shape.
        Returns a tuple (largest_parent_shape, shape_type) where shape_type is the class name
        or None if no larger shape is found."""
        if not shape:
            return None, None

        # Get all shapes from the canvas
        rectangles = self.drawable_manager.drawables.Rectangles
        triangles = self.drawable_manager.drawables.Triangles

        # If the shape is a rectangle, don't check for parent shapes
        if shape.get_class_name() == 'Rectangle':
            return None, None

        # Check rectangles first as they are larger
        for rect in rectangles:
            if rect != shape:  # Don't compare with itself
                shared_segs = self.get_shared_segments(shape, rect)
                if shared_segs:  # If any segments are shared with a rectangle, return it
                    return rect, rect.get_class_name()

        # Only check triangles if no rectangle was found and the shape isn't a triangle
        if shape.get_class_name() == 'Triangle':
            return None, None

        largest_parent_shape = None
        max_segments = 0

        for tri in triangles:
            if tri != shape:  # Don't compare with itself
                shared_segs = self.get_shared_segments(shape, tri)
                if shared_segs and len(shared_segs) > max_segments:
                    largest_parent_shape = tri
                    max_segments = len(shared_segs)

        return largest_parent_shape, largest_parent_shape.get_class_name() if largest_parent_shape else None

    def get_shared_segments(self, shape1, shape2):
        """Check if two shapes share any segments.
        Returns a list of shared segments."""
        shape1_segments = []
        shape2_segments = []

        # Get segments from shape1
        if hasattr(shape1, 'segment1'):
            shape1_segments.append(shape1.segment1)
        if hasattr(shape1, 'segment2'):
            shape1_segments.append(shape1.segment2)
        if hasattr(shape1, 'segment3'):
            shape1_segments.append(shape1.segment3)
        if hasattr(shape1, 'segment4'):
            shape1_segments.append(shape1.segment4)

        # Get segments from shape2
        if hasattr(shape2, 'segment1'):
            shape2_segments.append(shape2.segment1)
        if hasattr(shape2, 'segment2'):
            shape2_segments.append(shape2.segment2)
        if hasattr(shape2, 'segment3'):
            shape2_segments.append(shape2.segment3)
        if hasattr(shape2, 'segment4'):
            shape2_segments.append(shape2.segment4)

        # Find shared segments
        shared_segments = []
        for s1 in shape1_segments:
            for s2 in shape2_segments:
                if s1 == s2:
                    shared_segments.append(s1)

        return shared_segments

    def create_colored_area(self, drawable1_name, drawable2_name=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3):
        """Creates a colored area between two functions, two segments, or a function and a segment"""
        return self.drawable_manager.create_colored_area(drawable1_name, drawable2_name, left_bound, right_bound, color, opacity)
        
    def delete_colored_area(self, name):
        """Deletes a colored area with the given name"""
        return self.drawable_manager.delete_colored_area(name)
        
    def delete_colored_areas_for_function(self, func):
        """Deletes all colored areas associated with a function"""
        return self.drawable_manager.delete_colored_areas_for_function(func)
        
    def delete_colored_areas_for_segment(self, segment):
        """Deletes all colored areas associated with a segment"""
        return self.drawable_manager.delete_colored_areas_for_segment(segment)
        
    def get_colored_areas_for_drawable(self, drawable):
        """Gets all colored areas associated with a drawable (function or segment)"""
        return self.drawable_manager.get_colored_areas_for_drawable(drawable)
        
    def update_colored_area_style(self, name, color=None, opacity=None):
        """Updates the color and/or opacity of a colored area"""
        return self.drawable_manager.update_colored_area_style(name, color, opacity)

    def _validate_color_and_opacity(self, color, opacity):
        """Validates both color and opacity values"""
        return StyleUtils.validate_color_and_opacity(color, opacity)

    def _is_valid_css_color(self, color):
        """Validates if a string is a valid CSS color."""
        return StyleUtils.is_valid_css_color(color)

    def _validate_opacity(self, opacity):
        """Validates if an opacity value is between 0 and 1"""
        return StyleUtils.validate_opacity(opacity)

    @property
    def name_generator(self):
        """Property to access the name generator from the drawable manager"""
        return self.drawable_manager.name_generator

