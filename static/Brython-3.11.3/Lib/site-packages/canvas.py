from config import default_color, default_font_size
from browser import document, svg
from drawable import Drawable
from point import Point
from math_geometry import Segment, Triangle, Rectangle, Circle, Ellipse, Vector


class Canvas:
    def __init__(self):
        self.drawables = []
        self.scale_factor = 1  # Default scale factor is 1 (no scaling)
        self.zoom_point = Point(0, 0)  # Default zoom point is at origin
        self.offset = Point(0, 0)  # Default offset is 0
        self.zoom_direction = 0  # Default zoom direction is 0 (no zoom)
        self.zoom_step = 0.1  # Default zoom step is 0.1 (10%)
        self.cartesian2axis = Cartesian2Axis(canvas=self)
        self.add_drawable(self.cartesian2axis)

    def add_drawable(self, drawable):
        self.drawables.append(drawable)
        drawable.canvas = self  # Set the drawable's canvas reference

    def draw(self, apply_zoom=False):
        svg_container = document["math-svg"]
        svg_container.clear()
        for drawable in self.drawables:
            if apply_zoom:
                drawable.zoom()
            drawable.draw()  # Draw each drawable

    def clear(self):
        for drawable in self.drawables:
            drawable.canvas = None  # Clear the drawable's canvas reference
        self.drawables = []  # Clear the list of drawables

    def reset(self):
        self.scale_factor = 1
        self.offset = Point(0, 0)
        self.zoom_direction = 0
        for drawable in self.drawables:
            drawable.reset()


class Label(Drawable):
    def __init__(self, position, text, color=default_color, canvas=None, font_size=default_font_size):
        self.position = Point(position['x'], position['y'], color=color, canvas=canvas)
        self.text = text
        self.font_size = font_size
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.position.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def _initialize(self):
        self.position._initialize()

    def draw(self):
        x, y = self.position.x, self.position.y
        self.create_svg_element('text', x=str(x), y=str(y), fill=self.color, text_content=self.text, text_font_size=self.font_size)

    def _translate(self, offset):
        self.position._translate(offset)

    def _scale(self, factor):
        self.position._scale_coordinates(factor)

    def zoom(self):
        if self.canvas:
            self.position.zoom()


class Cartesian2Axis(Drawable):
    def __init__(self, color=default_color, canvas=None):
        math_viewport = document['math-svg'].getBoundingClientRect()
        self.width = math_viewport.width
        self.height = math_viewport.height
        self.origin = Point(self.width/2, self.height/2, color=color, canvas=canvas)
        self.tick_spacing = 50
        self.previous_tick_spacing = self.tick_spacing  # Track the previous tick spacing to determine zoom level
        self.tick_size = 3
        self.zoom_level = 0
        self.tick_color = color
        self.tick_label_color = "grey"
        self.tick_label_font_size = 8
        self.grid_color = "lightgrey"
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.origin.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def _initialize(self):
        self.origin._initialize()

    def draw(self):
        # Draw axes
        x_axis = Segment({"x": 0, "y": self.origin.y}, {"x": self.width, "y": self.origin.y}, self.color)
        x_axis.draw()
        y_axis = Segment({"x": self.origin.x, "y": 0}, {"x": self.origin.x, "y": self.height}, self.color)
        y_axis.draw()
        # Add labels for axes
        x_label = Label({"x": x_axis.point2.x - 10, "y": x_axis.point2.y + 10}, "x", self.color)
        x_label.draw()
        y_label = Label({"x": y_axis.point1.x + 2, "y": 10}, "y", self.color)
        y_label.draw()
        # Add spaced ticks on the axes
        display_tick_spacing  = self.tick_spacing * self.canvas.scale_factor * 2 ** (-self.zoom_level)
        # Draw ticks on axes
        self._draw_ticks(display_tick_spacing)
        # Draw grid
        self._draw_grid(display_tick_spacing / 2)

    def _draw_ticks(self, step):
        def draw_ticks(axis, step, direction):
            tick_mark = self.origin.x if axis == 'x' else self.origin.y
            boundary = self.width if axis == 'x' else self.height
            tick_size = self.tick_size
            go = lambda: (direction == 1 and tick_mark < boundary) or (direction == -1 and tick_mark > 0)
            while go():
                if axis == 'x':
                    tick = Segment({"x": tick_mark, "y": self.origin.y - tick_size}, {"x": tick_mark, "y": self.origin.y + tick_size}, self.color)
                    tick_label_text = str(round((tick_mark - self.origin.x) / (self.tick_spacing * self.canvas.scale_factor) * self.tick_spacing, 2))
                    tick_label = Label({"x": tick_mark + 2, "y": self.origin.y + tick_size + self.tick_label_font_size}, tick_label_text, color=self.tick_label_color, font_size=self.tick_label_font_size)
                else:
                    tick = Segment({"x": self.origin.x - tick_size, "y": tick_mark}, {"x": self.origin.x + tick_size, "y": tick_mark}, self.color)
                    tick_label_text = str(round((self.origin.y - tick_mark) / (self.tick_spacing * self.canvas.scale_factor) * self.tick_spacing, 2))
                    tick_label = Label({"x": self.origin.x + tick_size, "y": tick_mark - tick_size}, tick_label_text, color=self.tick_label_color, font_size=self.tick_label_font_size)
                tick.draw()
                tick_label.draw()
                tick_mark += step * direction
        for axis in ['x', 'y']:
            for direction in [-1, 1]:
                draw_ticks(axis, step, direction)

    def _draw_grid(self, step):
        def draw_grid_lines(axis, step, direction):
            grid_mark = self.origin.x if axis == 'x' else self.origin.y
            boundary = self.width if axis == 'x' else self.height
            go = lambda: (direction == 1 and grid_mark < boundary) or (direction == -1 and grid_mark > 0)

            while go():
                start_point = {"x": 0, "y": grid_mark} if axis == 'y' else {"x": grid_mark, "y": 0}
                end_point = {"x": self.width, "y": grid_mark} if axis == 'y' else {"x": grid_mark, "y": self.height}
                grid_line_segment = Segment(start_point, end_point, self.grid_color)
                grid_line_segment.draw()
                grid_mark += step * direction
        for axis in ['x', 'y']:
            for direction in [-1, 1]:
                draw_grid_lines(axis, step, direction)

    def _translate(self, offset):
        self.origin._translate(offset)

    def zoom(self):
        if self.canvas:
            # Calculate display tick spacing from zoom level and scale factor
            display_tick_spacing = self.tick_spacing * self.canvas.scale_factor * 2 ** (-self.zoom_level)
            # Check if the display tick spacing is outside the range [previous_tick_spacing / 2, previous_tick_spacing * 2]
            zoom_in = self.canvas.zoom_direction == -1
            if zoom_in and display_tick_spacing > self.previous_tick_spacing * 2:
                # Zooming in, and display tick spacing is more than twice the previous tick spacing
                self.zoom_level += 1
                self.previous_tick_spacing = self.tick_spacing
            elif not zoom_in and display_tick_spacing < self.previous_tick_spacing / 2:
                # Zooming out, and display tick spacing is less than half the previous tick spacing
                self.zoom_level -= 1
                self.previous_tick_spacing = self.tick_spacing
            self.origin.zoom()


# Map function names to functions
function_mapping = {
    'Point': Point,
    'Segment': Segment,
    'Triangle': Triangle,
    'Rectangle': Rectangle,
    'Circle': Circle,
    'Ellipse': Ellipse,
    'Vector': Vector,
    'Label': Label,
}