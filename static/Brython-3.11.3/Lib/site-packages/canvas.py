from browser import document
from cartesian_system_2axis import Cartesian2Axis
from expression_validator import ExpressionValidator
from itertools import combinations
from math_geometry import Segment, Vector, Triangle, Rectangle, Circle, Ellipse, Function
from math_util import MathUtil
from name_generator import DrawableNameGenerator
from point import Point
from position import Position
from datetime import datetime
import copy


class Canvas:
    def __init__(self, width, height, draw_enabled=True):
        self.drawables = {}
        self.undo_stack = []
        self.drawables_redo_stack = []
        self.computations = []  # Store computation history
        self.name_generator = DrawableNameGenerator(self)
        self.width = width
        self.height = height
        self.center = Position(self.width / 2, self.height / 2)
        self.scale_factor = 1  # no scaling
        self.zoom_point = Position(0, 0)  # Default zoom point is at origin
        self.zoom_direction = 0  # no zoom
        self.zoom_step = 0.1  # 10% zoom step
        self.dragging = False
        self.offset = Position(0, 0)  # Default offset is 0
        self.cartesian2axis = Cartesian2Axis(self)
        self.cartesian2axis.origin = Point(x=0, y=0, canvas=self, name="o") # initializing a point requires a cartesian2axis object
        self.draw_enabled = draw_enabled
        if self.draw_enabled:
            self.cartesian2axis.draw()

    def add_drawable(self, drawable):
        drawable.canvas = self  # Set the drawable's canvas reference
        category = drawable.get_class_name()
        if category not in self.drawables:
            self.drawables[category] = []
        self.drawables[category].append(drawable)

    def draw(self, apply_zoom=False):
        if not self.draw_enabled:
            return
        svg_container = document["math-svg"]
        svg_container.clear()
        self._draw_cartesian(apply_zoom)
        for drawable in self.get_drawables():
            drawable.pan()
            if apply_zoom:
                drawable.zoom()
            drawable.draw()  # Draw each drawable
        self.offset = Position(0, 0)  # Reset the offset

    def _draw_cartesian(self, apply_zoom=False):
        self.cartesian2axis.pan()
        if apply_zoom:
            self.cartesian2axis.zoom()
        self.cartesian2axis.draw()

    def _fix_drawable_canvas_references(self):
        for drawable in self.get_drawables():
            drawable.canvas = self

    def clear(self):
        self.archive()
        self.drawables = {}
        self.reset()

    def reset(self):
        self.center = Position(self.width / 2, self.height / 2)
        self.scale_factor = 1
        self.offset = Position(0, 0)
        self.zoom_direction = 0
        self.dragging = False
        self.cartesian2axis.reset()
        for drawable in self.get_drawables():
            drawable.reset()
        self.draw()

    def archive(self):
        """Archives the current state for undo operations."""
        archived_state = {
            'drawables': copy.deepcopy(self.drawables),
            'computations': copy.deepcopy(self.computations)  # Keep this for reference, even though we won't restore it
        }
        self.undo_stack.append(archived_state)

    def undo(self):
        """Restores the last archived state from the undo stack"""
        if not self.undo_stack:
            return
            
        # Get the last archived state
        last_state = self.undo_stack.pop()
        
        # Archive current state for redo
        current_state = {
            'drawables': copy.deepcopy(self.drawables),
            'computations': copy.deepcopy(self.computations)  # Keep this for reference, even though we won't restore it
        }
        self.drawables_redo_stack.append(current_state)
        
        # Restore only the drawables from the last state
        self.drawables = copy.deepcopy(last_state['drawables'])
        
        # Ensure all objects are properly initialized
        self._fix_drawable_canvas_references()
        
        self.draw()

    def redo(self):
        """Restores the last undone state from the redo stack"""
        if not self.drawables_redo_stack:
            return
            
        # Get the last undone state
        next_state = self.drawables_redo_stack.pop()
        
        # Archive current state for undo
        current_state = {
            'drawables': copy.deepcopy(self.drawables),
            'computations': copy.deepcopy(self.computations)  # Keep this for reference, even though we won't restore it
        }
        self.undo_stack.append(current_state)
        
        # Restore only the drawables from the next state
        self.drawables = copy.deepcopy(next_state['drawables'])
        
        # Ensure all objects are properly initialized
        self._fix_drawable_canvas_references()
        
        self.draw()

    def get_drawables(self):
        return [drawable for category in self.drawables for drawable in self.drawables[category]]

    def get_drawables_state(self):
        state_dict = {}
        for category, drawables in self.drawables.items():
            state_dict[category + 's'] = [drawable.get_state() for drawable in drawables]
        return state_dict

    def get_drawables_by_class_name(self, class_name):
        return self.drawables.get(class_name, [])

    def get_cartesian2axis_state(self):
        return self.cartesian2axis.get_state()

    def get_canvas_state(self):
        state = self.get_drawables_state()
        cartesian_state = self.get_cartesian2axis_state()
        if cartesian_state is not None:
            state.update(cartesian_state)
        if self.computations:  # Add computations to state if they exist
            state["computations"] = self.computations
        return state

    def _delete_point_dependencies(self, x, y):
        # Delete the segments that contain the point
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles.copy():
            if any(MathUtil.segment_has_end_point(segment, x, y) for segment in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                rectangles.remove(rectangle)
        # Delete the triangles that contain the point
        triangles = self.drawables.get('Triangle', [])
        for triangle in triangles.copy():
            if any(MathUtil.segment_has_end_point(segment, x, y) for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                triangles.remove(triangle)
        # Delete the segments that contains the point
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            if MathUtil.segment_has_end_point(segment, x, y):
                p1x = segment.point1.original_position.x
                p1y = segment.point1.original_position.y
                p2x = segment.point2.original_position.x
                p2y = segment.point2.original_position.y
                self.delete_segment(p1x, p1y, p2x, p2y,
                                    delete_children=True, delete_parents=False)
        # Delete the vectors that contain the point
        vectors = self.drawables.get('Vector', [])
        for vector in vectors.copy():
            if MathUtil.segment_has_end_point(vector.segment, x, y):
                origin_x = vector.segment.point1.original_position.x
                origin_y = vector.segment.point1.original_position.y
                tip_x = vector.segment.point2.original_position.x
                tip_y = vector.segment.point2.original_position.y
                self.delete_vector(origin_x, origin_y, tip_x, tip_y)
        # Delete the circles that contain the point
        circles = self.drawables.get('Circle', [])
        for circle in circles.copy():
            if MathUtil.point_matches_coordinates(circle.center, x, y):
                self.delete_circle(circle.name)
        # Delete the ellipses that contain the point
        ellipses = self.drawables.get('Ellipse', [])
        for ellipse in ellipses.copy():
            if MathUtil.point_matches_coordinates(ellipse.center, x, y):
                self.delete_ellipse(ellipse.name)

    def _delete_segment_dependencies(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if not segment:
            return
        # Recursively delete the segment's children
        if delete_children:
            self._delete_segment_children(segment)
        # If it's not part of a recursive call, delete the parents
        if delete_parents:
            self._delete_segment_parents(segment)
        # Delete the segment's vectors
        self.delete_vector(x1, y1, x2, y2)
        self.delete_vector(x2, y2, x1, y1)
        # Delete the rectangles that contain the segment
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles.copy():
            if any(MathUtil.segment_matches_coordinates(segment, x1, y1, x2, y2) for segment in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                rectangles.remove(rectangle)
        # Delete the triangles that contain the segment
        triangles = self.drawables.get('Triangle', [])
        for triangle in triangles.copy():
            if any(MathUtil.segment_matches_coordinates(segment, x1, y1, x2, y2) for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                triangles.remove(triangle)

    def get_point(self, x, y):
        points = self.drawables.get('Point', [])
        for point in points:
            if MathUtil.point_matches_coordinates(point, x, y):
                return point
        return None

    def get_point_by_name(self, name):
        points = self.drawables.get('Point', [])
        for point in points:
            if point.name == name:
                return point
        return None

    def create_point(self, x, y, name="", extra_graphics=True):
        point = self.get_point(x, y)
        if point:
            return point
        # Create new point
        name = self.name_generator.generate_point_name(name)
        point = Point(x, y, canvas=self, name=name)
        self.add_drawable(point)
        if extra_graphics:
            self._split_segments_with_point(x, y)
            self._create_drawables_from_new_connections()
        self.draw()
        return point

    def delete_point(self, x, y):
        point = self.get_point(x, y)
        if point:
            self.archive()  # Archive before deletion
            self._delete_point_dependencies(x, y)
            self.drawables.get('Point', []).remove(point)
            self.draw()

    def delete_point_by_name(self, name):
        """Deletes a point with the given name"""
        point = self.get_point_by_name(name)
        if point:
            self.archive()  # Archive before deletion
            self._delete_point_dependencies(point.original_position.x, point.original_position.y)
            if 'Point' in self.drawables:
                self.drawables['Point'].remove(point)
            self.draw()

    def is_point_within_canvas_visible_area(self, x, y):
        return 0 <= x <= self.width and 0 <= y <= self.height

    def get_segment_by_coordinates(self, x1, y1, x2, y2):
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            if MathUtil.segment_has_end_point(segment, x1, y1) and MathUtil.segment_has_end_point(segment, x2, y2):
                return segment
        return None

    def get_segment_by_name(self, name):
        """Gets a segment with the given name"""
        segments = self.drawables.get('Segment', [])
        for segment in segments:
            if segment.name == name:
                return segment
        return None

    def get_segment_by_points(self, p1, p2):
        return self.get_segment_by_coordinates(p1.original_position.x, p1.original_position.y, p2.original_position.x, p2.original_position.y)

    def create_segment(self, x1, y1, x2, y2, name="", extra_graphics=True):
        existing_segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if existing_segment:
            return existing_segment
        # Create new segment
        p1 = self.create_point(x1, y1, extra_graphics=False)
        p2 = self.create_point(x2, y2, extra_graphics=False)
        segment = Segment(p1, p2, canvas=self)
        self.add_drawable(segment)
        if extra_graphics:
            self._create_drawables_from_new_connections()
        self.draw()
        return segment

    def delete_segment(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if segment:
            self.archive()  # Archive before deletion
            print(f"Deleting segment {segment.name}")
            self._delete_segment_dependencies(x1, y1, x2, y2, delete_children, delete_parents)
            self._remove_segment_from_parents(segment)
            self.drawables['Segment'].remove(segment)
            self.draw()

    def delete_segment_by_name(self, name):
        """Deletes a segment with the given name"""
        segment = self.get_segment_by_name(name)
        if segment:
            self.archive()  # Archive before deletion
            x1, y1 = segment.point1.original_position.x, segment.point1.original_position.y
            x2, y2 = segment.point2.original_position.x, segment.point2.original_position.y
            self._delete_segment_dependencies(x1, y1, x2, y2, True, False)
            self._remove_segment_from_parents(segment)
            if 'Segment' in self.drawables:
                self.drawables['Segment'].remove(segment)
            self.draw()

    def any_segment_part_visible_in_canvas_area(self, x1, y1, x2, y2):
        intersect_top = MathUtil.segments_intersect(x1, y1, x2, y2, 0, 0, self.width, 0)
        intersect_right = MathUtil.segments_intersect(x1, y1, x2, y2, self.width, 0, self.width, self.height)
        intersect_bottom = MathUtil.segments_intersect(x1, y1, x2, y2, self.width, self.height, 0, self.height)
        intersect_left = MathUtil.segments_intersect(x1, y1, x2, y2, 0, self.height, 0, 0)
        return intersect_top or intersect_right or intersect_bottom or intersect_left

    def get_vector(self, x1, y1, x2, y2):
        vectors = self.drawables.get('Vector', [])
        for vector in vectors.copy():
            if MathUtil.segment_has_end_point(vector.segment, x1, y1) and MathUtil.segment_has_end_point(vector.segment, x2, y2):
                return vector
        return None

    def create_vector(self, origin_x, origin_y, tip_x, tip_y, name="", extra_graphics=True):
        existing_vector = self.get_vector(origin_x, origin_y, tip_x, tip_y)
        if existing_vector:
            return existing_vector
        # Create new vector
        origin = self.create_point(origin_x, origin_y, extra_graphics=False)
        tip = self.create_point(tip_x, tip_y, extra_graphics=False)
        vector = Vector(origin, tip, canvas=self)
        self.add_drawable(vector)
        if extra_graphics:
            self._create_drawables_from_new_connections()
        self.draw()
        return vector

    def delete_vector(self, origin_x, origin_y, tip_x, tip_y):
        vector = self.get_vector(origin_x, origin_y, tip_x, tip_y,)
        if vector:
            self.drawables['Vector'].remove(vector)
            self.draw()

    def get_triangle(self, x1, y1, x2, y2, x3, y3):
        triangles = self.drawables.get('Triangle', [])
        for drawable in triangles.copy():
            if all(MathUtil.segment_matches_coordinates(segment, x1, y1, x2, y2) or
                MathUtil.segment_matches_coordinates(segment, x1, y1, x3, y3) or
                MathUtil.segment_matches_coordinates(segment, x2, y2, x3, y3) for segment in [drawable.segment1, drawable.segment2, drawable.segment3]):
                return drawable
        return None

    def create_triangle(self, x1, y1, x2, y2, x3, y3, name="", extra_graphics=True):
        existing_triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if existing_triangle:
            return existing_triangle
        s1 = self.create_segment(x1, y1, x2, y2, extra_graphics=False)
        s2 = self.create_segment(x2, y2, x3, y3, extra_graphics=False)
        s3 = self.create_segment(x3, y3, x1, y1, extra_graphics=False)
        triangle = Triangle(s1, s2, s3, canvas=self)
        self.add_drawable(triangle)
        if extra_graphics:
            self._create_drawables_from_new_connections()
        self.draw()
        print(f"Created triangle: {triangle.name}")    # DEBUG
        return triangle

    def delete_triangle(self, x1, y1, x2, y2, x3, y3):     
        triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if not triangle:
            return
        self.drawables['Triangle'].remove(triangle)
        self.delete_segment(x1, y1, x2, y2)
        self.delete_segment(x2, y2, x3, y3)
        self.delete_segment(x3, y3, x1, y1)
        self.draw()

    def get_rectangle_by_diagonal_points(self, px, py, opposite_px, opposite_py):
        rectangles = self.drawables.get('Rectangle', [])
        # Calculate the coordinates of the other two corners based on the diagonal points
        corner1 = (px, py)
        corner2 = (opposite_px, py)
        corner3 = (opposite_px, opposite_py)
        corner4 = (px, opposite_py)
        # Iterate over all rectangles
        for drawable in rectangles:
            segments = [drawable.segment1, drawable.segment2, drawable.segment3, drawable.segment4]
            rectangle_corners = [(segment.point1.original_position.x, segment.point1.original_position.y) for segment in segments]
            # Ensuring all corners are matched, considering rectangles could be defined in any direction
            if all(corner in rectangle_corners for corner in [corner1, corner2, corner3, corner4]):
                return drawable
        return None

    def get_rectangle_by_name(self, name):
        rectangles = self.drawables.get('Rectangle', [])
        for rectangle in rectangles:
            if rectangle.name == name:
                return rectangle
        return None

    def create_rectangle(self, px, py, opposite_px, opposite_py, name="", extra_graphics=True):
        # Check if the rectangle already exists
        existing_rectangle = self.get_rectangle_by_diagonal_points(px, py, opposite_px, opposite_py)
        if existing_rectangle:
            return existing_rectangle
        # Create or retrieve the segments of the rectangle
        s1 = self.create_segment(px, py, opposite_px, py, extra_graphics=False)
        s2 = self.create_segment(opposite_px, py, opposite_px, opposite_py, extra_graphics=False)
        s3 = self.create_segment(opposite_px, opposite_py, px, opposite_py, extra_graphics=False)
        s4 = self.create_segment(px, opposite_py, px, py, extra_graphics=False)
        # Create the rectangle with the segments
        rectangle = Rectangle(s1, s2, s3, s4, canvas=self)
        self.add_drawable(rectangle)
        if extra_graphics:
            self._create_drawables_from_new_connections()
        self.draw()
        return rectangle

    def delete_rectangle(self, name):
        rectangle = self.get_rectangle_by_name(name)
        if not rectangle:
            return
        self.drawables['Rectangle'].remove(rectangle)
        # delete all 4 segments
        self.delete_segment(rectangle.segment1.point1.original_position.x, rectangle.segment1.point1.original_position.y, 
                                rectangle.segment1.point2.original_position.x, rectangle.segment1.point2.original_position.y)
        self.delete_segment(rectangle.segment2.point1.original_position.x, rectangle.segment2.point1.original_position.y, 
                                rectangle.segment2.point2.original_position.x, rectangle.segment2.point2.original_position.y)
        self.delete_segment(rectangle.segment3.point1.original_position.x, rectangle.segment3.point1.original_position.y, 
                                rectangle.segment3.point2.original_position.x, rectangle.segment3.point2.original_position.y)
        self.delete_segment(rectangle.segment4.point1.original_position.x, rectangle.segment4.point1.original_position.y, 
                                rectangle.segment4.point2.original_position.x, rectangle.segment4.point2.original_position.y)
        self.draw()

    def get_circle(self, center_x, center_y, radius):
        circles = self.drawables.get('Circle', [])
        for circle in circles:
            if circle.center.original_position.x == center_x and circle.center.original_position.y == center_y and circle.radius == radius:
                return circle
        return None

    def get_circle_by_name(self, name):
        circles = self.drawables.get('Circle', [])
        for circle in circles:
            if circle.name == name:
                return circle
        return None

    def create_circle(self, center_x, center_y, radius, name="", extra_graphics=True):
        existing_circle = self.get_circle(center_x, center_y, radius)
        if existing_circle:
            return existing_circle
        center = self.create_point(center_x, center_y, extra_graphics=False)
        circle = Circle(center, radius, canvas=self)
        self.add_drawable(circle)
        if extra_graphics:
            self._create_drawables_from_new_connections()
        self.draw()
        return circle

    def delete_circle(self, name):
        circle = self.get_circle_by_name(name)
        if not circle:
            return
        self.drawables['Circle'].remove(circle)
        self.draw()

    def get_ellipse(self, center_x, center_y, radius_x, radius_y):
        ellipses = self.drawables.get('Ellipse', [])
        for ellipse in ellipses:
            if ellipse.center.original_position.x == center_x and \
               ellipse.center.original_position.y == center_y and \
               ellipse.radius_x == radius_x and \
               ellipse.radius_y == radius_y:
                return ellipse
        return None

    def get_ellipse_by_name(self, name):
        ellipses = self.drawables.get('Ellipse', [])
        for ellipse in ellipses:
            if ellipse.name == name:
                return ellipse
        return None

    def create_ellipse(self, center_x, center_y, radius_x, radius_y, rotation_angle=0, name="", extra_graphics=True):
        existing_ellipse = self.get_ellipse(center_x, center_y, radius_x, radius_y)
        if existing_ellipse:
            return existing_ellipse
        center = self.create_point(center_x, center_y, extra_graphics=False)
        ellipse = Ellipse(center, radius_x, radius_y, canvas=self, rotation_angle=rotation_angle)
        self.add_drawable(ellipse)
        if extra_graphics:
            self._create_drawables_from_new_connections()
        self.draw()
        return ellipse

    def delete_ellipse(self, name):
        ellipse = self.get_ellipse_by_name(name)
        if not ellipse:
            return
        self.drawables['Ellipse'].remove(ellipse)
        self.draw()

    def get_function(self, name):
        functions = self.drawables.get('Function', [])
        for function in functions:
            if function.name == name:
                return function
        return None

    def draw_function(self, function_string, name, left_bound=None, right_bound=None):
        # Check if a function with the given name already exists
        existing_function = self.get_function(name)
        if existing_function:
            # Update the existing function's string and redraw it
            try:
                existing_function.function_string = ExpressionValidator.fix_math_expression(function_string)
                existing_function.function = ExpressionValidator.parse_function_string(function_string, use_mathjs=False)
            except Exception as e:
                raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
            # Update the bounds
            existing_function.left_bound = left_bound
            existing_function.right_bound = right_bound
            self.draw()
            return existing_function
        else:
            name = self.name_generator.generate_function_name(name)
            function = Function(function_string, self, name=name, left_bound=left_bound, right_bound=right_bound)
            self.add_drawable(function)
            self.draw()
            return function

    def delete_function(self, name):
        function = self.get_function(name)
        if not function:
            return
        self.drawables['Function'].remove(function)
        self.draw()

    def _get_unique_point_names_from_segments(self, segments):
        # Flatten the list of points from each segment and extract the names
        points = [point for segment in segments for point in [segment.point1.name, segment.point2.name]]
        # Remove duplicates by converting the list to a set, then convert it back to a sorted list
        unique_points = sorted(set(points))
        return unique_points

    def _is_fully_connected_graph(self, list_of_point_names):
        # Iterate over all pairs of points
        for point_pair in combinations(list_of_point_names, 2):
            # Check if there's a segment connecting the pair
            if not any(MathUtil.segment_matches_point_names(segment, *point_pair) for segment in self.drawables.get('Segment', [])):
                return False
        return True

    def _create_new_triangles_from_connected_segments(self):
        segments = list(self.drawables.get('Segment', []))
        for i in range(len(segments)):
            for j in range(i+1, len(segments)):
                for k in range(j+1, len(segments)):
                    s1, s2, s3 = segments[i], segments[j], segments[k]
                    # Get the unique points in the three segments
                    unique_points = self._get_unique_point_names_from_segments([s1, s2, s3])
                    # If the segments share exactly three unique points, check if they form a triangle
                    if len(unique_points) == 3 and self._is_fully_connected_graph(unique_points):
                        p1 = self.get_point_by_name(unique_points[0])
                        p2 = self.get_point_by_name(unique_points[1])
                        p3 = self.get_point_by_name(unique_points[2])
                        # Create a triangle if it doesn't exist
                        self.create_triangle(p1.original_position.x, p1.original_position.y, 
                                             p2.original_position.x, p2.original_position.y, 
                                             p3.original_position.x, p3.original_position.y, 
                                             extra_graphics=False)

    def _split_segments_with_point(self, x, y):
        segments = self.drawables.get('Segment', [])
        for segment in segments.copy():
            sp1, sp2 = segment.point1.original_position, segment.point2.original_position
            # If the new point is either of the segment's endpoints, we don't need to create new segments
            if (x, y) == (sp1.x, sp1.y) or (x, y) == (sp2.x, sp2.y):
                return
            if MathUtil.is_point_on_segment(x, y, sp1.x, sp1.y, sp2.x, sp2.y):
                print(f"Splitting segment {segment.name} from ({sp1.x}, {sp1.y}) to ({sp2.x}, {sp2.y}) at {x}, {y}")
                # Create new segments
                segment1 = self.create_segment(x, y, sp1.x, sp1.y, extra_graphics=False) 
                segment2 = self.create_segment(x, y, sp2.x, sp2.y, extra_graphics=False)
                # Add segments to parents
                segment.children.add(segment1)
                segment.children.add(segment2)
                self._add_segment_to_parents(segment1)
                self._add_segment_to_parents(segment2)
                # Also have to add smaller segments to the new segment's children
                segment1.children = {c for c in self._find_segment_children(segment1)}
                segment2.children = {c for c in self._find_segment_children(segment2)}

    def _get_segment_parents(self, segment):
        parents = []
        segments = self.drawables.get('Segment', [])
        for s in segments:
            if segment in s.children:
                parents.append(s)
        return parents

    def _find_segment_children(self, segment):
        sp1, sp2 = segment.point1.original_position, segment.point2.original_position
        children = []
        segments = self.drawables.get('Segment', [])
        for s in segments:
            if s == segment:
                continue
            p1, p2 = s.point1.original_position, s.point2.original_position
            if MathUtil.is_point_on_segment(p1.x, p1.y, sp1.x, sp1.y, sp2.x, sp2.y) and MathUtil.is_point_on_segment(p2.x, p2.y, sp1.x, sp1.y, sp2.x, sp2.y):
                children.append(s)
        return children

    def _add_segment_to_parents(self, segment_to_add, current_parent=None):
        if current_parent is None:
            # Initially, find the direct parents of the segment to add
            parents = self._get_segment_parents(segment_to_add)
        else:
            # In recursive calls, work with the current parent's parents
            parents = self._get_segment_parents(current_parent)
        for parent in parents:
            # Add the segment to the current parent's children
            parent.children.add(segment_to_add)
            # Recursively add the segment to this parent's parents
            self._add_segment_to_parents(segment_to_add, parent)

    def _delete_segment_parents(self, segment):
        print(f"Deleting segment {segment.name} parents")
        parents = self._get_segment_parents(segment)
        for parent in parents:
            p1x = parent.point1.original_position.x
            p1y = parent.point1.original_position.y
            p2x = parent.point2.original_position.x
            p2y = parent.point2.original_position.y
            self.delete_segment(p1x, p1y, p2x, p2y, delete_children=True, delete_parents=True)

    def _delete_segment_children(self, segment):
        print(f"Deleting segment {segment.name} children")
        for child_segment in list(segment.children):
            p1x = child_segment.point1.original_position.x
            p1y = child_segment.point1.original_position.y
            p2x = child_segment.point2.original_position.x
            p2y = child_segment.point2.original_position.y
            self.delete_segment(p1x, p1y, p2x, p2y, delete_children=True, delete_parents=False)

    def _remove_segment_from_parents(self, segment_to_remove):
        segments = self.drawables.get('Segment', [])
        for s in segments:
            # If segment_to_remove is found in the children list of segment s, remove it
            if segment_to_remove in s.children:
                s.children.remove(segment_to_remove)

    def _create_drawables_from_new_connections(self):
        self._create_new_triangles_from_connected_segments()

    def translate_object(self, name, x_offset, y_offset):
        # Find the drawable first to validate it exists
        drawable = None
        for category in self.drawables:
            for d in self.drawables[category]:
                if d.name == name:
                    drawable = d
                    break
            if drawable:
                break
        
        if not drawable:
            raise ValueError(f"No drawable found with name '{name}'")
            
        # Archive current state for undo/redo AFTER finding the object but BEFORE modifying it
        self.archive()
        
        # Apply translation using the drawable's translate method
        drawable.translate(x_offset, y_offset)
        
        # Redraw the canvas
        self.draw()

    def rotate_object(self, name, angle):
        # Find the drawable first to validate it exists
        drawable = None
        for category in self.drawables:
            if category in ['Function', 'Point', 'Circle']:
                continue
            for d in self.drawables[category]:
                if d.name == name:
                    drawable = d
                    break
            if drawable:
                break
        if not drawable:
            raise ValueError(f"No drawable found with name '{name}'")
        
        # Archive current state for undo/redo AFTER finding the object but BEFORE modifying it
        self.archive()
        
        # Apply rotation using the drawable's rotate method
        drawable.rotate(angle)

        # Redraw the canvas
        self.draw()

    def has_computation(self, expression):
        """Check if a computation with the given expression already exists."""
        return any(comp["expression"] == expression for comp in self.computations)

    def add_computation(self, expression, result):
        """Add a computation to the history if it doesn't already exist."""
        if not self.has_computation(expression):
            self.computations.append({
                "expression": expression,
                "result": result
            })

