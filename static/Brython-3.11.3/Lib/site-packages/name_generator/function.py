import re
from itertools import count
from .base import NameGenerator


class FunctionNameGenerator(NameGenerator):
    """Specialized generator for function names."""
    
    def _extract_number_suffix(self, func_name):
        """Extract a numeric suffix from a function name if present."""
        match = re.search(r'(?<=\w)(\d+)$', func_name)
        if match:
            number = int(match.group())
            prefix = func_name[:match.start()]
            return prefix, number
        return func_name, None
    
    def _increment_function_name(self, func_name):
        """Increment a function name by adding or incrementing a number suffix."""
        func_name = self.filter_string(func_name)
        
        prefix, number = self._extract_number_suffix(func_name)
        
        if number is not None:
            return prefix + str(number + 1)
        else:
            return func_name + '1'
    
    def _try_function_name(self, letter, number, existing_names):
        """Try a function name with the given letter and number."""
        func_name = f"{letter}{number if number > 0 else ''}"
        if func_name not in existing_names:
            return func_name
        return None
    
    def _generate_unique_function_name(self):
        """Generate a unique function name using alphabetical sequence."""
        func_alphabet = 'fghijklmnopqrstuvwxyzabcde'
        function_names = self.get_drawable_names('Function')
        
        for number in count():
            for letter in func_alphabet:
                name = self._try_function_name(letter, number, function_names)
                if name:
                    return name
                    
        raise ValueError("All function names are taken")
    
    def _extract_function_name_before_parenthesis(self, preferred_name):
        """Extract the function name before any parenthesis."""
        match = re.search(r'(?<=\w)(?=\()', preferred_name)
        if match:
            return preferred_name[:match.start()]
        return preferred_name
    
    def _find_available_function_name(self, preferred_name, function_names):
        """Find an available function name based on the preferred name."""
        if preferred_name not in function_names:
            return preferred_name
            
        # Try incrementing until we find an available name
        current_name = preferred_name
        while True:
            current_name = self._increment_function_name(current_name)
            if current_name not in function_names:
                return current_name
    
    def generate_function_name(self, preferred_name):
        """Generate a unique function name, using preferred_name if possible."""
        if not preferred_name:
            return self._generate_unique_function_name()
            
        function_names = self.get_drawable_names('Function')
        
        # Extract name before parenthesis if present
        clean_name = self._extract_function_name_before_parenthesis(preferred_name)
        
        # Find an available function name
        return self._find_available_function_name(clean_name, function_names)

    def reset_state(self):
        """Reset any internal state for function naming (if any in the future)."""
        # No complex state like used_letters_from_names currently, but good to have for consistency.
        pass 