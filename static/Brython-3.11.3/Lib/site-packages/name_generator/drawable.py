from .point import PointNameGenerator
from .function import FunctionNameGenerator


class DrawableNameGenerator:
    """Main class that orchestrates the generation of various drawable names."""
    
    def __init__(self, canvas):
        self.canvas = canvas
        self.used_letters_from_names = {}  # Maintain for backward compatibility
        
        # Initialize specialized generators
        self.point_generator = PointNameGenerator(canvas)
        self.function_generator = FunctionNameGenerator(canvas)
    
    def print_names(self):
        """Print all drawable names by category."""
        print(f"Point names: {self.get_drawable_names('Point')}")
        print(f"Segment names: {self.get_drawable_names('Segment')}")
        print(f"Triangle names: {self.get_drawable_names('Triangle')}")
        print(f"Rectangle names: {self.get_drawable_names('Rectangle')}")
        print(f"Circle names: {self.get_drawable_names('Circle')}")
        print(f"Ellipse names: {self.get_drawable_names('Ellipse')}")
        print(f"Function names: {self.get_drawable_names('Function')}")
    
    # Delegate methods to specialized generators or base NameGenerator
    
    def get_drawable_names(self, class_name):
        """Get sorted list of names for drawables of a specific class."""
        drawables = self.canvas.get_drawables_by_class_name(class_name)
        drawable_names = sorted([drawable.name for drawable in drawables])
        return drawable_names
    
    def filter_string(self, name):
        """Filter a string to keep only letters, apostrophes, digits, and parentheses."""
        return self.point_generator.filter_string(name)
    
    def split_point_names(self, expression, n=2):
        """Split a point expression into individual point names."""
        # Update our internal tracker for backward compatibility
        result = self.point_generator.split_point_names(expression, n)
        if expression and expression in self.point_generator.used_letters_from_names:
            self.used_letters_from_names[expression] = self.point_generator.used_letters_from_names[expression]
        return result
    
    def _generate_unique_point_name(self):
        """Generate a unique point name using alphabetical sequence with apostrophes."""
        return self.point_generator._generate_unique_point_name()
    
    def generate_point_name(self, preferred_name):
        """Generate a unique point name, using preferred_name if possible."""
        # Update our internal tracker for backward compatibility
        result = self.point_generator.generate_point_name(preferred_name)
        if preferred_name and preferred_name in self.point_generator.used_letters_from_names:
            self.used_letters_from_names[preferred_name] = self.point_generator.used_letters_from_names[preferred_name]
        return result
    
    def _increment_function_name(self, func_name):
        """Increment a function name by adding or incrementing a number suffix."""
        return self.function_generator._increment_function_name(func_name)
    
    def _generate_unique_function_name(self):
        """Generate a unique function name using alphabetical sequence."""
        return self.function_generator._generate_unique_function_name()
    
    def generate_function_name(self, preferred_name):
        """Generate a unique function name, using preferred_name if possible."""
        return self.function_generator.generate_function_name(preferred_name)

    def generate_angle_name_from_segments(self, segment1_name, segment2_name):
        """
        Generates a canonical angle name (e.g., "angle_P1VP2") from two segment names.
        Segments are assumed to be named like "VP1", "VP2" (Vertex + Point).
        Returns the angle name string, or None if segments are invalid or don't form an angle.
        """
        if not segment1_name or not segment2_name:
            return None

        s1_points = self.point_generator.split_point_names(segment1_name)
        s2_points = self.point_generator.split_point_names(segment2_name)

        # Ensure each segment name yields exactly two point names
        if not (s1_points and len(s1_points) == 2 and s1_points[0] and s1_points[1] and 
                s2_points and len(s2_points) == 2 and s2_points[0] and s2_points[1]):
            return None 

        set_s1_points = set(s1_points)
        set_s2_points = set(s2_points)

        common_points = list(set_s1_points.intersection(set_s2_points))
        if len(common_points) != 1:
            return None # Segments must share exactly one common vertex
        
        vertex_name = common_points[0]
        
        all_unique_points = list(set_s1_points.union(set_s2_points))
        if len(all_unique_points) != 3:
            return None # Angle must be formed by 3 unique points

        # Identify and sort the two arm points (excluding the vertex)
        arm_point_names = sorted([p for p in all_unique_points if p != vertex_name])
        
        # This check is somewhat redundant if len(all_unique_points) == 3 and len(common_points) == 1,
        # as arm_point_names would then have to be 2. Kept for clarity/safety.
        if len(arm_point_names) != 2:
            return None 

        return f"angle_{arm_point_names[0]}{vertex_name}{arm_point_names[1]}" 