from .point import PointNameGenerator
from .function import FunctionNameGenerator


class DrawableNameGenerator:
    """Main class that orchestrates the generation of various drawable names."""
    
    def __init__(self, canvas):
        self.canvas = canvas
        self.used_letters_from_names = {}  # Maintain for backward compatibility
        
        # Initialize specialized generators
        self.point_generator = PointNameGenerator(canvas)
        self.function_generator = FunctionNameGenerator(canvas)
    
    def reset_state(self):
        """Reset the state of all specialized name generators."""
        self.point_generator.reset_state()
        self.function_generator.reset_state() # Assuming FunctionNameGenerator might also have state
        # Add resets for other generators if they exist and have state
    
    def print_names(self):
        """Print all drawable names by category."""
        print(f"Point names: {self.get_drawable_names('Point')}")
        print(f"Segment names: {self.get_drawable_names('Segment')}")
        print(f"Triangle names: {self.get_drawable_names('Triangle')}")
        print(f"Rectangle names: {self.get_drawable_names('Rectangle')}")
        print(f"Circle names: {self.get_drawable_names('Circle')}")
        print(f"Ellipse names: {self.get_drawable_names('Ellipse')}")
        print(f"Function names: {self.get_drawable_names('Function')}")
    
    # Delegate methods to specialized generators or base NameGenerator
    
    def get_drawable_names(self, class_name):
        """Get sorted list of names for drawables of a specific class."""
        drawables = self.canvas.get_drawables_by_class_name(class_name)
        drawable_names = sorted([drawable.name for drawable in drawables])
        return drawable_names
    
    def filter_string(self, name):
        """Filter a string to keep only letters, apostrophes, digits, and parentheses."""
        return self.point_generator.filter_string(name)
    
    def split_point_names(self, expression, n=2):
        """Split a point expression into individual point names."""
        # Update our internal tracker for backward compatibility
        result = self.point_generator.split_point_names(expression, n)
        if expression and expression in self.point_generator.used_letters_from_names:
            self.used_letters_from_names[expression] = self.point_generator.used_letters_from_names[expression]
        return result
    
    def _generate_unique_point_name(self):
        """Generate a unique point name using alphabetical sequence with apostrophes."""
        return self.point_generator._generate_unique_point_name()
    
    def generate_point_name(self, preferred_name):
        """Generate a unique point name, using preferred_name if possible."""
        # Update our internal tracker for backward compatibility
        result = self.point_generator.generate_point_name(preferred_name)
        if preferred_name and preferred_name in self.point_generator.used_letters_from_names:
            self.used_letters_from_names[preferred_name] = self.point_generator.used_letters_from_names[preferred_name]
        return result
    
    def _increment_function_name(self, func_name):
        """Increment a function name by adding or incrementing a number suffix."""
        return self.function_generator._increment_function_name(func_name)
    
    def _generate_unique_function_name(self):
        """Generate a unique function name using alphabetical sequence."""
        return self.function_generator._generate_unique_function_name()
    
    def generate_function_name(self, preferred_name):
        """Generate a unique function name, using preferred_name if possible."""
        return self.function_generator.generate_function_name(preferred_name)

    def _is_valid_point_list(self, points):
        """Helper to check if a list of points is valid for angle name generation."""
        if not points or not isinstance(points, list) or len(points) != 2:
            return False
        # Ensure both point names are non-empty strings
        if not (isinstance(points[0], str) and points[0] and \
                isinstance(points[1], str) and points[1]):
            return False
        return True

    def generate_angle_name_from_segments(self, segment1_name, segment2_name):
        """
        Generates a canonical angle name (e.g., "angle_P1VP2") from two segment names.
        Segments are assumed to be named like "VP1", "VP2" (Vertex + Point).
        Returns the angle name string, or None if segments are invalid or don't form an angle.
        """
        if not segment1_name or not segment2_name:
            return None

        # Temporarily reset next_index for these specific segment names if they were parsed before
        # This ensures a fresh parse by split_point_names for this method's context
        if hasattr(self.point_generator, 'used_letters_from_names'): # Check if attribute exists
            if segment1_name in self.point_generator.used_letters_from_names:
                self.point_generator.used_letters_from_names[segment1_name]['next_index'] = 0
            if segment2_name in self.point_generator.used_letters_from_names:
                self.point_generator.used_letters_from_names[segment2_name]['next_index'] = 0
            
        s1_points = self.point_generator.split_point_names(segment1_name)
        s2_points = self.point_generator.split_point_names(segment2_name)

        valid_s1 = self._is_valid_point_list(s1_points)
        valid_s2 = self._is_valid_point_list(s2_points)

        if not (valid_s1 and valid_s2):
            return None

        set_s1_points = set(s1_points)
        set_s2_points = set(s2_points)

        common_points = list(set_s1_points.intersection(set_s2_points))
        if len(common_points) != 1:
            return None 
        
        vertex_name = common_points[0]
        
        all_unique_points = list(set_s1_points.union(set_s2_points))
        if len(all_unique_points) != 3:
            return None 

        # Identify and sort the two arm points (excluding the vertex)
        # Ensure elements are strings before comparison with vertex_name if there's any doubt
        arm_point_candidates = [str(p) for p in all_unique_points if p is not None and str(p) != str(vertex_name)]
        arm_point_names = sorted(arm_point_candidates)
        
        if len(arm_point_names) != 2:
            return None 

        final_name = f"angle_{arm_point_names[0]}{vertex_name}{arm_point_names[1]}"
        return final_name 