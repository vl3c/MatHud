from constants import default_color, default_point_size, point_label_font_size
from drawable import Drawable
from position import Position
from math_util import MathUtil
import math


class Point(Drawable):
    def __init__(self, x, y, canvas, name="", color=default_color):
        self.original_position = Position(x, y)
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()
    
    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self._initialize()

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Point'

    def draw(self):
        if not self.is_visible():
            return
        x, y = self.x, self.y
        # Draw point
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(default_point_size), fill=self.color)
        # Draw label
        label_text = self.name + f'({round(self.original_position.x, 3)}, {round(self.original_position.y, 3)})'
        label_offset = default_point_size
        self.create_svg_element('text', x=str(x+label_offset), y=str(y-label_offset), fill=self.color, text_content=label_text, text_font_size=point_label_font_size)

    def __str__(self):
        x = self.x
        y = self.y
        return f'{x},{y}'
    
    def _initialize(self):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        self.x = origin.x + self.original_position.x * scale_factor
        self.y = origin.y - self.original_position.y * scale_factor

    def _translate(self, offset_point):
        self.x += offset_point.x
        self.y += offset_point.y

    def _translate_towards(self, destination, displacement):
        # Calculate the direction vector from the point to the destination
        dx = destination.x - self.x
        dy = destination.y - self.y
        # Normalize the direction vector
        magnitude = math.sqrt(dx**2 + dy**2)
        dx /= magnitude
        dy /= magnitude
        # Update the coordinates by adding the displacement in the direction of the destination
        offset_point = Position(displacement * dx, displacement * dy)
        self._translate(offset_point)

    def zoom(self):
        zoom_point = self.canvas.zoom_point
        zoom_direction = self.canvas.zoom_direction
        zoom_step = self.canvas.zoom_step
        distance = MathUtil.get_2D_distance(zoom_point, self)
        displacement = distance * zoom_step * zoom_direction
        self._translate_towards(zoom_point, displacement)

    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        pos = self.original_position
        state = {"name": self.name, "args": {"position": {"x": pos.x, "y": pos.y}}}
        return state
    
    def is_visible(self):
        # returns true if the point is within the canvas
        return self.canvas.is_point_within_canvas_visible_area(self.x, self.y)
    
    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        # For undo / redo / archive functionality
        # Create a new Point instance with the same coordinates and properties, but do not deep copy the canvas
        new_point = Point(self.original_position.x, self.original_position.y, self.canvas, name=self.name, color=self.color)
        memo[id(self)] = new_point
        return new_point

    def translate(self, x_offset, y_offset):
        self.original_position.x += x_offset
        self.original_position.y += y_offset
        self._initialize()

    def rotate(self, angle):
        pass