import math
from config import default_color, default_point_size
from drawable import Drawable
from math_util import Utilities


class Position:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f'Position: {self.x}, {self.y}'


class Point(Drawable):
    def __init__(self, x, y, canvas, color=default_color):
        self.original_position = Position(x, y)
        super().__init__(color, canvas)
        self._initialize()
    
    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self._initialize()

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Point'

    def draw(self):
        x, y = self.x, self.y
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(default_point_size), fill=self.color)

    def __str__(self):
        x = self.x
        y = self.y
        return f'{x},{y}'
    
    def _initialize(self):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        self.x = origin.x + self.original_position.x * scale_factor
        self.y = origin.y - self.original_position.y * scale_factor

    def _translate(self, offset_point):
        self.x += offset_point.x
        self.y += offset_point.y
    
    def _scale(self, factor):
        pass # Points are not scaled

    def _scale_coordinates(self, factor):
        self.x *= factor
        self.y *= factor

    def _translate_towards(self, destination, displacement):
        # Calculate the direction vector from the point to the destination
        dx = destination.x - self.x
        dy = destination.y - self.y
        # Normalize the direction vector
        magnitude = math.sqrt(dx**2 + dy**2)
        dx /= magnitude
        dy /= magnitude
        # Update the coordinates by adding the displacement in the direction of the destination
        offset_point = Position(displacement * dx, displacement * dy)
        self._translate(offset_point)

    def zoom(self):
        zoom_point = self.canvas.zoom_point
        zoom_direction = self.canvas.zoom_direction
        zoom_step = self.canvas.zoom_step
        distance = Utilities.get_2D_distance(zoom_point, self)
        displacement = distance * zoom_step * zoom_direction
        self._translate_towards(zoom_point, displacement)

    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        pos = self.original_position
        state = {"class": self.get_class_name(), "args": {"position": {"x": pos.x, "y": pos.y}}}
        return state