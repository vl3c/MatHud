import math
import ast


class ExpressionValidator(ast.NodeVisitor):
    ALLOWED_NODES = {
        ast.Add, ast.Sub, ast.Mult, ast.Div, ast.USub, ast.UAdd, ast.Num, ast.Name, ast.BinOp, ast.UnaryOp, ast.Expression, ast.Call
    }

    ALLOWED_FUNCTIONS = {'sin', 'cos', 'tan', 'sqrt', 'pi'}

    def visit(self, node):
        if not isinstance(node, self.ALLOWED_NODES):
            raise ValueError(f"Disallowed node type: {type(node).__name__}")
        return super().visit(node)

    def visit_Call(self, node):
        if isinstance(node.func, ast.Name) and node.func.id in self.ALLOWED_FUNCTIONS:
            # Visit the children of the ast.Call node manually
            for arg in node.args:
                self.visit(arg)
            for keyword in node.keywords:
                self.visit(keyword)
        else:
            raise ValueError(f"Disallowed function: {ast.dump(node)}")
    
    @staticmethod
    def validate_expression(expr):
        tree = ast.parse(expr, mode='eval')
        print(ast.dump(tree))
        validator = ExpressionValidator()
        validator.visit(tree)


class Utilities:
    @staticmethod
    def get_2D_distance(point1, point2):
        dx = point1.x - point2.x
        dy = point1.y - point2.y
        distance = math.sqrt(dx**2 + dy**2)
        return distance

    @staticmethod
    def get_2D_midpoint(point1, point2):
        x = (point1.x + point2.x) / 2
        y = (point1.y + point2.y) / 2
        return (x, y)

    @staticmethod
    def is_point_on_segment(px, py, sp1x, sp1y, sp2x, sp2y):
        # Check if point is within bounding box of the segment
        if (min(sp1x, sp2x) <= px <= max(sp1x, sp2x)) and (min(sp1y, sp2y) <= py <= max(sp1y, sp2y)):
            # Check if point is on the line defined by the segment
            # Using the cross product approach to check if three points are collinear
            cross_product = (py - sp1y) * (sp2x - sp1x) - (px - sp1x) * (sp2y - sp1y)
            return abs(cross_product) < 1e-10  # Using a small threshold to handle floating point inaccuracies
        return False

    @staticmethod
    def get_triangle_area(cls, point1, point2, point3):
        # Calculate the area of the triangle using Heron's formula
        a = cls.get_2D_distance(point1, point2)
        b = cls.get_2D_distance(point2, point3)
        c = cls.get_2D_distance(point3, point1)
        s = (a + b + c) / 2
        area = math.sqrt(s * (s - a) * (s - b) * (s - c))
        return area
    
    @staticmethod
    def get_rectangle_area(point1, point2):
        width = abs(point1.x - point2.x)
        height = abs(point1.y - point2.y)
        area = width * height
        return area
        
    @staticmethod
    def _evaluate_expression(expression, x):
        # Parse the expression into an abstract syntax tree
        tree = ast.parse(expression, mode='eval')
        # Create a dictionary with the variable x and the math module's trigonometric functions
        variables = {'x': x, 'sin': math.sin, 'cos': math.cos, 'tan': math.tan, 'sqrt': math.sqrt, 'pi': math.pi}
        # Evaluate the expression using the abstract syntax tree and the variables dictionary
        result = eval(compile(tree, '<string>', mode='eval'), variables)
        return result

    @classmethod
    def parse_function_string(cls, function_string):
        # Fix the function string to be compatible with the ast module (e.g. replace ^ with **)
        function_string = function_string.replace('^', '**')
        # Validate the expression using the ExpressionValidator
        ExpressionValidator.validate_expression(function_string)
        print(f"Valid expression: {function_string}")
        # Return a lambda function that evaluates the expression
        return lambda x: cls._evaluate_expression(function_string, x)

    @staticmethod
    def validate_rectangle(x1, y1, x2, y2, x3, y3, x4, y4):
        points = [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]
        # Calculate all distances between points
        distances = [math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) for i, (x1, y1) in enumerate(points) for x2, y2 in points[i+1:]]
        # There should be 4 distances of one length (the sides) and 2 distances of another length (the diagonals)
        distances.sort()
        sides = distances[:4]
        diagonals = distances[4:]
        if len(set(sides)) != 1 or len(set(diagonals)) != 1:
            return False  # Sides or diagonals are not of equal length
        # Check for right angles using the dot product
        vectors = [(x2 - x1, y2 - y1) for (x1, y1), (x2, y2) in zip(points, points[1:] + points[:1])]
        for i, vector in enumerate(vectors):
            if sum(v1 * v2 for v1, v2 in zip(vector, vectors[(i+1)%4])) != 0:
                return False  # Angles are not right angles
        return True