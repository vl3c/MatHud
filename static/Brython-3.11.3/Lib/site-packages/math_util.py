from collections import Counter
import math
import random
import statistics
from browser import window


class MathUtil:
    @staticmethod
    def format_number_for_cartesian(n, max_digits=6):
        """
        Formats the number to a string with a maximum number of significant digits or in scientific notation.
        Trailing zeros after the decimal point are stripped.
        """
        if n == 0:
            return "0"
        # Use scientific notation for very large or very small numbers but not zero
        elif abs(n) >= 10**max_digits or (abs(n) < 10**(-max_digits + 1)):
            formatted_number = f"{n:.1e}"
        else:
            formatted_number = f"{n:.{max_digits}g}"
        # Process scientific notation to adjust exponent formatting
        if 'e' in formatted_number:
            base, exponent = formatted_number.split('e')
            base = base.rstrip('0').rstrip('.')
            # Fix handling for exponent sign
            sign = exponent[0] if exponent.startswith('-') else '+'
            exponent_number = exponent.lstrip('+').lstrip('-').lstrip('0') or '0'
            formatted_number = f"{base}e{sign}{exponent_number}"
        else:
            # Truncate to max_digits significant digits for non-scientific notation
            if '.' in formatted_number:
                formatted_number = formatted_number[:formatted_number.find('.') + max_digits]
        return formatted_number

    @staticmethod
    def point_matches_coordinates(point, x, y):
        result = point.original_position.x == x and point.original_position.y == y
        return result

    @staticmethod
    def segment_matches_coordinates(segment, x1, y1, x2, y2):
        first_direction_match = MathUtil.point_matches_coordinates(segment.point1, x1, y1) and MathUtil.point_matches_coordinates(segment.point2, x2, y2)
        second_direction_match = MathUtil.point_matches_coordinates(segment.point1, x2, y2) and MathUtil.point_matches_coordinates(segment.point2, x1, y1)
        return first_direction_match or second_direction_match

    @staticmethod
    def segment_matches_point_names(segment, p1_name, p2_name):
        return ((segment.point1.name == p1_name and segment.point2.name == p2_name) or
               (segment.point1.name == p2_name and segment.point2.name == p1_name))

    @staticmethod
    def segment_has_end_point(segment, x, y):
            return MathUtil.point_matches_coordinates(segment.point1, x, y) or MathUtil.point_matches_coordinates(segment.point2, x, y)

    @staticmethod
    def get_2D_distance(p1, p2):
        dx = p1.x - p2.x
        dy = p1.y - p2.y
        distance = math.sqrt(dx**2 + dy**2)
        return distance

    @staticmethod
    def get_2D_midpoint(p1, p2):
        x = (p1.x + p2.x) / 2
        y = (p1.y + p2.y) / 2
        return x, y

    @staticmethod
    def is_point_on_segment(px, py, sp1x, sp1y, sp2x, sp2y):
        # Check if point is within bounding box of the segment
        if not ((min(sp1x, sp2x) <= px <= max(sp1x, sp2x)) and (min(sp1y, sp2y) <= py <= max(sp1y, sp2y))):
            return False
        # Check if point is on the line defined by the segment
        # Using the cross product approach to check if three points are collinear
        from point import Position
        origin = Position(sp1x, sp1y)
        p1 = Position(sp2x, sp2y)
        p2 = Position(px, py)
        cross_product = MathUtil.cross_product(origin, p1, p2)
        return abs(cross_product) < 1e-10  # Using a small threshold to handle floating point inaccuracies

    @staticmethod
    def get_triangle_area(p1, p2, p3):
        # Calculate the area of the triangle using Heron's formula
        a = MathUtil.get_2D_distance(p1, p2)
        b = MathUtil.get_2D_distance(p2, p3)
        c = MathUtil.get_2D_distance(p3, p1)
        s = (a + b + c) / 2
        area = math.sqrt(s * (s - a) * (s - b) * (s - c))
        return area
    
    @staticmethod
    def get_triangle_centroid(p1, p2, p3):
        x = (p1.x + p2.x + p3.x) / 3
        y = (p1.y + p2.y + p3.y) / 3
        return x, y

    @staticmethod
    def get_rectangle_area(diagonal_p1, diagonal_p2):
        width = abs(diagonal_p1.x - diagonal_p2.x)
        height = abs(diagonal_p1.y - diagonal_p2.y)
        area = width * height
        return area

    @staticmethod
    def cross_product(origin, p1, p2):
        result = (p1.x - origin.x) * (p2.y - origin.y) - (p2.x - origin.x) * (p1.y - origin.y)
        return result
    
    @staticmethod
    def dot_product(origin, p1, p2):
        vec1 = (p1.x - origin.x, p1.y - origin.y)
        vec2 = (p2.x - origin.x, p2.y - origin.y)
        result = vec1[0] * vec2[0] + vec1[1] * vec2[1]
        return result 

    @staticmethod
    def is_right_angle(origin, p1, p2):
        dot_product = MathUtil.dot_product(origin, p1, p2)
        return dot_product == 0

    @staticmethod
    def is_rectangle(x1, y1, x2, y2, x3, y3, x4, y4): # points must be in clockwise or counterclockwise order
        from point import Position
        points = [Position(x, y) for x, y in [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]]

        # Check for duplicate points
        for i, p1 in enumerate(points):
            for j, p2 in enumerate(points):
                if i != j and p1.x == p2.x and p1.y == p2.y:
                    return False
        
        # Calculate all pairwise distances and count unique distances
        distances = [MathUtil.get_2D_distance(p1, p2) for i, p1 in enumerate(points) for j, p2 in enumerate(points) if i < j]
        distance_counts = Counter(distances)
        
        # Check for 2 (squares) or 3 (rectangles) unique distances 
        unique_distances_invalid = len(distance_counts) not in [2, 3]
        square_distances_invalid = sorted(distance_counts.values()) != [2, 4]
        rectangle_distances_invalid = sorted(distance_counts.values()) != [2, 2, 2]
        distances_types_invalid = square_distances_invalid and rectangle_distances_invalid
        if unique_distances_invalid or distances_types_invalid:
            return False

        for i in range(4):
            # Using each point as a vertex and the next and previous points as ends of the sides
            vertex = points[i]
            next_point = points[(i + 1) % 4]
            prev_point = points[(i - 1) % 4]  # Adjusted to get the previous point correctly
            if not MathUtil.is_right_angle(vertex, next_point, prev_point):
                return False

        return True


    # DEPRECATED BUT FASTER
    @staticmethod
    def evaluate_expression_using_python(expression):
        from expression_validator import ExpressionValidator
        result = ExpressionValidator.parse_function_string(expression)(0)
        return result

    @staticmethod
    def points_orientation(p1x, p1y, p2x, p2y, p3x, p3y):
        # Calculate orientation of triplet (p1, p2, p3)
        val = (p2y - p1y) * (p3x - p2x) - (p2x - p1x) * (p3y - p2y)
        if val == 0:
            return 0  # Collinear
        elif val > 0:
            return 1  # Clockwise
        else:
            return 2  # Counterclockwise

    @staticmethod
    def segments_intersect(s1x1, s1y1, s1x2, s1y2, s2x1, s2y1, s2x2, s2y2):
        # Find orientations
        o1 = MathUtil.points_orientation(s1x1, s1y1, s1x2, s1y2, s2x1, s2y1)
        o2 = MathUtil.points_orientation(s1x1, s1y1, s1x2, s1y2, s2x2, s2y2)
        o3 = MathUtil.points_orientation(s2x1, s2y1, s2x2, s2y2, s1x1, s1y1)
        o4 = MathUtil.points_orientation(s2x1, s2y1, s2x2, s2y2, s1x2, s1y2)

        # General case
        if o1 != o2 and o3 != o4:
            return True

        # Special Cases using the revised is_point_on_segment
        if o1 == 0 and MathUtil.is_point_on_segment(s2x1, s2y1, s1x1, s1y1, s1x2, s1y2):
            return True
        if o2 == 0 and MathUtil.is_point_on_segment(s2x2, s2y2, s1x1, s1y1, s1x2, s1y2):
            return True
        if o3 == 0 and MathUtil.is_point_on_segment(s1x1, s1y1, s2x1, s2y1, s2x2, s2y2):
            return True
        if o4 == 0 and MathUtil.is_point_on_segment(s1x2, s1y2, s2x1, s2y1, s2x2, s2y2):
            return True

        return False

    @staticmethod
    def get_line_formula(x1, y1, x2, y2):
        # Calculate the slope
        if x2 - x1 != 0:  # Avoid division by zero
            m = (y2 - y1) / (x2 - x1)
        else:
            return "x = " + str(x1)  # The line is vertical
        # Calculate the y-intercept
        b = y1 - m * x1
        # Return the algebraic expression
        if b >= 0:
            return f"y = {m} * x + {b}"
        else:
            return f"y = {m} * x - {-b}"  # Use -b to make sure the minus sign is printed correctly

    @staticmethod
    def get_segments_intersection(s1_x1, s1_y1, s1_x2, s1_y2, s2_x1, s2_y1, s2_x2, s2_y2):
        # Generate line formulas for both segments
        line1_formula = MathUtil.get_line_formula(s1_x1, s1_y1, s1_x2, s1_y2)
        line2_formula = MathUtil.get_line_formula(s2_x1, s2_y1, s2_x2, s2_y2)
        # Assuming solve_system_of_equations exists and handles these formulas
        solution = MathUtil.solve_system_of_equations([line1_formula, line2_formula])
        # Check if the solution is an error message
        if isinstance(solution, str) and solution.startswith("Error:"):
            return None
        # Parse the solution if it is in the form "x = 0.5, y = 0.5"
        if isinstance(solution, str) and ", " in solution:
            x_str, y_str = solution.split(", ")
            x = float(x_str.split(" = ")[1])
            y = float(y_str.split(" = ")[1])
            return x, y

    @staticmethod
    def get_circle_formula(x, y, r):
        # Return the algebraic expression
        return f"(x - {x})**2 + (y - {y})**2 = {r}**2"
    
    @staticmethod
    def get_ellipse_formula(x, y, rx, ry):
        # Return the algebraic expression
        return f"((x - {x})**2)/{rx}**2 + ((y - {y})**2)/{ry}**2 = 1"

    @staticmethod
    def try_convert_to_number(value):
        try:
            return float(value)
        except Exception:
            return value

    @staticmethod
    def sqrt(x):
        try:
            result = window.math.format(window.math.sqrt(x))
            return MathUtil.try_convert_to_number(result)
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def pow(x, exp):
        try:
            result = window.math.format(window.math.pow(x, exp))
            return MathUtil.try_convert_to_number(result)
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def det(matrix):
        try:
            result = window.math.format(window.math.det(matrix))
            return MathUtil.try_convert_to_number(result)
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def convert(value, from_unit, to_unit):
        try:
            return window.math.format(window.math.evaluate(f"{value} {from_unit} to {to_unit}"))
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def evaluate(expression, variables=None):
        try:
            from expression_validator import ExpressionValidator
            js_expression = ExpressionValidator.fix_math_expression(expression, python_compatible=False)
            python_expression = ExpressionValidator.fix_math_expression(expression, python_compatible=True)
            ExpressionValidator.validate_expression_tree(python_expression)
            if not variables:
                result = window.math.format(window.math.evaluate(js_expression))
            else:
                result = window.math.format(window.math.evaluate(js_expression, variables))
            converted_result = MathUtil.try_convert_to_number(result)
            return converted_result
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def derivative(expression, variable):
        try:
            return window.nerdamer(f"diff({expression}, {variable})").text()
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def limit(expression, variable, value_to_approach):
        try:
            value_to_approach = str(value_to_approach).lower().replace(' ', '')
            if value_to_approach in ['inf', 'infinity']:
                value_to_approach = 'Infinity'
            elif value_to_approach in ['-inf', '-infinity']:
                value_to_approach = '-Infinity'
            return window.nerdamer(f"limit({expression}, {variable}, {value_to_approach})").text()
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def integral(expression, variable, lower_bound=None, upper_bound=None):
        try:
            indefinite_integral = window.nerdamer(f"integrate({expression}, {variable})")
            if not lower_bound and not upper_bound:
                return indefinite_integral.text()
            evaluated_at_upper = indefinite_integral.sub(variable, upper_bound).text()
            evaluated_at_lower = indefinite_integral.sub(variable, lower_bound).text()
            return window.nerdamer(f"{evaluated_at_upper} - {evaluated_at_lower}").evaluate().text()
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def simplify(expression):
        try:
            return window.nerdamer(f"simplify({expression})").text()
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def expand(expression):
        try:
            return window.nerdamer(f"expand({expression})").text()
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def factor(expression):
        try:
            return window.nerdamer(f"factor({expression})").text()
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def get_equation_type(equation):
        import re
        try:
            # Preprocess the equation by expanding it to eliminate parentheses
            expanded_equation = MathUtil.expand(equation)
            # Remove whitespaces for easier processing
            expanded_equation = expanded_equation.replace(' ', '')
            
            # First, check for higher order equations, starting from the highest possible orders
            higher_order_match = re.search(r'\b[a-zA-Z]\^([5-9]|\d{2,})\b', expanded_equation)
            if higher_order_match:
                power = higher_order_match.group(1)
                return f"Order {power}"
            
            # Then check for quartic, cubic, and quadratic equations in descending order
            quartic_match = re.search(r'\b[a-zA-Z]\^4\b', expanded_equation)
            if quartic_match:
                return "Quartic"
            
            cubic_match = re.search(r'\b[a-zA-Z]\^3\b', expanded_equation)
            if cubic_match:
                return "Cubic"
            
            quadratic_match = re.search(r'\b[a-zA-Z]\^2\b', expanded_equation)
            if quadratic_match:
                return "Quadratic"
            
            trigonometric_match = re.search(r'\b(sin|cos|tan|csc|sec|cot)\s*\(([^)]+)\)', expanded_equation)
            if trigonometric_match:
                return "Trigonometric"

            # Check for other types of non-linear equations, e.g., variables multiplied together
            if re.search(r'\b([a-zA-Z])\*?([a-zA-Z])\b', expanded_equation):
                return "Other Non-linear"
            
            # If none of the non-linear conditions are met, it's linear
            return "Linear"
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def determine_max_number_of_solutions(equations):
        try:
            if not equations:  # Checking for an empty list of equations
                return 0  # Indicates no solutions can be determined without equations
    
            # Analyze the types of equations
            equation_types = [MathUtil.get_equation_type(eq) for eq in equations]
            
            # Initialize counts for each type
            linear_count = equation_types.count("Linear")
            quadratic_count = equation_types.count("Quadratic")
            cubic_count = equation_types.count("Cubic")
            quartic_count = equation_types.count("Quartic")
            higher_order_count = sum(1 for et in equation_types if "Order" in et)
            trigonometric_count = equation_types.count("Trigonometric")
            other_non_linear_count = equation_types.count("Other Non-linear")

            # Handling combinations of equations
            if len(equations) == 1:
                return 0
            elif trigonometric_count > 0:
                return 0  # Indicates complex or uncertain scenarios without a clear maximum, or potentially no solution
            elif higher_order_count > 1:
                return 0 # Indicates complex or uncertain scenarios without a clear maximum, or potentially no solution
            elif other_non_linear_count > 0:
                return 0
            elif linear_count == 1 and quadratic_count == 1:
                return 2  # A quadratic and a linear equation can intersect in at most 2 points
            elif linear_count == 1 and cubic_count == 1:
                return 3  # A cubic and a linear equation can intersect in at most 3 points
            elif linear_count == 1 and quartic_count == 1:
                return 4  # A quartic and a linear equation can intersect in at most 4 points
            elif quadratic_count == 1 and cubic_count == 1:
                return 6  # Intersection points of a quadratic and cubic equation
            elif quadratic_count == 1 and quartic_count == 1:
                return 8  # Intersection points of a quadratic and quartic equation
            elif cubic_count == 1 and quartic_count == 1:
                return 12  # Intersection points of a cubic and quartic equation
            elif linear_count == len(equations):
                return 1  # Systems of linear equations typically have one solution, coincident lines being a special case
            
            # Other combinations or if higher-order or multiple non-linear equations are present
            return 0  # Indicates complex or uncertain scenarios without a clear maximum, or potentially no solution
            
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def solve(equation, variable):
        try:
            return window.nerdamer(f"solve({equation}, {variable})").text()
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def solve_linear_quadratic_system(equations):
        try:
            from ast import literal_eval

            if len(equations) in [0, 1] or len(equations) > 2:
                raise ValueError("The system of equations must contain at most 2 equations.")
            
            from expression_validator import ExpressionValidator
            eq1 = MathUtil.expand(equations[0])
            eq1 = ExpressionValidator.fix_math_expression(eq1, python_compatible=False)
            # Split by '=' to separate the left and right sides of the equation and take the side containing the variable
            eq1 = eq1.split('=')[0] if 'x' in eq1.split('=')[0] else eq1.split('=')[1]

            eq2 = MathUtil.expand(equations[1])
            eq2 = ExpressionValidator.fix_math_expression(eq2, python_compatible=False)
            # Split by '=' to separate the left and right sides of the equation and take the side containing the variable
            eq2 = eq2.split('=')[0] if 'x' in eq2.split('=')[0] else eq2.split('=')[1]
            
            linear, quadratic = (eq1, eq2) if "^2" in eq2 else (eq2, eq1)

            system_eq = f"{quadratic} - ({linear})"
            system_eq = MathUtil.expand(system_eq)

            # Extract m, n = coefficients of the linear equation (assuming y = mx + n form)
            lin_coeffs_str = window.nerdamer.coeffs(linear, 'x').text() # The coefficients are placed in the index of their power. So constants are in the 0th place, x^2 would be in the 2nd place, etc. 
            lin_coeffs = literal_eval(lin_coeffs_str)
            m, n = lin_coeffs[1], lin_coeffs[0]
            
            # Extract a, b, c = coefficients of system equation
            quadratic_coeffs_str = window.nerdamer.coeffs(system_eq, 'x').text()
            quadratic_coeffs = literal_eval(quadratic_coeffs_str)
            a, b, c = quadratic_coeffs[2], quadratic_coeffs[1], quadratic_coeffs[0]

            # Solve the quadratic equation of the system
            discriminant = b**2 - 4*a*c
            if discriminant < 0:
                raise ValueError(f"No real solution for the quadratic equation {quadratic}.")

            x1 = (-b + math.sqrt(discriminant)) / (2*a)
            x2 = (-b - math.sqrt(discriminant)) / (2*a)
            
            # If the linear equation is not directly in terms of y, adjust accordingly
            y1 = m*x1 + n
            y2 = m*x2 + n
            
            # Format solutions
            solutions = []
            if discriminant > 0:  # Two solutions
                solutions.append(('x1', x1))
                solutions.append(('y1', y1))
                solutions.append(('x2', x2))
                solutions.append(('y2', y2))
            elif discriminant == 0:  # One solution
                solutions.append(('x', x1))
                solutions.append(('y', y1))
            
            # Prepare the solution dictionary (assuming a single solution format for simplification)
            solution_dict = {sol[0]: sol[1] for sol in solutions}
            
            # Convert solution_dict to string format
            solution_strings = [f"{k} = {v}" for k, v in solution_dict.items()]
            return ', '.join(solution_strings)

        except ValueError as ve:
            raise ve
        except Exception as e:
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def solve_system_of_equations(equations):
        try:
            from expression_validator import ExpressionValidator
            equations = [ExpressionValidator.fix_math_expression(eq, python_compatible=False) for eq in equations]

            max_solutions = MathUtil.determine_max_number_of_solutions(equations)
            
            if max_solutions == 2:
                solutions = MathUtil.solve_linear_quadratic_system(equations)
                return solutions
            else:
                # Return the first solution found by the nerdamer library solver
                solutions = window.nerdamer.solveEquations(equations)
                solution_strings = [f"{solution[0]} = {solution[1]}" for solution in solutions]
                return ', '.join(solution_strings)
        except Exception as e:  # Catch all exceptions
            # Standard error handling
            return f"Error: {e} {getattr(e, 'message', str(e))}"

    @staticmethod
    def random(min_value=0, max_value=1):
        return random.uniform(min_value, max_value)

    @staticmethod
    def round(value, ndigits=0):
        return round(value, ndigits)

    @staticmethod
    def gcd(*values):
        return math.gcd(*values)

    @staticmethod
    def lcm(*values):
        return math.lcm(*values)

    @staticmethod
    def mean(values):
        return statistics.mean(values)

    @staticmethod
    def median(values):
        return statistics.median(values)

    @staticmethod
    def mode(values):
        return statistics.mode(values)

    @staticmethod
    def stdev(values):
        return statistics.stdev(values)

    @staticmethod
    def variance(values):
        return statistics.variance(values)
