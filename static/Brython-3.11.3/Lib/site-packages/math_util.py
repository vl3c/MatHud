import ast
from browser import window
import math
import random
import re
import statistics

class ExpressionValidator(ast.NodeVisitor):
    ALLOWED_NODES = {
        ast.Add, ast.Sub, ast.Mult, ast.Div, ast.USub, ast.UAdd, ast.Num, ast.Name, ast.BinOp, ast.UnaryOp, ast.Expression, ast.Call
    }

    ALLOWED_FUNCTIONS = {
        'sin', 'cos', 'tan', 'sqrt', 'log', 'log10', 'log2', 'factorial', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh', 'exp', 'abs', 'pi', 'e', 'pow', 'bin'
    }

    def visit(self, node):
        if not isinstance(node, self.ALLOWED_NODES):
            raise ValueError(f"Disallowed node type: {type(node).__name__}")
        return super().visit(node)

    def visit_Call(self, node):
        if isinstance(node.func, ast.Name) and node.func.id in self.ALLOWED_FUNCTIONS:
            # Visit the children of the ast.Call node manually
            for arg in node.args:
                self.visit(arg)
            for keyword in node.keywords:
                self.visit(keyword)
        else:
            raise ValueError(f"Disallowed function: {ast.dump(node)}")
    
    @staticmethod
    def validate_expression(expr):
        try:
            # Parse the expression into an abstract syntax tree
            tree = ast.parse(expr, mode='eval')
            validator = ExpressionValidator()
            validator.visit(tree)
            print(f"Valid expression: {expr}")
        except Exception as e:
            print(f"Invalid expression: {expr}")
            raise e

    @staticmethod
    def evaluate_expression(expression, x=0):
        # Create a dictionary with the variable x and the math module's trigonometric functions
        variables_and_functions = {
            'x': x,
            'sin': math.sin,
            'cos': math.cos,
            'tan': math.tan,
            'sqrt': MathUtil.sqrt,
            'log': math.log,   # Natural logarithm (base e)
            'log10': math.log10,  # Logarithm base 10
            'log2': math.log2,  # Logarithm base 2
            'factorial': math.factorial,  # Factorial function
            'asin': math.asin,  # Arcsine function
            'acos': math.acos,  # Arccosine function
            'atan': math.atan,  # Arctangent function
            'sinh': math.sinh, # Hyperbolic sine function
            'cosh': math.cosh, # Hyperbolic cosine function
            'tanh': math.tanh, # Hyperbolic tangent function
            'exp': math.exp, # Exponential function
            'abs': abs, # Absolute value function
            'pi': math.pi, # The constant pi
            'e': math.e, # The constant e
            'pow': math.pow, # Power function
            'bin': bin # Binary representation of an integer
        }
        # Parse the expression into an abstract syntax tree
        tree = ast.parse(expression, mode='eval')
        # Evaluate the expression using the abstract syntax tree and the variables dictionary
        result = eval(compile(tree, '<string>', mode='eval'), variables_and_functions)
        print(f"Evaluated expression: {expression} = {result}")
        return result


class MathUtil:
    @staticmethod
    def fix_math_expression(expression):
        # Test example: sin(pi/4) + cos(π/3) - tan(sqrt(16)) * log(e) / log10(100) + log2(8) * factorial(3) + asin(0.5) - acos(0.5) + atan(1) + sinh(1) - cosh(1) + tanh(0) + exp(1) - abs(-pi) + pow(2, 3)^2 = 82.09880526150872
        # Handle more complex replacements first
        expression = re.sub(r'\|(.*?)\|', r'abs(\1)', expression)
        expression = re.sub(r'√\((.*?)\)', r'sqrt(\1)', expression)
        expression = re.sub(r'√([0-9a-zA-Z_]+)', r'sqrt(\1)', expression)

        def replace_factorial(match):
            inner_expression = match.group(1)
            return f'factorial({inner_expression})'
        expression = re.sub(r'([0-9a-zA-Z_]+|\(.*?\))\!', replace_factorial, expression)

        # Replace all instances of the keys in the replacements dictionary with their corresponding values
        replacements = {
            '^': '**',
            'π': 'pi',  # Using the variable from the dictionary
            'ln': 'log',  # Python's math.log is ln by default
            '{': '(',
            '}': ')',
            '[': '(',
            ']': ')'
        }
        for old, new in replacements.items():
            expression = expression.replace(old, new)

        # Replace 'i' with 'j' only in contexts likely to represent the imaginary unit
        # Assuming it's used in the form of numbers like '2i' or standalone 'i'
        expression = re.sub(r'(?<=\d)i\b', 'j', expression)  # For numbers like '2i'
        expression = re.sub(r'\bi\b', 'j', expression)  # For standalone 'i'

        return expression

    @staticmethod
    def parse_function_string(function_string):       
        function_string = MathUtil.fix_math_expression(function_string)
        ExpressionValidator.validate_expression(function_string)
        # Return a lambda function that evaluates the expression
        return lambda x: ExpressionValidator.evaluate_expression(function_string, x)
    
    @staticmethod
    def get_2D_distance(point1, point2):
        dx = point1.x - point2.x
        dy = point1.y - point2.y
        distance = math.sqrt(dx**2 + dy**2)
        return distance

    @staticmethod
    def get_2D_midpoint(point1, point2):
        x = (point1.x + point2.x) / 2
        y = (point1.y + point2.y) / 2
        return (x, y)

    @staticmethod
    def is_point_on_segment(px, py, sp1x, sp1y, sp2x, sp2y):
        # Check if point is within bounding box of the segment
        if (min(sp1x, sp2x) <= px <= max(sp1x, sp2x)) and (min(sp1y, sp2y) <= py <= max(sp1y, sp2y)):
            # Check if point is on the line defined by the segment
            # Using the cross product approach to check if three points are collinear
            cross_product = (py - sp1y) * (sp2x - sp1x) - (px - sp1x) * (sp2y - sp1y)
            return abs(cross_product) < 1e-10  # Using a small threshold to handle floating point inaccuracies
        return False

    @staticmethod
    def get_triangle_area(cls, point1, point2, point3):
        # Calculate the area of the triangle using Heron's formula
        a = cls.get_2D_distance(point1, point2)
        b = cls.get_2D_distance(point2, point3)
        c = cls.get_2D_distance(point3, point1)
        s = (a + b + c) / 2
        area = math.sqrt(s * (s - a) * (s - b) * (s - c))
        return area
    
    @staticmethod
    def get_rectangle_area(point1, point2):
        width = abs(point1.x - point2.x)
        height = abs(point1.y - point2.y)
        area = width * height
        return area

    @staticmethod
    def validate_rectangle(x1, y1, x2, y2, x3, y3, x4, y4):
        points = [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]
        # Calculate all distances between points
        distances = [math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) for i, (x1, y1) in enumerate(points) for x2, y2 in points[i+1:]]
        # There should be 4 distances of one length (the sides) and 2 distances of another length (the diagonals)
        distances.sort()
        sides = distances[:4]
        diagonals = distances[4:]
        if len(set(sides)) != 1 or len(set(diagonals)) != 1:
            return False  # Sides or diagonals are not of equal length
        # Check for right angles using the dot product
        vectors = [(x2 - x1, y2 - y1) for (x1, y1), (x2, y2) in zip(points, points[1:] + points[:1])]
        for i, vector in enumerate(vectors):
            if sum(v1 * v2 for v1, v2 in zip(vector, vectors[(i+1)%4])) != 0:
                return False  # Angles are not right angles
        return True
    
    @staticmethod
    def evaluate_expression(expression):
        expression = MathUtil.fix_math_expression(expression)
        ExpressionValidator.validate_expression(expression)
        result = ExpressionValidator.evaluate_expression(expression)
        return result
    
    @staticmethod
    def segments_intersect(s1_x1, s1_y1, s1_x2, s1_y2, s2_x1, s2_y1, s2_x2, s2_y2):
        # Compute cross products
        def cross(x1, y1, x2, y2):
            return x1 * y2 - x2 * y1
        # Calculate the cross products for each pair of points
        cross1 = cross(s1_x2 - s1_x1, s1_y2 - s1_y1, s2_x1 - s1_x1, s2_y1 - s1_y1)
        cross2 = cross(s1_x2 - s1_x1, s1_y2 - s1_y1, s2_x2 - s1_x1, s2_y2 - s1_y1)
        cross3 = cross(s2_x2 - s2_x1, s2_y2 - s2_y1, s1_x1 - s2_x1, s1_y1 - s2_y1)
        cross4 = cross(s2_x2 - s2_x1, s2_y2 - s2_y1, s1_x2 - s2_x1, s1_y2 - s2_y1)
        # Check if the cross products have opposite signs
        return (cross1 * cross2 < 0) and (cross3 * cross4 < 0)

    @staticmethod
    def get_segments_intersection_coord(s1_x1, s1_y1, s1_x2, s1_y2, s2_x1, s2_y1, s2_x2, s2_y2):
        # Compute the determinant
        determinant = (s1_x1 - s1_x2) * (s2_y2 - s2_y1) - (s2_x2 - s2_x1) * (s1_y2 - s1_y1)
        
        # If the determinant is zero, the lines are parallel
        if determinant == 0:
            return None

        # Calculate the parameter t for the first line
        t1 = ((s1_x1 - s2_x1) * (s2_y2 - s2_y1) - (s1_y1 - s2_y1) * (s2_x2 - s2_x1)) / determinant

        # Calculate the parameter t for the second line
        t2 = ((s2_x1 - s1_x1) * (s1_y2 - s1_y1) - (s2_y1 - s1_y1) * (s1_x2 - s1_x1)) / determinant

        # Check if the parameters t are within the range [0, 1] for both lines
        if 0 <= t1 <= 1 and 0 <= t2 <= 1:
            # Compute the intersection point
            x_intersection = s1_x1 + t1 * (s1_x2 - s1_x1)
            y_intersection = s1_y1 + t1 * (s1_y2 - s1_y1)
            return x_intersection, y_intersection

        # If the parameters t are not within the range [0, 1], the segments do not intersect
        return None
    
    @staticmethod
    def calculate_line_formula(x1, y1, x2, y2):
        # Calculate the slope
        if x2 - x1 != 0:  # Avoid division by zero
            m = (y2 - y1) / (x2 - x1)
        else:
            return "x = " + str(x1)  # The line is vertical
        # Calculate the y-intercept
        b = y1 - m * x1
        # Return the algebraic expression
        if b >= 0:
            return f"y = {m} * x + {b}"
        else:
            return f"y = {m} * x - {-b}"  # Use -b to make sure the minus sign is printed correctly

    @staticmethod
    def calculate_circle_formula(x, y, r):
        # Return the algebraic expression
        return f"(x - {x})**2 + (y - {y})**2 = {r}**2"
    
    @staticmethod
    def calculate_ellipse_formula(x, y, rx, ry):
        # Return the algebraic expression
        return f"((x - {x})**2)/{rx}**2 + ((y - {y})**2)/{ry}**2 = 1"
    
    @staticmethod
    def sqrt(x):
        return window.math.format(window.math.sqrt(x))

    @staticmethod
    def convert(value, from_unit, to_unit):
        # Convert from one unit to another
        return window.math.format(window.math.evaluate(f"{value} {from_unit} to {to_unit}"))
    
    @staticmethod
    def derivative(expression, variable):
        return window.nerdamer(f"diff({expression}, {variable})").text()

    @staticmethod
    def limit(expression, variable, lim):
        # Enclose the limit point in quotes if it's a special value like Infinity
        limit_point = f"'{lim}'" if lim in ["Infinity", "-Infinity"] else str(lim)
        return window.nerdamer(f"limit({expression}, {variable}, {limit_point})").text()
    
    @staticmethod
    def integral_indefinite(expression, variable):
        return window.nerdamer(f"integrate({expression}, {variable})").text()

    @staticmethod
    def integral(expression, variable, lower_limit, upper_limit):
        indefinite_integral = window.nerdamer(f"integrate({expression}, {variable})")
        evaluated_at_upper = indefinite_integral.sub(variable, upper_limit).text()
        evaluated_at_lower = indefinite_integral.sub(variable, lower_limit).text()
        return window.nerdamer(f"{evaluated_at_upper} - {evaluated_at_lower}").text()

    @staticmethod
    def simplify(expression):
        return window.nerdamer(f"simplify({expression})").text()

    @staticmethod
    def expand(expression):
        return window.nerdamer(f"expand({expression})").text()

    @staticmethod
    def factor(expression):
        return window.nerdamer(f"factor({expression})").text()

    @staticmethod
    def solve(expression, variable):
        return window.nerdamer(f"solve({expression}, {variable})").text()
    
    @staticmethod
    def solve_system_of_equations(equations, variables=None):
        results = window.nerdamer.solveEquations(equations, variables) if variables else window.nerdamer.solveEquations(equations)
        return results

    @staticmethod
    def roots(expression):
        return window.nerdamer(f"roots({expression})").text()

    @staticmethod
    def random(min_value=0, max_value=1):
        return random.uniform(min_value, max_value)

    @staticmethod
    def round(value, ndigits=0):
        return round(value, ndigits)

    @staticmethod
    def gcd(*values):
        return math.gcd(*values)

    @staticmethod
    def lcm(*values):
        return math.lcm(*values)

    @staticmethod
    def mean(values):
        return statistics.mean(values)

    @staticmethod
    def median(values):
        return statistics.median(values)

    @staticmethod
    def mode(values):
        return statistics.mode(values)

    @staticmethod
    def stdev(values):
        return statistics.stdev(values)

    @staticmethod
    def variance(values):
        return statistics.variance(values)

    @staticmethod
    def test_math_functions():
        print("Testing math functions:")
        print(f"sqrt(-4) = {window.math.format(window.math.sqrt(-4))} // Expected: 2i")
        print(f"pow([[-1, 2], [3, 1]], 2) = {window.math.pow([[-1, 2], [3, 1]], 2)} // Expected: [[7, 0], [0, 7]]")
        print(f"evaluate('12 / (2.3 + 0.7)') = {window.math.evaluate('12 / (2.3 + 0.7)')} // Expected: 4")
        print(f"evaluate('12.7 cm to inch') = {window.math.format(window.math.evaluate('12.7 cm to inch'))} // Expected: 5 inch")
        print(f"evaluate('sin(45 deg) ^ 2') = {window.math.evaluate('sin(45 deg) ^ 2')} // Expected: 0.5")
        print(f"evaluate('9 / 3 + 2i') = {window.math.format(window.math.evaluate('9 / 3 + 2i'))} // Expected: 3 + 2i")
        print(f"evaluate('det([-1, 2; 3, 1])') = {window.math.evaluate('det([-1, 2; 3, 1])')} // Expected: -7")
        print(f"chain(3).add(4).multiply(2).done() = {window.math.chain(3).add(4).multiply(2).done()} // Expected: 14")
        print(f"random() = {MathUtil.random()} // Expected: a random number between 0 and 1")
        print(f"round(1.2345, 2) = {MathUtil.round(1.2345, 2)} // Expected: 1.23")
        print(f"gcd(48, 18) = {MathUtil.gcd(48, 18)} // Expected: 6")
        print(f"lcm(4, 5) = {MathUtil.lcm(4, 5)} // Expected: 20")
        print(f"mean(1, 2, 3, 4, 5) = {MathUtil.mean([1, 2, 3, 4, 5])} // Expected: 3")
        print(f"median(1, 2, 3, 4, 5) = {MathUtil.median([1, 2, 3, 4, 5])} // Expected: 3")
        print(f"mode(1, 2, 2, 3) = {MathUtil.mode([1, 2, 2, 3])} // Expected: 2")
        print(f"stdev([2, 4, 6, 8, 10]) = {MathUtil.stdev([2, 4, 6, 8, 10])} // Expected: 3.1623")
        print(f"variance([2, 4, 6, 8, 10]) = {MathUtil.variance([2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5])} // Expected: 1.372")
        print(f"limit('sin(x) / x', 'x', 0) = {MathUtil.limit('sin(x) / x', 'x', 0)} // Expected: 1")
        print(f"derivative('x^2', 'x') = {MathUtil.derivative('x^2', 'x')} // Expected: 2 * x")
        print(f"integral_indefinite('x^2', 'x') = {MathUtil.integral_indefinite('x^2', 'x')} // Expected: x^3/3")
        print(f"integral('x^2', 'x', 0, 1) = {MathUtil.integral('x^2', 'x', 0, 1)} // Expected: 0.333")
        print(f"simplify('x^2 + 2*x + 1') = {MathUtil.simplify('x^2 + 2*x + 1')} // Expected: (1+x)^2")
        print(f"expand('(x + 1)^2') = {MathUtil.expand('(x + 1)^2')} // Expected: 1 + 2*x + x^2")
        print(f"factor('x^2 - 1') = {MathUtil.factor('x^2 - 1')} // Expected: (x - 1)*(x + 1)")
        print(f"solve('x^2 - 4', 'x') = {MathUtil.solve('x^2 - 4', 'x')} // Expected: [-2, 2]")
        print(f"roots('x^2 - 9') = {MathUtil.roots('x^2 - 9')} // Expected: [-3, 3]")
        print(f"solve_system_of_equations(['x + y = 4', 'x - y = 2']) = {MathUtil.solve_system_of_equations(['x + y = 4', 'x - y = 2'])} // Expected: x=3, y=1")
