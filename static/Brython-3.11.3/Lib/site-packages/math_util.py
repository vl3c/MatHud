from browser import window
import ast
import math
import random
import re
import statistics


class ExpressionValidator(ast.NodeVisitor):
    ALLOWED_NODES = {
        ast.Add, ast.Sub, ast.Mult, ast.Div, ast.USub, ast.UAdd, ast.Constant, ast.Name, ast.BinOp, ast.UnaryOp, ast.Expression, ast.Call
    }

    ALLOWED_FUNCTIONS = {
        'sin', 'cos', 'tan', 'sqrt', 'log', 'log10', 'log2', 'factorial', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh', 'exp', 'abs', 'pi', 'e', 'pow', 'bin'
    }
    ALLOWED_FUNCTIONS = {
        'sin', 'cos', 'tan', 'sqrt', 'log', 'log10', 'log2', 'factorial', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh', 'exp', 'abs', 'pi', 'e', 'pow', 'bin',
        'round', 'ceil', 'floor', 'trunc', 'max', 'min', 'sum', 'mean', 'median', 'mode', 'std', 'var', 'random', 'randint'
    }
    def visit(self, node):
        if not isinstance(node, self.ALLOWED_NODES):
            raise ValueError(f"Disallowed node type: {type(node).__name__}")
        return super().visit(node)

    def visit_Call(self, node):
        if isinstance(node.func, ast.Name) and node.func.id in self.ALLOWED_FUNCTIONS:
            # Visit the children of the ast.Call node manually
            for arg in node.args:
                self.visit(arg)
            for keyword in node.keywords:
                self.visit(keyword)
        else:
            raise ValueError(f"Disallowed function: {ast.dump(node)}")

    def visit_Import(self, node):
        raise ValueError("Import statements are not allowed")
    
    def visit_ImportFrom(self, node):
        raise ValueError("Import statements are not allowed")

    def visit_Lambda(self, node):
        raise ValueError("Lambda expressions are not allowed")
    
    def visit_Attribute(self, node):
        raise ValueError("Attribute access is not allowed")

    def visit_Subscript(self, node):
        raise ValueError("Subscripting is not allowed")

    def visit_Assign(self, node):
        raise ValueError("Assignment is not allowed")

    def visit_AugAssign(self, node):
        raise ValueError("Augmented assignment is not allowed")

    def visit_Exec(self, node):
        raise ValueError("Exec statements are not allowed")

    def visit_Global(self, node):
        raise ValueError("Global statements are not allowed")

    def visit_Nonlocal(self, node):
        raise ValueError("Nonlocal statements are not allowed")
    
    @staticmethod
    def validate_expression_tree(expression):
        try:
            # Parse the expression into an abstract syntax tree
            tree = ast.parse(expression, mode='eval')
            validator = ExpressionValidator()
            validator.visit(tree)
            print(f"Valid expression: {expression}")
        except SyntaxError as e:
            # Handling SyntaxError specifically for parsing issues
            print(f"Syntax error in expression: {expression}")
            raise ValueError(f"Syntax error in expression '{expression}': {str(e)}") from e
        except Exception as e:
            # General exception handling
            print(f"Invalid expression: {expression}")
            raise ValueError(f"Error validating expression '{expression}': {str(e)}") from e

    @staticmethod
    def evaluate_expression(expression, x=0):
        # Create a dictionary with the variable x and the math module's trigonometric functions
        variables_and_functions = {
            'x': x,
            'sin': math.sin,
            'cos': math.cos,
            'tan': math.tan,
            'sqrt': MathUtil.sqrt, # Square root function
            'log': math.log,   # Natural logarithm (base e)
            'log10': math.log10,  # Logarithm base 10
            'log2': math.log2,  # Logarithm base 2
            'factorial': math.factorial,  # Factorial function
            'asin': math.asin,  # Arcsine function
            'acos': math.acos,  # Arccosine function
            'atan': math.atan,  # Arctangent function
            'sinh': math.sinh, # Hyperbolic sine function
            'cosh': math.cosh, # Hyperbolic cosine function
            'tanh': math.tanh, # Hyperbolic tangent function
            'exp': math.exp, # Exponential function
            'abs': abs, # Absolute value function
            'pi': math.pi, # The constant pi
            'e': math.e, # The constant e
            'pow': MathUtil.pow, # Power function
            'bin': bin, # Binary representation of an integer
            'det': MathUtil.det, # Determinant of a matrix
            'limit': MathUtil.limit, # Limit of a function
            'derivative': MathUtil.derivative, # Derivative of a function
            'integrate': MathUtil.integral, # Indefinite integral of a function
            'simplify': MathUtil.simplify, # Simplify an expression
            'expand': MathUtil.expand, # Expand an expression
            'factor': MathUtil.factor, # Factor an expression
            'solve': MathUtil.solve, # Solve an equation
            'random': MathUtil.random, # Generate a random number
            'round': MathUtil.round, # Round a number
            'gcd': MathUtil.gcd, # Greatest common divisor
            'lcm': MathUtil.lcm, # Least common multiple
            'mean': MathUtil.mean, # Mean of a list of numbers
            'median': MathUtil.median, # Median of a list of numbers
            'mode': MathUtil.mode, # Mode of a list of numbers
            'stdev': MathUtil.stdev, # Standard deviation of a list of numbers
            'variance': MathUtil.variance, # Variance of a list of numbers
            'ceil': math.ceil, # Round up to the nearest integer
            'floor': math.floor, # Round down to the nearest integer
            'trunc': math.trunc, # Truncate to an integer
            'max': max, # Maximum of a list of numbers
            'min': min, # Minimum of a list of numbers
            'sum': sum, # Sum of a list of numbers
            'randint': lambda a, b: random.randint(a, b) # Random integer between a and b
    }
        # Parse the expression into an abstract syntax tree
        tree = ast.parse(expression, mode='eval')
        # Evaluate the expression using the abstract syntax tree and the variables dictionary
        result = eval(compile(tree, '<string>', mode='eval'), variables_and_functions)
        return result

    @staticmethod
    def fix_math_expression(expression, python_compatible=False):
        # Replace degree symbol with 'deg' for conversion to radians
        expression = expression.replace('°', ' deg')
        expression = expression.replace('degrees', ' deg')
        expression = expression.replace('degree', ' deg')
        # Replace 'deg' with a conversion to radians
        expression = re.sub(r'(\d+)\s*deg', lambda match: str(float(match.group(1)) * math.pi / 180), expression)

        # Handle more complex replacements first
        expression = re.sub(r'√\((.*?)\)', r'sqrt(\1)', expression)
        expression = re.sub(r'√([0-9a-zA-Z_]+)', r'sqrt(\1)', expression)

        # Replace | | with the Python equivalent
        if python_compatible:
            expression = re.sub(r'\|(.*?)\|', r'abs(\1)', expression)

        def replace_factorial(match):
            inner_expression = match.group(1)
            return f'factorial({inner_expression})'
        expression = re.sub(r'([0-9a-zA-Z_]+|\(.*?\))\!', replace_factorial, expression)

        # Replace all instances of the keys in the replacements dictionary with their corresponding values
        replacements = {
            'π': 'pi',  # Using the variable from the dictionary
            'ln': 'log',  # Python's math.log is ln by default
            '{': '(',
            '}': ')',
            '[': '(',
            ']': ')',
            "absolute(": "abs(",
            "power(": "pow(",
            "binary(": "bin(",
            "logarithm(": "log(",
            "logarithm10(": "log10(",
            "logarithm2(": "log2(",
            "square root(": "sqrt(",
            "sine(": "sin(",
            "cosine(": "cos(",
            "tangent(": "tan(",
            "arcsine(": "asin(",
            "arccosine(": "acos(",
            "arctangent(": "atan(",
            "hyperbolic sine(": "sinh(",
            "hyperbolic cosine(": "cosh(",
            "hyperbolic tangent(": "tanh(",
            "exponential(": "exp("
        }
        for old, new in replacements.items():
            expression = expression.replace(old, new)

        # Replace the power symbol with '**' if specified
        if python_compatible:
            expression = expression.replace('^', '**')
        else:
            expression = expression.replace('**', '^') 

        # Replace 'i' with 'j' only in contexts likely to represent the imaginary unit
        imaginary_unit = 'j' if python_compatible else 'i'
        opposite_unit = 'i' if python_compatible else 'j'

        # Assuming it's used in the form of numbers like '2i' or standalone 'i'
        expression = re.sub(rf'(?<=\d){opposite_unit}\b', f'{imaginary_unit}', expression)  # For numbers like '2i'
        expression = re.sub(rf'\b{opposite_unit}\b', f'{imaginary_unit}', expression)  # For standalone 'i'

        # Insert '*' between a number and a variable, function name, or parenthesis
        # Step 1: Protect "log" followed by any number from being altered
        expression = re.sub(r'log(\d+)', r'log[\1]', expression)
        # Step 2: Insert '*' between a number and a variable, function name, or parenthesis, excluding 'i' or 'j' immediately after a number
        expression = re.sub(rf'(\d)(?!{imaginary_unit})([a-zA-Z_\(])', r'\1*\2', expression)
        # Step 3: Revert "log" followed by any number back to its original form
        expression = re.sub(r'log\[(\d+)\]', r'log\1', expression)

        return expression

    @staticmethod
    def parse_function_string(function_string, use_mathjs=False):       
        if use_mathjs:
            # Parse the function string using math.js (slower)
            f = lambda x: MathUtil.evaluate(function_string, {'x': x})
        else:
            # Parse the function string using Python's math functions (faster)
            function_string = ExpressionValidator.fix_math_expression(function_string, python_compatible=True)
            ExpressionValidator.validate_expression_tree(function_string)
            f = lambda x: ExpressionValidator.evaluate_expression(function_string, x)
        return f


class MathUtil:
    @staticmethod
    def format_number_for_cartesian(n, max_digits=6):
        """
        Formats the number to a string with a maximum number of significant digits or in scientific notation.
        Trailing zeros after the decimal point are stripped.
        """
        if n == 0:
            return "0"
        # Use scientific notation for very large or very small numbers but not zero
        elif abs(n) >= 10**max_digits or (abs(n) < 10**(-max_digits + 1)):
            formatted_number = f"{n:.1e}"
        else:
            formatted_number = f"{n:.{max_digits}g}"
        # Process scientific notation to adjust exponent formatting
        if 'e' in formatted_number:
            base, exponent = formatted_number.split('e')
            base = base.rstrip('0').rstrip('.')
            # Fix handling for exponent sign
            sign = exponent[0] if exponent.startswith('-') else '+'
            exponent_number = exponent.lstrip('+').lstrip('-').lstrip('0') or '0'
            formatted_number = f"{base}e{sign}{exponent_number}"
        else:
            # Truncate to max_digits significant digits for non-scientific notation
            if '.' in formatted_number:
                formatted_number = formatted_number[:formatted_number.find('.') + max_digits]
        return formatted_number
    
    @staticmethod
    def get_2D_distance(p1, p2):
        dx = p1.x - p2.x
        dy = p1.y - p2.y
        distance = math.sqrt(dx**2 + dy**2)
        return distance

    @staticmethod
    def get_2D_midpoint(p1, p2):
        x = (p1.x + p2.x) / 2
        y = (p1.y + p2.y) / 2
        return x, y

    @staticmethod
    def is_point_on_segment(px, py, sp1x, sp1y, sp2x, sp2y):
        # Check if point is within bounding box of the segment
        if (min(sp1x, sp2x) <= px <= max(sp1x, sp2x)) and (min(sp1y, sp2y) <= py <= max(sp1y, sp2y)):
            # Check if point is on the line defined by the segment
            # Using the cross product approach to check if three points are collinear
            cross_product = (py - sp1y) * (sp2x - sp1x) - (px - sp1x) * (sp2y - sp1y)
            return abs(cross_product) < 1e-10  # Using a small threshold to handle floating point inaccuracies
        return False

    @staticmethod
    def get_triangle_area(p1, p2, p3):
        # Calculate the area of the triangle using Heron's formula
        a = MathUtil.get_2D_distance(p1, p2)
        b = MathUtil.get_2D_distance(p2, p3)
        c = MathUtil.get_2D_distance(p3, p1)
        s = (a + b + c) / 2
        area = math.sqrt(s * (s - a) * (s - b) * (s - c))
        return area
    
    @staticmethod
    def get_triangle_centroid(p1, p2, p3):
        x = (p1.x + p2.x + p3.x) / 3
        y = (p1.y + p2.y + p3.y) / 3
        return x, y

    @staticmethod
    def get_rectangle_area(diagonal_p1, diagonal_p2):
        width = abs(diagonal_p1.x - diagonal_p2.x)
        height = abs(diagonal_p1.y - diagonal_p2.y)
        area = width * height
        return area

    @staticmethod
    def is_rectangle(x1, y1, x2, y2, x3, y3, x4, y4):
        points = [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]
        # Calculate all distances between points
        distances = [math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) for i, (x1, y1) in enumerate(points) for x2, y2 in points[i+1:]]
        # There should be 4 distances of one length (the sides) and 2 distances of another length (the diagonals)
        distances.sort()
        sides = distances[:4]
        diagonals = distances[4:]
        if len(set(sides)) != 1 or len(set(diagonals)) != 1:
            return False  # Sides or diagonals are not of equal length
        # Check for right angles using the dot product
        vectors = [(x2 - x1, y2 - y1) for (x1, y1), (x2, y2) in zip(points, points[1:] + points[:1])]
        for i, vector in enumerate(vectors):
            if sum(v1 * v2 for v1, v2 in zip(vector, vectors[(i+1)%4])) != 0:
                return False  # Angles are not right angles
        return True
    
    # DEPRECATED BUT FASTER
    @staticmethod
    def evaluate_expression_using_python(expression):
        result = ExpressionValidator.parse_function_string(expression)(0)
        return result
    
    @staticmethod
    def segments_intersect(s1_x1, s1_y1, s1_x2, s1_y2, s2_x1, s2_y1, s2_x2, s2_y2):
        # Compute cross products
        def cross(x1, y1, x2, y2):
            return x1 * y2 - x2 * y1
        # Calculate the cross products for each pair of points
        cross1 = cross(s1_x2 - s1_x1, s1_y2 - s1_y1, s2_x1 - s1_x1, s2_y1 - s1_y1)
        cross2 = cross(s1_x2 - s1_x1, s1_y2 - s1_y1, s2_x2 - s1_x1, s2_y2 - s1_y1)
        cross3 = cross(s2_x2 - s2_x1, s2_y2 - s2_y1, s1_x1 - s2_x1, s1_y1 - s2_y1)
        cross4 = cross(s2_x2 - s2_x1, s2_y2 - s2_y1, s1_x2 - s2_x1, s1_y2 - s2_y1)
        # Check if the cross products have opposite signs
        return (cross1 * cross2 < 0) and (cross3 * cross4 < 0)

    @staticmethod
    def get_line_formula(x1, y1, x2, y2):
        # Calculate the slope
        if x2 - x1 != 0:  # Avoid division by zero
            m = (y2 - y1) / (x2 - x1)
        else:
            return "x = " + str(x1)  # The line is vertical
        # Calculate the y-intercept
        b = y1 - m * x1
        # Return the algebraic expression
        if b >= 0:
            return f"y = {m} * x + {b}"
        else:
            return f"y = {m} * x - {-b}"  # Use -b to make sure the minus sign is printed correctly

    @staticmethod
    def get_segments_intersection(s1_x1, s1_y1, s1_x2, s1_y2, s2_x1, s2_y1, s2_x2, s2_y2):
        # Generate line formulas for both segments
        line1_formula = MathUtil.get_line_formula(s1_x1, s1_y1, s1_x2, s1_y2)
        line2_formula = MathUtil.get_line_formula(s2_x1, s2_y1, s2_x2, s2_y2)
        # Assuming solve_system_of_equations exists and handles these formulas
        solution = MathUtil.solve_system_of_equations([line1_formula, line2_formula])
        # Check if the solution is an error message
        if isinstance(solution, str) and solution.startswith("Error:"):
            return None
        # Parse the solution if it is in the form "x = 0.5, y = 0.5"
        if isinstance(solution, str) and ", " in solution:
            x_str, y_str = solution.split(", ")
            x = float(x_str.split(" = ")[1])
            y = float(y_str.split(" = ")[1])
            return x, y

    @staticmethod
    def get_circle_formula(x, y, r):
        # Return the algebraic expression
        return f"(x - {x})**2 + (y - {y})**2 = {r}**2"
    
    @staticmethod
    def get_ellipse_formula(x, y, rx, ry):
        # Return the algebraic expression
        return f"((x - {x})**2)/{rx}**2 + ((y - {y})**2)/{ry}**2 = 1"
    
    @staticmethod
    def sqrt(x):
        try:
            return window.math.format(window.math.sqrt(x))
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def pow(x, exp):
        try:
            return window.math.format(window.math.pow(x, exp))
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def det(matrix):
        try:
            return window.math.format(window.math.det(matrix))
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def convert(value, from_unit, to_unit):
        try:
            return window.math.format(window.math.evaluate(f"{value} {from_unit} to {to_unit}"))
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def evaluate(expression, variables=None):
        try:
            js_expression = ExpressionValidator.fix_math_expression(expression, python_compatible=False)
            python_expression = ExpressionValidator.fix_math_expression(expression, python_compatible=True)
            ExpressionValidator.validate_expression(python_expression)
            if not variables:
                return window.math.format(window.math.evaluate(js_expression))
            else:
                return window.math.format(window.math.evaluate(js_expression, variables))
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def derivative(expression, variable):
        try:
            return window.nerdamer(f"diff({expression}, {variable})").text()
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def limit(expression, variable, value_to_approach):
        try:
            value_to_approach = str(value_to_approach).lower().replace(' ', '')
            if value_to_approach in ['inf', 'infinity']:
                value_to_approach = 'Infinity'
            elif value_to_approach in ['-inf', '-infinity']:
                value_to_approach = '-Infinity'
            return window.nerdamer(f"limit({expression}, {variable}, {value_to_approach})").text()
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def integral(expression, variable, lower_bound=None, upper_bound=None):
        try:
            indefinite_integral = window.nerdamer(f"integrate({expression}, {variable})")
            if not lower_bound and not upper_bound:
                return indefinite_integral.text()
            evaluated_at_upper = indefinite_integral.sub(variable, upper_bound).text()
            evaluated_at_lower = indefinite_integral.sub(variable, lower_bound).text()
            return window.nerdamer(f"{evaluated_at_upper} - {evaluated_at_lower}").evaluate().text()
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def simplify(expression):
        try:
            return window.nerdamer(f"simplify({expression})").text()
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def expand(expression):
        try:
            return window.nerdamer(f"expand({expression})").text()
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def factor(expression):
        try:
            return window.nerdamer(f"factor({expression})").text()
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def solve(equation, variable):
        try:
            return window.nerdamer(f"solve({equation}, {variable})").text()
        except Exception as e:
            return f"Error: {getattr(e, 'message', str(e))}"
    
    @staticmethod
    def solve_system_of_equations(equations):
        try:
            solutions = window.nerdamer.solveEquations(equations)
            solution_strings = [f"{solution[0]} = {solution[1]}" for solution in solutions]
            return ', '.join(solution_strings)
        except Exception as e:  # Catch all exceptions
            # Assuming the message is in a standard format
            return f"Error: {getattr(e, 'message', str(e))}"

    @staticmethod
    def random(min_value=0, max_value=1):
        return random.uniform(min_value, max_value)

    @staticmethod
    def round(value, ndigits=0):
        return round(value, ndigits)

    @staticmethod
    def gcd(*values):
        return math.gcd(*values)

    @staticmethod
    def lcm(*values):
        return math.lcm(*values)

    @staticmethod
    def mean(values):
        return statistics.mean(values)

    @staticmethod
    def median(values):
        return statistics.median(values)

    @staticmethod
    def mode(values):
        return statistics.mode(values)

    @staticmethod
    def stdev(values):
        return statistics.stdev(values)

    @staticmethod
    def variance(values):
        return statistics.variance(values)
