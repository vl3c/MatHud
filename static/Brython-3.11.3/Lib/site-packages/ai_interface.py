from browser import document, html, ajax
from math_util import MathUtil
from process_function_calls import ProcessFunctionCalls
from constants import successful_call_message
import json
import traceback
from canvas import Canvas


class AIInterface:
    def __init__(self, canvas):
        self.canvas = canvas
        self.available_functions = {
            "reset_canvas": self.canvas.reset,
            "clear_canvas": self.canvas.clear,
            "create_point": self.canvas.create_point,
            "delete_point": self.canvas.delete_point,
            "create_segment": self.canvas.create_segment,
            "delete_segment": self.canvas.delete_segment,
            "create_vector": self.canvas.create_vector,
            "delete_vector": self.canvas.delete_vector,
            "create_triangle": self.canvas.create_triangle,
            "delete_triangle": self.canvas.delete_triangle,
            "create_rectangle": self.canvas.create_rectangle,
            "delete_rectangle": self.canvas.delete_rectangle,
            "create_circle": self.canvas.create_circle,
            "delete_circle": self.canvas.delete_circle,
            "create_ellipse": self.canvas.create_ellipse,
            "delete_ellipse": self.canvas.delete_ellipse,
            "draw_function": self.canvas.draw_function,
            "delete_function": self.canvas.delete_function,
            "translate_object": self.canvas.translate_object,
            "rotate_object": self.canvas.rotate_object,
            "evaluate_expression": ProcessFunctionCalls.evaluate_expression,
            "undo": self.canvas.undo,
            "redo": self.canvas.redo,
            "run_tests": self.run_tests,
            "convert": MathUtil.convert,
            "limit": MathUtil.limit,
            "derive": MathUtil.derivative,
            "integrate": MathUtil.integral,
            "simplify": MathUtil.simplify,
            "expand": MathUtil.expand,
            "factor": MathUtil.factor,
            "solve": MathUtil.solve,
            "solve_system_of_equations": MathUtil.solve_system_of_equations,
            "save_workspace": self.save_workspace,
            "load_workspace": self.load_workspace,
            "list_workspaces": self.list_workspaces,
            "delete_workspace": self.delete_workspace,
            "create_colored_area": self.canvas.create_colored_area,
            "delete_colored_area": self.canvas.delete_colored_area
        }
        self.undoable_functions = (
            "clear_canvas",
            "reset_canvas", 
            "create_point",
            "delete_point",
            "create_segment",
            "delete_segment",
            "create_vector", 
            "delete_vector",
            "create_triangle",
            "delete_triangle",
            "create_rectangle",
            "delete_rectangle",
            "create_circle",
            "delete_circle",
            "create_ellipse",
            "delete_ellipse",
            "draw_function",
            "delete_function",
            "translate_object",
            "rotate_object",
            "create_colored_area",
            "delete_colored_area"
        )

    def run_tests(self):
        """Run unit tests for the AIInterface class."""
        def test_graphics_drawing():
            function_calls = [
                {
                    "function_name": "create_point",
                    "arguments": {"x": -200, "y": 100, "name": "A"}
                },
                {
                    "function_name": "create_point",
                    "arguments": {"x": 250, "y": -150, "name": "B"}
                },
                {
                    "function_name": "create_segment",
                    "arguments": {"x1": -200, "y1": 100, "x2": 250, "y2": -150, "name": "AB"}
                },
                {
                    "function_name": "create_vector",
                    "arguments": {"origin_x": -150, "origin_y": -200, "tip_x": 100, "tip_y": 200, "name": "v1"}
                },
                {
                    "function_name": "create_triangle",
                    "arguments": {"x1": -100, "y1": -150, "x2": 120, "y2": 130, "x3": 150, "y3": -100, "name": "ABC"}
                },
                {
                    "function_name": "create_rectangle",
                    "arguments": {"px": -250, "py": 250, "opposite_px": 220, "opposite_py": -220, "name": "Rect1"}
                },
                {
                    "function_name": "create_circle",
                    "arguments": {"center_x": 0, "center_y": 0, "radius": 150, "name": "Circle1"}
                },
                {
                    "function_name": "create_ellipse",
                    "arguments": {"center_x": 200, "center_y": -100, "radius_x": 60, "radius_y": 90, "name": "Ellipse1"}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 50) + 50 * tan(x / 100)", "name": "f1", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 30)", "name": "f2", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "create_colored_area",
                    "arguments": {"drawable1_name": "f1", "drawable2_name": "f2", "color": "lightblue", "opacity": 0.3}
                },
                {
                    "function_name": "create_colored_area",
                    "arguments": {"drawable1_name": "f2", "drawable2_name": "x_axis", "color": "lightgreen", "opacity": 0.3}
                },
                {
                    "function_name": "delete_colored_area",
                    "arguments": {"name": "area_f1_f2"}
                },
                {
                    "function_name": "clear_canvas",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                },
                {
                    "function_name": "redo",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                }
            ]
            results = ProcessFunctionCalls.get_results(function_calls, self.available_functions, self.undoable_functions, self.canvas)
            print(f"Results of graphics drawing test: {results}")   # DEBUG
            return results

        def test_undoable_functions():
            for function_name in self.undoable_functions:
                if function_name not in self.available_functions:
                    raise Exception(f"Function '{function_name}' is not available.")
            print("All undoable functions are available.")   # DEBUG

        # Run the class unit tests
        print("Running AIInterface class unit tests...")
        test_graphics_drawing()
        test_undoable_functions()
        # Import tests module only when needed to avoid circular dependency
        try:
            from ClientTests import tests
            tests.run_tests()
        except ImportError:
            print("Client tests module not available - skipping additional tests")

    def _store_results_in_canvas_state(self, call_results):
        """Store valid function call results in the canvas state, skipping special cases and formatting values."""
        if not ProcessFunctionCalls.validate_results(call_results):
            return
            
        for key, value in call_results.items():
            # Skip storing workspace management functions in computations
            if key.startswith("list_workspaces") or \
               key.startswith("save_workspace") or \
               key.startswith("load_workspace"):
                continue

            if not ProcessFunctionCalls.is_successful_result(value):
                continue

            # Format numeric results consistently
            if isinstance(value, (int, float)):
                formatted_value = float(value)  # Always convert numeric values to float
            else:
                formatted_value = value
                
            self.canvas.add_computation(
                expression=key,  # The key is already the expression
                result=formatted_value
            )

    def _print_ai_message_in_chat(self, ai_message):
        """Print an AI message to the chat history and scroll to bottom."""
        if ai_message:
            ai_message = ai_message.replace('\n', '<br>')
            document["chat-history"] <= html.P(f'<strong>AI:</strong> {ai_message}', innerHTML=True)
            # Scroll the chat history to the bottom
            document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _print_user_message_in_chat(self, user_message):
        """Print a user message to the chat history, clear input field, and scroll to bottom."""
        # Add the user's message to the chat history
        document["chat-history"] <= html.P(f'<strong>User:</strong> {user_message}')
        # Clear the input field
        document["chat-input"].value = ''
        # Scroll the chat history to the bottom
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _debug_log_ai_response(self, ai_message, ai_function_calls, finish_reason):
        """Log debug information about the AI response."""
        print(f"### AI message: {ai_message}")
        print(f"### AI function calls: {ai_function_calls}")
        print(f"### AI finish reason: {finish_reason}")

    def _process_ai_response(self, ai_message, tool_calls, finish_reason):     
        self._debug_log_ai_response(ai_message, tool_calls, finish_reason)

        if finish_reason == "stop" or finish_reason == "error":
            self._print_ai_message_in_chat(ai_message)
        else: # finish_reason == "tool_calls" or "function_call"
            try:
                call_results = ProcessFunctionCalls.get_results(tool_calls, self.available_functions, self.undoable_functions, self.canvas)
                self._store_results_in_canvas_state(call_results)
                self._send_prompt_to_ai(None, json.dumps(call_results))
            except Exception as e:
                print(f"Error processing tool calls: {e}")
                traceback.print_exc()

    def _on_error(self, request):
        print(f"Error: {request.status}, {request.text}")

    def _on_complete(self, request):
        if request.status == 200 or request.status == 0:                
            # Extract data from the proper response structure
            response_data = request.json.get('data')
            if not response_data:
                error_msg = request.json.get('message', 'Invalid response format')
                print(f"Error: {error_msg}")
                document["ai-response"].text = error_msg
                return

            ai_message = response_data.get('ai_message')
            ai_function_calls = response_data.get('ai_tool_calls')
            finish_reason = response_data.get('finish_reason')

            # Parse the AI's response and create / delete drawables as needed
            self._process_ai_response(ai_message, ai_function_calls, finish_reason)
        else:
            self._on_error(request)

    def _create_request_payload(self, prompt, include_svg=True):
        """Create the JSON payload for the request, optionally including SVG state."""
        if not include_svg:
            return {'message': prompt}
            
        # Get the SVG element and its content
        svg_element = document["math-svg"]
        svg_content = svg_element.outerHTML
        
        # Get container dimensions
        container = document["math-container"]
        rect = container.getBoundingClientRect()
        
        return {
            'message': prompt,
            'svg_state': {
                'content': svg_content,
                'dimensions': {
                    'width': rect.width,
                    'height': rect.height
                },
                'viewBox': svg_element.getAttribute("viewBox"),
                'transform': svg_element.getAttribute("transform")
            }
        }

    def _make_request(self, payload):
        """Send an AJAX request with the given payload."""
        req = ajax.ajax()
        req.bind('complete', self._on_complete)
        req.bind('error', self._on_error)
        req.open('POST', '/send_message', True)
        req.set_header('content-type', 'application/json')
        req.send(json.dumps(payload))

    def _send_request(self, prompt):
        try:
            # Try to send request with SVG state
            payload = self._create_request_payload(prompt, include_svg=True)
            self._make_request(payload)
        except Exception as e:
            print(f"Error preparing request with SVG: {str(e)}")
            # Fall back to sending request without SVG state
            payload = self._create_request_payload(prompt, include_svg=False)
            self._make_request(payload)

    def _send_prompt_to_ai(self, user_message=None, tool_call_results=None):
        canvas_state = self.canvas.get_canvas_state()
        
        # Only use vision when we have a user message and no tool call results
        use_vision = document["vision-toggle"].checked and user_message is not None and tool_call_results is None
        
        prompt_json = {
            "canvas_state": canvas_state,
            "user_message": user_message,
            "tool_call_results": tool_call_results,
            "use_vision": use_vision,
            "ai_model": document["ai-model-selector"].value
        }
        
        # Convert to JSON string
        prompt = json.dumps(prompt_json)
        print(f'Prompt for AI: {prompt}')
        self._send_request(prompt)

    def interact_with_ai(self, event):            
        # Get the user's message from the input field
        user_message = document["chat-input"].value
        # Print the user message in chat
        self._print_user_message_in_chat(user_message)
        # Send the user's message to the AI
        self._send_prompt_to_ai(user_message)

    def save_workspace(self, name=None):
        """Save the current workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    message = f'Workspace "{name if name else "current"}" saved successfully'
                else:
                    message = f'Error saving workspace: {response.get("message")}'
                document["chat-history"] <= html.P(message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(message)
            except Exception as e:
                error_message = f'Error saving workspace: {str(e)}'
                document["chat-history"] <= html.P(error_message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(error_message)
            return successful_call_message

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: print(f'Error saving workspace: {e.text}'))
        
        data = {
            'state': self.canvas.get_canvas_state(),
            'name': name
        }
        
        req.open('POST', '/save_workspace', True)
        req.set_header('Content-Type', 'application/json')
        req.send(json.dumps(data))
        return successful_call_message

    def load_workspace(self, name=None):
        """Load a workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    state = response.get('data', {}).get('state')
                    if not state:
                        return f'Error loading workspace: No state data found in response'
                        
                    self.canvas.clear()
                    
                    # First, process all points
                    if "Points" in state:
                        for item_state in state["Points"]:
                            self.canvas.create_point(
                                item_state["args"]["position"]["x"], 
                                item_state["args"]["position"]["y"],
                                name=item_state.get("name", "")
                            )
                    
                    # Then process segments
                    if "Segments" in state:
                        for item_state in state["Segments"]:
                            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
                            if p1 and p2:
                                self.canvas.create_segment(
                                    p1.original_position.x,
                                    p1.original_position.y,
                                    p2.original_position.x,
                                    p2.original_position.y,
                                    name=item_state.get("name", "")
                                )

                    # Process vectors
                    if "Vectors" in state:
                        for item_state in state["Vectors"]:
                            self.canvas.create_vector(
                                item_state["args"]["origin_x"],
                                item_state["args"]["origin_y"], 
                                item_state["args"]["tip_x"],
                                item_state["args"]["tip_y"],
                                name=item_state.get("name", "")
                            )

                    # Process triangles
                    if "Triangles" in state:
                        for item_state in state["Triangles"]:
                            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
                            p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
                            if p1 and p2 and p3:
                                self.canvas.create_triangle(
                                    p1.original_position.x,
                                    p1.original_position.y,
                                    p2.original_position.x,
                                    p2.original_position.y,
                                    p3.original_position.x,
                                    p3.original_position.y,
                                    name=item_state.get("name", "")
                                )

                    # Process rectangles
                    if "Rectangles" in state:
                        for item_state in state["Rectangles"]:
                            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                            p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
                            if p1 and p3:
                                self.canvas.create_rectangle(
                                    p1.original_position.x,
                                    p1.original_position.y,
                                    p3.original_position.x,
                                    p3.original_position.y,
                                    name=item_state.get("name", "")
                                )

                    # Process circles
                    if "Circles" in state:
                        for item_state in state["Circles"]:
                            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
                            if center_point:
                                self.canvas.create_circle(
                                    center_point.original_position.x,
                                    center_point.original_position.y,
                                    item_state["args"]["radius"],
                                    name=item_state.get("name", "")
                                )

                    # Process ellipses
                    if "Ellipses" in state:
                        for item_state in state["Ellipses"]:
                            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
                            if center_point:
                                self.canvas.create_ellipse(
                                    center_point.original_position.x,
                                    center_point.original_position.y,
                                    item_state["args"]["radius_x"],
                                    item_state["args"]["radius_y"],
                                    rotation_angle=item_state["args"].get("rotation_angle", 0),
                                    name=item_state.get("name", "")
                                )

                    # Process functions
                    if "Functions" in state:
                        for item_state in state["Functions"]:
                            self.canvas.draw_function(
                                item_state["args"]["function_string"],
                                name=item_state.get("name", ""),
                                left_bound=item_state["args"].get("left_bound"),
                                right_bound=item_state["args"].get("right_bound")
                            )

                    # Process computations last
                    if "computations" in state:
                        for comp in state["computations"]:
                            # Skip workspace management functions
                            if comp["expression"].startswith("list_workspaces") or \
                               comp["expression"].startswith("save_workspace") or \
                               comp["expression"].startswith("load_workspace"):
                                continue
                            self.canvas.add_computation(comp["expression"], comp["result"])
                    
                    return f'Workspace "{name if name else "current"}" loaded successfully.'
                else:
                    return f'Error loading workspace: {response.get("message")}'
            except Exception as e:
                return f'Error loading workspace: {str(e)}'

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error loading workspace: {e.text}')
        
        url = f'/load_workspace?name={name}' if name else '/load_workspace'
        req.open('GET', url, False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def _handle_error(self, error_message):
        """Common error handling for workspace operations.
        
        Args:
            error_message: The error message to display
            
        Returns:
            str: The error message prefixed with 'Error: '
        """
        document["chat-history"] <= html.P(error_message, innerHTML=True)
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight
        print(error_message)
        return f"Error: {error_message}"

    def list_workspaces(self):
        """List all saved workspaces."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    workspaces = response.get('data', [])
                    result = ', '.join(workspaces) if workspaces else 'None'
                    return result
                return self._handle_error(f'Error listing workspaces: {response.get("message")}')
            except Exception as e:
                return self._handle_error(f'Error listing workspaces: {str(e)}')
                
        def on_error(e):
            error_msg = str(getattr(e, 'message', getattr(e, 'text', str(e))))
            return self._handle_error(f'Error listing workspaces: {error_msg}')
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', on_error)
        
        req.open('GET', '/list_workspaces', False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def delete_workspace(self, name):
        """Delete a workspace."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    message = f'Workspace "{name}" deleted successfully'
                    document["chat-history"] <= html.P(message, innerHTML=True)
                    document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                    print(message)
                else:
                    self._handle_error(f'Error deleting workspace: {response.get("message")}')
            except Exception as e:
                self._handle_error(f'Error deleting workspace: {str(e)}')
            return successful_call_message
                
        def on_error(e):
            # Extract the actual error message from the JavaScript Error object
            error_msg = str(getattr(e, 'message', getattr(e, 'text', str(e))))
            self._handle_error(f'Error deleting workspace: {error_msg}')
            return successful_call_message
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', on_error)
        
        url = f'/delete_workspace?name={name}'
        req.open('GET', url, True)
        req.send()
        return successful_call_message