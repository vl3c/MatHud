from browser import document, html, ajax
from math_util import MathUtil
from process_function_calls import ProcessFunctionCalls
from constants import successful_call_message
import json
import traceback
from canvas import Canvas


class AIInterface:
    def __init__(self, canvas):
        self.canvas = canvas
        self.multi_step_mode_enabled = False
        self.available_functions = {
            "reset_canvas": self.canvas.reset,
            "clear_canvas": self.canvas.clear,
            "create_point": self.canvas.create_point,
            "delete_point": self.canvas.delete_point,
            "create_segment": self.canvas.create_segment,
            "delete_segment": self.canvas.delete_segment,
            "create_vector": self.canvas.create_vector,
            "delete_vector": self.canvas.delete_vector,
            "create_triangle": self.canvas.create_triangle,
            "delete_triangle": self.canvas.delete_triangle,
            "create_rectangle": self.canvas.create_rectangle,
            "delete_rectangle": self.canvas.delete_rectangle,
            "create_circle": self.canvas.create_circle,
            "delete_circle": self.canvas.delete_circle,
            "create_ellipse": self.canvas.create_ellipse,
            "delete_ellipse": self.canvas.delete_ellipse,
            "draw_function": self.canvas.draw_function,
            "delete_function": self.canvas.delete_function,
            "translate_object": self.canvas.translate_object,
            "rotate_object": self.canvas.rotate_object,
            "evaluate_expression": ProcessFunctionCalls.evaluate_expression,
            "undo": self.canvas.undo,
            "redo": self.canvas.redo,
            "run_tests": self.run_tests,
            "convert": MathUtil.convert,
            "limit": MathUtil.limit,
            "derive": MathUtil.derivative,
            "integrate": MathUtil.integral,
            "simplify": MathUtil.simplify,
            "expand": MathUtil.expand,
            "factor": MathUtil.factor,
            "solve": MathUtil.solve,
            "solve_system_of_equations": MathUtil.solve_system_of_equations,
            "enable_multi_step_mode": None,
            "save_workspace": self.save_workspace,
            "load_workspace": self.load_workspace,
            "list_workspaces": self.list_workspaces,
            "delete_workspace": self.delete_workspace
        }
        self.undoable_functions = (
            "clear_canvas",
            "reset_canvas", 
            "create_point",
            "delete_point",
            "create_segment",
            "delete_segment",
            "create_vector", 
            "delete_vector",
            "create_triangle",
            "delete_triangle",
            "create_rectangle",
            "delete_rectangle",
            "create_circle",
            "delete_circle",
            "create_ellipse",
            "delete_ellipse",
            "draw_function",
            "delete_function",
            "translate_object",
            "rotate_object"
        )

    def run_tests(self):
        """Run unit tests for the AIInterface class."""
        def test_graphics_drawing():
            function_calls = [
                {
                    "function_name": "create_point",
                    "arguments": {"x": -200, "y": 100, "name": "A"}
                },
                {
                    "function_name": "create_point",
                    "arguments": {"x": 250, "y": -150, "name": "B"}
                },
                {
                    "function_name": "create_segment",
                    "arguments": {"x1": -200, "y1": 100, "x2": 250, "y2": -150, "name": "AB"}
                },
                {
                    "function_name": "create_vector",
                    "arguments": {"origin_x": -150, "origin_y": -200, "tip_x": 100, "tip_y": 200, "name": "v1"}
                },
                {
                    "function_name": "create_triangle",
                    "arguments": {"x1": -100, "y1": -150, "x2": 120, "y2": 130, "x3": 150, "y3": -100, "name": "ABC"}
                },
                {
                    "function_name": "create_rectangle",
                    "arguments": {"px": -250, "py": 250, "opposite_px": 220, "opposite_py": -220, "name": "Rect1"}
                },
                {
                    "function_name": "create_circle",
                    "arguments": {"center_x": 0, "center_y": 0, "radius": 150, "name": "Circle1"}
                },
                {
                    "function_name": "create_ellipse",
                    "arguments": {"center_x": 200, "center_y": -100, "radius_x": 60, "radius_y": 90, "name": "Ellipse1"}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 50) + 50 * tan(x / 100)", "name": "f1", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 30)", "name": "f2", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "clear_canvas",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                },
                {
                    "function_name": "redo",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                }
            ]
            results, _ = ProcessFunctionCalls.get_results(function_calls, self.available_functions, self.undoable_functions, self.canvas)
            print(f"Results of graphics drawing test: {results}")   # DEBUG
            return results

        def test_undoable_functions():
            for function_name in self.undoable_functions:
                if function_name not in self.available_functions:
                    raise Exception(f"Function '{function_name}' is not available.")
            print("All undoable functions are available.")   # DEBUG

        def test_create_ai_response_text():
            test_cases = [
                ("", {"result1": ""}, "..."),
                ("", {"result1": 42, "result2": "x = 42"}, "result1: 42\nresult2: x = 42"),
                ("Test response.", {"result1": ""}, "Test response."),
                ("Test response.", {"result1": 42, "result2": "something", "result3": "x = 42"}, "Test response.\nresult1: 42\nresult2: something\nresult3: x = 42")
            ]
            for ai_response, call_results, expected_output in test_cases:
                output = self._create_ai_response_text(ai_response, call_results)
                assert output == expected_output, f"Expected '{expected_output}', got '{output}'"
            print("All create_ai_message tests passed.")   # DEBUG

        def test_build_prompt():
            canvas_state = {"objects": [], "computations": [{"description": "test", "expression": "1+1", "result": 2}]}
            user_message = "User message"
            prompt = self._build_prompt(canvas_state, user_message)
            assert isinstance(prompt, str), "Prompt should be a string."
            # Verify the prompt contains the computation
            prompt_json = json.loads(prompt)
            assert "computations" in prompt_json["canvas_state"], "Canvas state should include computations"
            print("build_prompt test passed.")   # DEBUG

        # Run the class unit tests
        print("Running AIInterface class unit tests...")
        test_graphics_drawing()
        test_undoable_functions()
        test_create_ai_response_text()
        test_build_prompt()
        # Import tests module only when needed to avoid circular dependency
        try:
            from ClientTests import tests
            tests.run_tests()
        except ImportError:
            print("Client tests module not available - skipping additional tests")

    def _create_ai_response_text(self, ai_response, call_results):
        if not isinstance(call_results, dict):
            raise ValueError("Invalid input for call_results. Expected a dictionary.")
            
        ai_response_text = ai_response if ai_response else "..."
        if call_results and ProcessFunctionCalls.validate_results(call_results):
            call_results_text = '\n'.join([f"{key}: {value}" for key, value in call_results.items() 
                                         if ProcessFunctionCalls.is_successful_result(value)])
            if call_results_text:  # If there's meaningful call_results_text
                if ai_response_text != "...":
                    ai_response_text += '\n' + call_results_text
                else:
                    ai_response_text = call_results_text
        # Avoid showing "..." if the AI requested intermediate results
        if self.multi_step_mode_enabled and ai_response_text == "...":
            return ""
        return ai_response_text

    def _create_ai_intermediate_request_text(self, ai_response, call_results):
        if not isinstance(call_results, dict):
            raise ValueError("Invalid input for call_results. Expected a dictionary.")
        
        # Only create results text if we have valid results
        if call_results and ProcessFunctionCalls.validate_results(call_results):
            # Separate errors and successful results
            errors = []
            successful_results = []
            
            for key, value in call_results.items():
                # Skip multi_step_mode messages
                if key == "multi_step_mode":
                    continue
                if not ProcessFunctionCalls.is_successful_result(value):
                    if isinstance(value, str) and value.startswith("Error:"):
                        errors.append(f"{key}: {value}")
                else:
                    successful_results.append(f"{key}: {value}")
            
            message_parts = []
            if errors:
                message_parts.append("I encountered some errors that need to be addressed:")
                message_parts.extend(errors)
            
            if successful_results:
                if errors:
                    message_parts.append("\nHowever, these operations were successful:")
                else:
                    message_parts.append("I requested some intermediate results:")
                message_parts.extend(successful_results)
            
            if message_parts:
                return "\n".join(message_parts)
        
        # Return empty string if no results to show
        return ""

    def _parse_ai_response(self, ai_message, ai_function_calls):
        try:
            # Load the JSON from the AI's reply and call the appropriate functions
            print(f"AI message: {ai_message}")   # DEBUG
            print(f"AI function calls: {ai_function_calls}")   # DEBUG
            
            # Get the results of the AI's function calls
            call_results, self.multi_step_mode_enabled = ProcessFunctionCalls.get_results(ai_function_calls, self.available_functions, self.undoable_functions, self.canvas)
            
            # Store valid results in canvas state
            if ProcessFunctionCalls.validate_results(call_results):
                for key, value in call_results.items():
                    # Skip storing multi_step_mode in computations
                    if key == "multi_step_mode":
                        continue
                    # Skip storing workspace management functions in computations
                    if key.startswith("list_workspaces") or \
                       key.startswith("save_workspace") or \
                       key.startswith("load_workspace"):
                        continue
                    if ProcessFunctionCalls.is_successful_result(value):
                        self.canvas.add_computation(
                            expression=key,  # The key is already the expression
                            result=value
                        )
            
            # Get the appropriate response text
            ai_response_text = ""
            if ai_message and ai_message.strip():  # If there's a non-empty AI message
                ai_response_text = ai_message
            
            # Add function call results if in multi-step mode and there are results
            if self.multi_step_mode_enabled and call_results:
                intermediate_results = self._create_ai_intermediate_request_text(ai_message, call_results)
                if intermediate_results:
                    if ai_response_text:
                        ai_response_text += '\n' + intermediate_results
                    else:
                        ai_response_text = intermediate_results
            else:
                # For non-multi-step mode, use the original response text creation
                ai_response_text = self._create_ai_response_text(ai_message, call_results)
            
            # Only add to chat history if we have a response to show
            if ai_response_text:
                ai_response_text = ai_response_text.replace('\n', '<br>')
                document["chat-history"] <= html.P(f'<strong>AI:</strong> {ai_response_text}', innerHTML=True)

            print(f"AI requested intermediate results: {self.multi_step_mode_enabled}")   # DEBUG
            print(f"Call results: {call_results}")   # DEBUG
            
            # Check if we're in multi-step mode and need to proceed
            if self.multi_step_mode_enabled:
                if not call_results or ("multi_step_mode" in call_results and len(call_results) == 1):
                    self._send_prompt_to_ai("Please proceed with the next steps in solving this problem. DO NOT call enable_multi_step_mode by itself again.")
                else:
                    self._send_prompt_to_ai("I've saved the results of your calculations in the canvas state. You can now use these results in your next actions. Please proceed with the next steps in solving this problem.")

        except Exception as e:
            print(f"Error while processing AI's response: {e}")
            traceback.print_exc()
        finally:
            # Scroll the chat history to the bottom
            document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _build_prompt(self, canvas_state, user_message):
        # Add multi_step_mode_enabled to canvas state
        canvas_state["multi_step_mode_enabled"] = self.multi_step_mode_enabled
        # Canvas state already includes computations
        prompt = json.dumps({"canvas_state": canvas_state, "user_message": user_message})
        return prompt

    def _on_error(self, request):
        print(f"Error: {request.status}, {request.text}")

    def _on_complete(self, request):
        if request.status == 200 or request.status == 0:
            ai_response = request.json
            ai_message, ai_function_calls = ai_response.get('ai_message'), ai_response.get('ai_tool_calls')
            # Parse the AI's response and create / delete drawables as needed
            self._parse_ai_response(ai_message, ai_function_calls)
        else:
            self._on_error(request)

    def _send_request(self, prompt):
        try:
            # Get the SVG element and its content
            svg_element = document["math-svg"]
            svg_content = svg_element.outerHTML
            
            # Get container dimensions
            container = document["math-container"]
            rect = container.getBoundingClientRect()
            
            # Create request with original message format plus SVG state
            req = ajax.ajax()
            req.bind('complete', self._on_complete)
            req.bind('error', self._on_error)
            req.open('POST', '/send_message', True)
            req.set_header('content-type', 'application/json')
            req.send(json.dumps({
                'message': prompt,
                'svg_state': {
                    'content': svg_content,
                    'dimensions': {
                        'width': rect.width,
                        'height': rect.height
                    },
                    'viewBox': svg_element.getAttribute("viewBox"),
                    'transform': svg_element.getAttribute("transform")
                }
            }))
        except Exception as e:
            print(f"Error preparing request: {str(e)}")
            # Still send the original request if SVG capture fails
            req = ajax.ajax()
            req.bind('complete', self._on_complete)
            req.bind('error', self._on_error)
            req.open('POST', '/send_message', True)
            req.set_header('content-type', 'application/json')
            req.send(json.dumps({'message': prompt}))

    def _send_prompt_to_ai(self, user_message=""):
        # Get the canvas state with on-screen drawables original properties 
        canvas_state = self.canvas.get_canvas_state()
        # Get vision toggle state
        use_vision = document["vision-toggle"].checked
        # Build and send the prompt for the AI
        prompt = self._build_prompt(canvas_state, user_message)
        prompt_json = json.loads(prompt)
        prompt_json["use_vision"] = use_vision
        prompt = json.dumps(prompt_json)
        print(f'Prompt for AI: {prompt}')
        self._send_request(prompt)

    # Send message, receive response from the AI and call functions as needed
    def interact_with_ai(self, event):            
        # Get the user's message from the input field
        user_message = document["chat-input"].value
        # Add the user's message to the chat history
        document["chat-history"] <= html.P(f'<strong>User:</strong> {user_message}')
        # Clear the input field
        document["chat-input"].value = ''
        # Scroll the chat history to the bottom
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight
        # Send the user's message to the AI
        self._send_prompt_to_ai(user_message)

    def save_workspace(self, name=None):
        """Save the current workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    message = f'Workspace "{name if name else "current"}" saved successfully'
                else:
                    message = f'Error saving workspace: {response.get("message")}'
                document["chat-history"] <= html.P(message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(message)
            except Exception as e:
                error_message = f'Error saving workspace: {str(e)}'
                document["chat-history"] <= html.P(error_message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(error_message)
            return successful_call_message

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: print(f'Error saving workspace: {e.text}'))
        
        data = {
            'state': self.canvas.get_canvas_state(),
            'name': name
        }
        
        req.open('POST', '/save_workspace', True)
        req.set_header('Content-Type', 'application/json')
        req.send(json.dumps(data))
        return successful_call_message

    def load_workspace(self, name=None):
        """Load a workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    state = response['state']
                    self.canvas.clear()
                    
                    # First, process all points
                    if "Points" in state:
                        for item_state in state["Points"]:
                            self.canvas.create_point(
                                item_state["args"]["position"]["x"], 
                                item_state["args"]["position"]["y"],
                                name=item_state.get("name", "")
                            )
                    
                    # Then process other drawables
                    for category, items in state.items():
                        if category == "computations":
                            for comp in items:
                                # Skip workspace management functions
                                if comp["expression"].startswith("list_workspaces") or \
                                   comp["expression"].startswith("save_workspace") or \
                                   comp["expression"].startswith("load_workspace"):
                                    continue
                                self.canvas.add_computation(comp["expression"], comp["result"])
                            continue
                            
                        if not category.endswith('s') or category == "Points":  # Skip non-collection keys and Points (already processed)
                            continue
                            
                        category_name = category[:-1]  # Remove 's' to get the class name
                        for item_state in items:
                            if category_name == "Point":
                                self.canvas.create_point(
                                    item_state["args"]["position"]["x"], 
                                    item_state["args"]["position"]["y"],
                                    name=item_state.get("name", "")
                                )
                            elif category_name == "Segment":
                                p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                                p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
                                if p1 and p2:
                                    self.canvas.create_segment(
                                        p1.original_position.x,
                                        p1.original_position.y,
                                        p2.original_position.x,
                                        p2.original_position.y,
                                        name=item_state.get("name", "")
                                    )
                            elif category_name == "Triangle":
                                p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                                p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
                                p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
                                if p1 and p2 and p3:
                                    self.canvas.create_triangle(
                                        p1.original_position.x,
                                        p1.original_position.y,
                                        p2.original_position.x,
                                        p2.original_position.y,
                                        p3.original_position.x,
                                        p3.original_position.y,
                                        name=item_state.get("name", "")
                                    )
                            elif category_name == "Rectangle":
                                p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                                p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
                                if p1 and p3:
                                    self.canvas.create_rectangle(
                                        p1.original_position.x,
                                        p1.original_position.y,
                                        p3.original_position.x,
                                        p3.original_position.y,
                                        name=item_state.get("name", "")
                                    )
                            elif category_name == "Circle":
                                # Get the center point by name
                                center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
                                if center_point:
                                    self.canvas.create_circle(
                                        center_point.original_position.x,
                                        center_point.original_position.y,
                                        item_state["args"]["radius"],
                                        name=item_state.get("name", "")
                                    )
                            elif category_name == "Ellipse":
                                center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
                                if center_point:
                                    self.canvas.create_ellipse(
                                        center_point.original_position.x,
                                        center_point.original_position.y,
                                        item_state["args"]["radius_x"],
                                        item_state["args"]["radius_y"],
                                        rotation_angle=item_state["args"].get("rotation_angle", 0),
                                        name=item_state.get("name", "")
                                    )
                            elif category_name == "Function":
                                self.canvas.draw_function(
                                    item_state["args"]["function_string"],
                                    name=item_state.get("name", ""),
                                    left_bound=item_state["args"].get("left_bound"),
                                    right_bound=item_state["args"].get("right_bound")
                                )
                    message = f'Workspace "{name if name else "current"}" loaded successfully.'
                    document["chat-history"] <= html.P(message, innerHTML=True)
                    document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                    print(message)
                else:
                    error_message = f'Error loading workspace: {response.get("message")}'
                    document["chat-history"] <= html.P(error_message, innerHTML=True)
                    document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                    print(error_message)
            except Exception as e:
                error_message = f'Error loading workspace: {str(e)}'
                document["chat-history"] <= html.P(error_message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(error_message)
            return successful_call_message

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: print(f'Error loading workspace: {e.text}'))
        
        url = f'/load_workspace?name={name}' if name else '/load_workspace'
        req.open('GET', url, True)
        req.send()
        return successful_call_message

    def list_workspaces(self):
        """List all saved workspaces."""
        def on_complete(req):
            try:
                workspaces = json.loads(req.text)
                workspace_list = ', '.join(workspaces) if workspaces else 'None'
                
                # Send the workspace list to the AI
                self._send_prompt_to_ai(f"Available workspaces: {workspace_list}")
                
                return successful_call_message
            except Exception as e:
                error_message = f'Error listing workspaces: {str(e)}'
                document["chat-history"] <= html.P(error_message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(error_message)
                return successful_call_message
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: print(f'Error listing workspaces: {e.text}'))
        
        req.open('GET', '/list_workspaces', True)
        req.send()
        return successful_call_message

    def delete_workspace(self, name):
        """Delete a workspace."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    message = f'Workspace "{name}" deleted successfully'
                else:
                    message = f'Error deleting workspace: {response.get("message")}'
                document["chat-history"] <= html.P(message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(message)
            except Exception as e:
                error_message = f'Error deleting workspace: {str(e)}'
                document["chat-history"] <= html.P(error_message, innerHTML=True)
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
                print(error_message)
            return successful_call_message
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: print(f'Error deleting workspace: {e.text}'))
        
        url = f'/delete_workspace?name={name}'
        req.open('GET', url, True)
        req.send()
        return successful_call_message