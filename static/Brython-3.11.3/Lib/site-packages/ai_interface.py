from browser import document, html, ajax
from math_util import MathUtil
from process_function_calls import ProcessFunctionCalls
from constants import successful_call_message
import json
import Tests.tests as tests
import traceback

class AIInterface:
    def __init__(self, canvas):
        self.canvas = canvas
        self.multi_step_mode_enabled = False
        self.available_functions = {
            "reset_canvas": self.canvas.reset,
            "clear_canvas": self.canvas.clear,
            "create_point": self.canvas.create_point,
            "delete_point": self.canvas.delete_point,
            "create_segment": self.canvas.create_segment,
            "delete_segment": self.canvas.delete_segment,
            "create_vector": self.canvas.create_vector,
            "delete_vector": self.canvas.delete_vector,
            "create_triangle": self.canvas.create_triangle,
            "delete_triangle": self.canvas.delete_triangle,
            "create_rectangle": self.canvas.create_rectangle,
            "delete_rectangle": self.canvas.delete_rectangle,
            "create_circle": self.canvas.create_circle,
            "delete_circle": self.canvas.delete_circle,
            "create_ellipse": self.canvas.create_ellipse,
            "delete_ellipse": self.canvas.delete_ellipse,
            "draw_function": self.canvas.draw_function,
            "delete_function": self.canvas.delete_function,
            "translate_object": self.canvas.translate_object,
            "rotate_object": self.canvas.rotate_object,
            "evaluate_expression": ProcessFunctionCalls.evaluate_expression,
            "undo": self.canvas.undo,
            "redo": self.canvas.redo,
            "run_tests": self.run_tests,
            "convert": MathUtil.convert,
            "limit": MathUtil.limit,
            "derive": MathUtil.derivative,
            "integrate": MathUtil.integral,
            "simplify": MathUtil.simplify,
            "expand": MathUtil.expand,
            "factor": MathUtil.factor,
            "solve": MathUtil.solve,
            "solve_system_of_equations": MathUtil.solve_system_of_equations,
            "enable_multi_step_mode": None
        }
        self.undoable_functions = (
            "clear_canvas",
            "reset_canvas", 
            "create_point",
            "delete_point",
            "create_segment",
            "delete_segment",
            "create_vector", 
            "delete_vector",
            "create_triangle",
            "delete_triangle",
            "create_rectangle",
            "delete_rectangle",
            "create_circle",
            "delete_circle",
            "create_ellipse",
            "delete_ellipse",
            "draw_function",
            "delete_function",
            "translate_object",
            "rotate_object"
        )

    def run_tests(self):
        def test_graphics_drawing():
            function_calls = [
                {
                    "function_name": "create_point",
                    "arguments": {"x": -200, "y": 100, "name": "A"}
                },
                {
                    "function_name": "create_point",
                    "arguments": {"x": 250, "y": -150, "name": "B"}
                },
                {
                    "function_name": "create_segment",
                    "arguments": {"x1": -200, "y1": 100, "x2": 250, "y2": -150, "name": "AB"}
                },
                {
                    "function_name": "create_vector",
                    "arguments": {"origin_x": -150, "origin_y": -200, "tip_x": 100, "tip_y": 200, "name": "v1"}
                },
                {
                    "function_name": "create_triangle",
                    "arguments": {"x1": -100, "y1": -150, "x2": 120, "y2": 130, "x3": 150, "y3": -100, "name": "ABC"}
                },
                {
                    "function_name": "create_rectangle",
                    "arguments": {"px": -250, "py": 250, "opposite_px": 220, "opposite_py": -220, "name": "Rect1"}
                },
                {
                    "function_name": "create_circle",
                    "arguments": {"center_x": 0, "center_y": 0, "radius": 150, "name": "Circle1"}
                },
                {
                    "function_name": "create_ellipse",
                    "arguments": {"center_x": 200, "center_y": -100, "radius_x": 60, "radius_y": 90, "name": "Ellipse1"}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 50) + 50 * tan(x / 100)", "name": "f1", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 30)", "name": "f2", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "clear_canvas",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                },
                {
                    "function_name": "redo",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                }
            ]
            results, _ = ProcessFunctionCalls.get_results(function_calls, self.available_functions, self.undoable_functions, self.canvas)
            print(f"Results of graphics drawing test: {results}")   # DEBUG
            return results

        def test_undoable_functions():
            for function_name in self.undoable_functions:
                if function_name not in self.available_functions:
                    raise Exception(f"Function '{function_name}' is not available.")
            print("All undoable functions are available.")   # DEBUG

        def test_create_ai_response_text():
            test_cases = [
                ("", {"result1": ""}, "..."),
                ("", {"result1": 42, "result2": "x = 42"}, "result1: 42\nresult2: x = 42"),
                ("Test response.", {"result1": ""}, "Test response."),
                ("Test response.", {"result1": 42, "result2": "something", "result3": "x = 42"}, "Test response.\nresult1: 42\nresult2: something\nresult3: x = 42")
            ]
            for ai_response, call_results, expected_output in test_cases:
                output = self._create_ai_response_text(ai_response, call_results)
                assert output == expected_output, f"Expected '{expected_output}', got '{output}'"
            print("All create_ai_message tests passed.")   # DEBUG

        def test_build_prompt():
            canvas_state = {"objects": [], "computations": [{"description": "test", "expression": "1+1", "result": 2}]}
            user_message = "User message"
            prompt = self._build_prompt(canvas_state, user_message)
            assert isinstance(prompt, str), "Prompt should be a string."
            # Verify the prompt contains the computation
            prompt_json = json.loads(prompt)
            assert "computations" in prompt_json["canvas_state"], "Canvas state should include computations"
            print("build_prompt test passed.")   # DEBUG

        # Run the class unit tests
        print("Running AIInterface class unit tests...")
        test_graphics_drawing()
        test_undoable_functions()
        test_create_ai_response_text()
        test_build_prompt()
        tests.run_tests()

    def _create_ai_response_text(self, ai_response, call_results):
        if not isinstance(call_results, dict):
            raise ValueError("Invalid input for call_results. Expected a dictionary.")
        ai_response_text = ai_response if ai_response else "..."
        if call_results and ProcessFunctionCalls.validate_results(call_results):
            call_results_text = '\n'.join([f"{key}: {value}" for key, value in call_results.items() 
                                         if ProcessFunctionCalls.is_successful_result(value)])
            if call_results_text:  # If there's meaningful call_results_text
                if ai_response_text != "...":
                    ai_response_text += '\n' + call_results_text
                else:
                    ai_response_text = call_results_text
        # Avoid showing "..." if the AI requested intermediate results
        if self.multi_step_mode_enabled and ai_response_text == "...":
            return ""
        return ai_response_text

    def _create_ai_intermediate_request_text(self, ai_response, call_results):
        if not isinstance(call_results, dict):
            raise ValueError("Invalid input for call_results. Expected a dictionary.")
        
        # Only create results text if we have valid results
        if call_results and ProcessFunctionCalls.validate_results(call_results):
            # Separate errors and successful results
            errors = []
            successful_results = []
            
            for key, value in call_results.items():
                # Skip multi_step_mode messages
                if key == "multi_step_mode":
                    continue
                if not ProcessFunctionCalls.is_successful_result(value):
                    if isinstance(value, str) and value.startswith("Error:"):
                        errors.append(f"{key}: {value}")
                else:
                    successful_results.append(f"{key}: {value}")
            
            message_parts = []
            if errors:
                message_parts.append("I encountered some errors that need to be addressed:")
                message_parts.extend(errors)
            
            if successful_results:
                if errors:
                    message_parts.append("\nHowever, these operations were successful:")
                else:
                    message_parts.append("I requested some intermediate results:")
                message_parts.extend(successful_results)
            
            if message_parts:
                return "\n".join(message_parts)
        
        # Return empty string if no results to show
        return ""

    def _parse_ai_response(self, ai_message, ai_function_calls):
        try:
            # Load the JSON from the AI's reply and call the appropriate functions
            print(f"AI message: {ai_message}")   # DEBUG
            print(f"AI function calls: {ai_function_calls}")   # DEBUG
            
            # Get the results of the AI's function calls
            call_results, self.multi_step_mode_enabled = ProcessFunctionCalls.get_results(ai_function_calls, self.available_functions, self.undoable_functions, self.canvas)
            
            # Store valid results in canvas state
            if ProcessFunctionCalls.validate_results(call_results):
                for key, value in call_results.items():
                    # Skip storing multi_step_mode in computations
                    if key == "multi_step_mode":
                        continue
                    if ProcessFunctionCalls.is_successful_result(value):
                        self.canvas.add_computation(
                            expression=key,  # The key is already the expression
                            result=value
                        )
            
            # Get the appropriate response text
            ai_response_text = ""
            if ai_message and ai_message.strip():  # If there's a non-empty AI message
                ai_response_text = ai_message
            
            # Add function call results if in multi-step mode and there are results
            if self.multi_step_mode_enabled and call_results:
                intermediate_results = self._create_ai_intermediate_request_text(ai_message, call_results)
                if intermediate_results:
                    if ai_response_text:
                        ai_response_text += '\n' + intermediate_results
                    else:
                        ai_response_text = intermediate_results
            else:
                # For non-multi-step mode, use the original response text creation
                ai_response_text = self._create_ai_response_text(ai_message, call_results)
            
            # Only add to chat history if we have a response to show
            if ai_response_text:
                ai_response_text = ai_response_text.replace('\n', '<br>')
                document["chat-history"] <= html.P(f'<strong>AI:</strong> {ai_response_text}', innerHTML=True)

            print(f"AI requested intermediate results: {self.multi_step_mode_enabled}")   # DEBUG
            print(f"Call results: {call_results}")   # DEBUG
            
            # Check if we're in multi-step mode and need to proceed
            if self.multi_step_mode_enabled:
                if not call_results or ("multi_step_mode" in call_results and len(call_results) == 1):
                    self._send_prompt_to_ai("Please proceed with the next steps in solving this problem. DO NOT call enable_multi_step_mode by itself again.")
                else:
                    self._send_prompt_to_ai("I've saved the results of your calculations in the canvas state. You can now use these results in your next actions. Please proceed with the next steps in solving this problem.")

        except Exception as e:
            print(f"Error while processing AI's response: {e}")
            traceback.print_exc()
        finally:
            # Scroll the chat history to the bottom
            document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _build_prompt(self, canvas_state, user_message):
        # Add multi_step_mode_enabled to canvas state
        canvas_state["multi_step_mode_enabled"] = self.multi_step_mode_enabled
        # Canvas state already includes computations
        prompt = json.dumps({"canvas_state": canvas_state, "user_message": user_message})
        return prompt

    def _on_error(self, request):
        print(f"Error: {request.status}, {request.text}")

    def _on_complete(self, request):
        if request.status == 200 or request.status == 0:
            ai_response = request.json
            ai_message, ai_function_calls = ai_response.get('ai_message'), ai_response.get('ai_tool_calls')
            # Parse the AI's response and create / delete drawables as needed
            self._parse_ai_response(ai_message, ai_function_calls)
        else:
            self._on_error(request)

    def _send_request(self, prompt):
        try:
            # Get the SVG element and its content
            svg_element = document["math-svg"]
            svg_content = svg_element.outerHTML
            
            # Get container dimensions
            container = document["math-container"]
            rect = container.getBoundingClientRect()
            
            # Create request with original message format plus SVG state
            req = ajax.ajax()
            req.bind('complete', self._on_complete)
            req.bind('error', self._on_error)
            req.open('POST', '/send_message', True)
            req.set_header('content-type', 'application/json')
            req.send(json.dumps({
                'message': prompt,
                'svg_state': {
                    'content': svg_content,
                    'dimensions': {
                        'width': rect.width,
                        'height': rect.height
                    },
                    'viewBox': svg_element.getAttribute("viewBox"),
                    'transform': svg_element.getAttribute("transform")
                }
            }))
        except Exception as e:
            print(f"Error preparing request: {str(e)}")
            # Still send the original request if SVG capture fails
            req = ajax.ajax()
            req.bind('complete', self._on_complete)
            req.bind('error', self._on_error)
            req.open('POST', '/send_message', True)
            req.set_header('content-type', 'application/json')
            req.send(json.dumps({'message': prompt}))

    def _send_prompt_to_ai(self, user_message=""):
        # Get the canvas state with on-screen drawables original properties 
        canvas_state = self.canvas.get_canvas_state()
        # Get vision toggle state
        use_vision = document["vision-toggle"].checked
        # Build and send the prompt for the AI
        prompt = self._build_prompt(canvas_state, user_message)
        prompt_json = json.loads(prompt)
        prompt_json["use_vision"] = use_vision
        prompt = json.dumps(prompt_json)
        print(f'Prompt for AI: {prompt}')
        self._send_request(prompt)

    # Send message, receive response from the AI and call functions as needed
    def interact_with_ai(self, event):            
        # Get the user's message from the input field
        user_message = document["chat-input"].value
        # Add the user's message to the chat history
        document["chat-history"] <= html.P(f'<strong>User:</strong> {user_message}')
        # Clear the input field
        document["chat-input"].value = ''
        # Scroll the chat history to the bottom
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight
        # Send the user's message to the AI
        self._send_prompt_to_ai(user_message)