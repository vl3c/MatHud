from browser import document, html, ajax
from math_util import MathUtil
from process_function_calls import ProcessFunctionCalls
from workspace_manager import WorkspaceManager
import json
import traceback
from canvas import Canvas


class AIInterface:
    def __init__(self, canvas):
        self.canvas = canvas
        self.workspace_manager = WorkspaceManager(canvas)
        self.available_functions = {
            "reset_canvas": self.canvas.reset,
            "clear_canvas": self.canvas.clear,
            "create_point": self.canvas.create_point,
            "delete_point": self.canvas.delete_point,
            "create_segment": self.canvas.create_segment,
            "delete_segment": self.canvas.delete_segment,
            "create_vector": self.canvas.create_vector,
            "delete_vector": self.canvas.delete_vector,
            "create_triangle": self.canvas.create_triangle,
            "delete_triangle": self.canvas.delete_triangle,
            "create_rectangle": self.canvas.create_rectangle,
            "delete_rectangle": self.canvas.delete_rectangle,
            "create_circle": self.canvas.create_circle,
            "delete_circle": self.canvas.delete_circle,
            "create_ellipse": self.canvas.create_ellipse,
            "delete_ellipse": self.canvas.delete_ellipse,
            "draw_function": self.canvas.draw_function,
            "delete_function": self.canvas.delete_function,
            "translate_object": self.canvas.translate_object,
            "rotate_object": self.canvas.rotate_object,
            "evaluate_expression": ProcessFunctionCalls.evaluate_expression,
            "undo": self.canvas.undo,
            "redo": self.canvas.redo,
            "run_tests": self.run_tests,
            "convert": MathUtil.convert,
            "limit": MathUtil.limit,
            "derive": MathUtil.derivative,
            "integrate": MathUtil.integral,
            "simplify": MathUtil.simplify,
            "expand": MathUtil.expand,
            "factor": MathUtil.factor,
            "solve": MathUtil.solve,
            "solve_system_of_equations": MathUtil.solve_system_of_equations,
            "save_workspace": self.workspace_manager.save_workspace,
            "load_workspace": self.workspace_manager.load_workspace,
            "list_workspaces": self.workspace_manager.list_workspaces,
            "delete_workspace": self.workspace_manager.delete_workspace,
            "create_colored_area": self.canvas.create_colored_area,
            "delete_colored_area": self.canvas.delete_colored_area
        }
        self.undoable_functions = (
            "clear_canvas",
            "reset_canvas", 
            "create_point",
            "delete_point",
            "create_segment",
            "delete_segment",
            "create_vector", 
            "delete_vector",
            "create_triangle",
            "delete_triangle",
            "create_rectangle",
            "delete_rectangle",
            "create_circle",
            "delete_circle",
            "create_ellipse",
            "delete_ellipse",
            "draw_function",
            "delete_function",
            "translate_object",
            "rotate_object",
            "create_colored_area",
            "delete_colored_area"
        )

    def run_tests(self):
        """Run unit tests for the AIInterface class."""
        def test_graphics_drawing():
            function_calls = [
                {
                    "function_name": "create_point",
                    "arguments": {"x": -200, "y": 100, "name": "A"}
                },
                {
                    "function_name": "create_point",
                    "arguments": {"x": 250, "y": -150, "name": "B"}
                },
                {
                    "function_name": "create_segment",
                    "arguments": {"x1": -200, "y1": 100, "x2": 250, "y2": -150, "name": "AB"}
                },
                {
                    "function_name": "create_vector",
                    "arguments": {"origin_x": -150, "origin_y": -200, "tip_x": 100, "tip_y": 200, "name": "v1"}
                },
                {
                    "function_name": "create_triangle",
                    "arguments": {"x1": -100, "y1": -150, "x2": 120, "y2": 130, "x3": 150, "y3": -100, "name": "ABC"}
                },
                {
                    "function_name": "create_rectangle",
                    "arguments": {"px": -250, "py": 250, "opposite_px": 220, "opposite_py": -220, "name": "Rect1"}
                },
                {
                    "function_name": "create_circle",
                    "arguments": {"center_x": 0, "center_y": 0, "radius": 150, "name": "Circle1"}
                },
                {
                    "function_name": "create_ellipse",
                    "arguments": {"center_x": 200, "center_y": -100, "radius_x": 60, "radius_y": 90, "name": "Ellipse1"}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 50) + 50 * tan(x / 100)", "name": "f1", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 30)", "name": "f2", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "create_colored_area",
                    "arguments": {"drawable1_name": "f1", "drawable2_name": "f2", "color": "lightblue", "opacity": 0.3}
                },
                {
                    "function_name": "create_colored_area",
                    "arguments": {"drawable1_name": "f2", "drawable2_name": "x_axis", "color": "lightgreen", "opacity": 0.3}
                },
                {
                    "function_name": "delete_colored_area",
                    "arguments": {"name": "area_f1_f2"}
                },
                {
                    "function_name": "clear_canvas",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                },
                {
                    "function_name": "redo",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                }
            ]
            results = ProcessFunctionCalls.get_results(function_calls, self.available_functions, self.undoable_functions, self.canvas)
            print(f"Results of graphics drawing test: {results}")   # DEBUG
            return results

        def test_undoable_functions():
            for function_name in self.undoable_functions:
                if function_name not in self.available_functions:
                    raise Exception(f"Function '{function_name}' is not available.")
            print("All undoable functions are available.")   # DEBUG

        # Run the class unit tests
        print("Running AIInterface class unit tests...")
        test_graphics_drawing()
        test_undoable_functions()
        # Import tests module only when needed to avoid circular dependency
        try:
            from ClientTests import tests
            tests.run_tests()
        except ImportError:
            print("Client tests module not available - skipping additional tests")

    def _store_results_in_canvas_state(self, call_results):
        """Store valid function call results in the canvas state, skipping special cases and formatting values."""
        if not ProcessFunctionCalls.validate_results(call_results):
            return
            
        for key, value in call_results.items():
            # Skip storing workspace management functions in computations
            if key.startswith("list_workspaces") or \
               key.startswith("save_workspace") or \
               key.startswith("load_workspace"):
                continue

            if not ProcessFunctionCalls.is_successful_result(value):
                continue

            # Format numeric results consistently
            if isinstance(value, (int, float)):
                formatted_value = float(value)  # Always convert numeric values to float
            else:
                formatted_value = value
                
            self.canvas.add_computation(
                expression=key,  # The key is already the expression
                result=formatted_value
            )

    def _print_ai_message_in_chat(self, ai_message):
        """Print an AI message to the chat history and scroll to bottom."""
        if ai_message:
            ai_message = ai_message.replace('\n', '<br>')
            document["chat-history"] <= html.P(f'<strong>AI:</strong> {ai_message}', innerHTML=True)
            # Scroll the chat history to the bottom
            document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _print_user_message_in_chat(self, user_message):
        """Print a user message to the chat history, clear input field, and scroll to bottom."""
        # Add the user's message to the chat history
        document["chat-history"] <= html.P(f'<strong>User:</strong> {user_message}')
        # Clear the input field
        document["chat-input"].value = ''
        # Scroll the chat history to the bottom
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _debug_log_ai_response(self, ai_message, ai_function_calls, finish_reason):
        """Log debug information about the AI response."""
        print(f"### AI message: {ai_message}")
        print(f"### AI function calls: {ai_function_calls}")
        print(f"### AI finish reason: {finish_reason}")

    def _process_ai_response(self, ai_message, tool_calls, finish_reason):     
        self._debug_log_ai_response(ai_message, tool_calls, finish_reason)

        if finish_reason == "stop" or finish_reason == "error":
            self._print_ai_message_in_chat(ai_message)
        else: # finish_reason == "tool_calls" or "function_call"
            try:
                call_results = ProcessFunctionCalls.get_results(tool_calls, self.available_functions, self.undoable_functions, self.canvas)
                self._store_results_in_canvas_state(call_results)
                self._send_prompt_to_ai(None, json.dumps(call_results))
            except Exception as e:
                print(f"Error processing tool calls: {e}")
                traceback.print_exc()

    def _on_error(self, request):
        print(f"Error: {request.status}, {request.text}")

    def _on_complete(self, request):
        if request.status == 200 or request.status == 0:                
            # Extract data from the proper response structure
            response_data = request.json.get('data')
            if not response_data:
                error_msg = request.json.get('message', 'Invalid response format')
                print(f"Error: {error_msg}")
                document["ai-response"].text = error_msg
                return

            ai_message = response_data.get('ai_message')
            ai_function_calls = response_data.get('ai_tool_calls')
            finish_reason = response_data.get('finish_reason')

            # Parse the AI's response and create / delete drawables as needed
            self._process_ai_response(ai_message, ai_function_calls, finish_reason)
        else:
            self._on_error(request)

    def _create_request_payload(self, prompt, include_svg=True):
        """Create the JSON payload for the request, optionally including SVG state."""
        if not include_svg:
            return {'message': prompt}
            
        # Get the SVG element and its content
        svg_element = document["math-svg"]
        svg_content = svg_element.outerHTML
        
        # Get container dimensions
        container = document["math-container"]
        rect = container.getBoundingClientRect()
        
        return {
            'message': prompt,
            'svg_state': {
                'content': svg_content,
                'dimensions': {
                    'width': rect.width,
                    'height': rect.height
                },
                'viewBox': svg_element.getAttribute("viewBox"),
                'transform': svg_element.getAttribute("transform")
            }
        }

    def _make_request(self, payload):
        """Send an AJAX request with the given payload."""
        req = ajax.ajax()
        req.bind('complete', self._on_complete)
        req.bind('error', self._on_error)
        req.open('POST', '/send_message', True)
        req.set_header('content-type', 'application/json')
        req.send(json.dumps(payload))

    def _send_request(self, prompt):
        try:
            # Try to send request with SVG state
            payload = self._create_request_payload(prompt, include_svg=True)
            self._make_request(payload)
        except Exception as e:
            print(f"Error preparing request with SVG: {str(e)}")
            # Fall back to sending request without SVG state
            payload = self._create_request_payload(prompt, include_svg=False)
            self._make_request(payload)

    def _send_prompt_to_ai(self, user_message=None, tool_call_results=None):
        canvas_state = self.canvas.get_canvas_state()
        
        # Only use vision when we have a user message and no tool call results
        use_vision = document["vision-toggle"].checked and user_message is not None and tool_call_results is None
        
        prompt_json = {
            "canvas_state": canvas_state,
            "user_message": user_message,
            "tool_call_results": tool_call_results,
            "use_vision": use_vision,
            "ai_model": document["ai-model-selector"].value
        }
        
        # Convert to JSON string
        prompt = json.dumps(prompt_json)
        print(f'Prompt for AI: {prompt}')
        self._send_request(prompt)

    def interact_with_ai(self, event):            
        # Get the user's message from the input field
        user_message = document["chat-input"].value
        # Print the user message in chat
        self._print_user_message_in_chat(user_message)
        # Send the user's message to the AI
        self._send_prompt_to_ai(user_message)