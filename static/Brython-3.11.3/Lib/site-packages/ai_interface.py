from browser import document, html, ajax
from math_util import MathUtil
from process_function_calls import ProcessFunctionCalls
import json
import Tests.tests as tests
import traceback

class AIInterface:
    def __init__(self, canvas):
        self.canvas = canvas
        self.function_call_results = {}
        self.available_functions = {
            "reset_canvas": self.canvas.reset,
            "clear_canvas": self.canvas.clear,
            "create_point": self.canvas.create_point,
            "delete_point": self.canvas.delete_point,
            "create_segment": self.canvas.create_segment,
            "delete_segment": self.canvas.delete_segment,
            "create_vector": self.canvas.create_vector,
            "delete_vector": self.canvas.delete_vector,
            "create_triangle": self.canvas.create_triangle,
            "delete_triangle": self.canvas.delete_triangle,
            "create_rectangle": self.canvas.create_rectangle,
            "delete_rectangle": self.canvas.delete_rectangle,
            "create_circle": self.canvas.create_circle,
            "delete_circle": self.canvas.delete_circle,
            "create_ellipse": self.canvas.create_ellipse,
            "delete_ellipse": self.canvas.delete_ellipse,
            "draw_function": self.canvas.draw_function,
            "delete_function": self.canvas.delete_function,
            "evaluate_expression": ProcessFunctionCalls.evaluate_expression,
            "undo": self.canvas.undo,
            "redo": self.canvas.redo,
            "run_tests": self.run_tests,
            "convert": MathUtil.convert,
            "limit": MathUtil.limit,
            "derive": MathUtil.derivative,
            "integrate": MathUtil.integral,
            "simplify": MathUtil.simplify,
            "expand": MathUtil.expand,
            "factor": MathUtil.factor,
            "solve": MathUtil.solve,
            "solve_system_of_equations": MathUtil.solve_system_of_equations,
        }
        self.undoable_functions = ("clear_canvas", "reset_canvas", "create_point", "delete_point", "create_segment", "delete_segment", "create_vector", "delete_vector", "create_triangle", "delete_triangle", "create_rectangle", "delete_rectangle", "create_circle", "delete_circle", "create_ellipse", "delete_ellipse", "draw_function", "delete_function")

    def run_tests(self):
        def test_graphics_drawing():
            function_calls = [
                {
                    "function_name": "create_point",
                    "arguments": {"x": -200, "y": 100, "name": "A"}
                },
                {
                    "function_name": "create_point",
                    "arguments": {"x": 250, "y": -150, "name": "B"}
                },
                {
                    "function_name": "create_segment",
                    "arguments": {"x1": -200, "y1": 100, "x2": 250, "y2": -150, "name": "AB"}
                },
                {
                    "function_name": "create_vector",
                    "arguments": {"origin_x": -150, "origin_y": -200, "tip_x": 100, "tip_y": 200, "name": "v1"}
                },
                {
                    "function_name": "create_triangle",
                    "arguments": {"x1": -100, "y1": -150, "x2": 120, "y2": 130, "x3": 150, "y3": -100, "name": "ABC"}
                },
                {
                    "function_name": "create_rectangle",
                    "arguments": {"px": -250, "py": 250, "opposite_px": 220, "opposite_py": -220, "name": "Rect1"}
                },
                {
                    "function_name": "create_circle",
                    "arguments": {"center_x": 0, "center_y": 0, "radius": 150, "name": "Circle1"}
                },
                {
                    "function_name": "create_ellipse",
                    "arguments": {"center_x": 200, "center_y": -100, "radius_x": 60, "radius_y": 90, "name": "Ellipse1"}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 50) + 50 * tan(x / 100)", "name": "f1", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "draw_function",
                    "arguments": {"function_string": "100 * sin(x / 30)", "name": "f2", "left_bound": -300, "right_bound": 300}
                },
                {
                    "function_name": "clear_canvas",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                },
                {
                    "function_name": "redo",
                    "arguments": {}
                },
                {
                    "function_name": "undo",
                    "arguments": {}
                }
            ]
            results = ProcessFunctionCalls.get_results(function_calls, self.available_functions, self.undoable_functions, self.canvas)
            print(f"Results of graphics drawing test: {results}")   # DEBUG
            return results

        def test_undoable_functions():
            for function_name in self.undoable_functions:
                if function_name not in self.available_functions:
                    raise Exception(f"Function '{function_name}' is not available.")
            print("All undoable functions are available.")   # DEBUG

        def test_create_ai_response_text():
            test_cases = [
                ("", {"result1": ""}, "..."),
                ("", {"result1": 42, "result2": "x = 42"}, "result1: 42\nresult2: x = 42"),
                ("Test response.", {"result1": ""}, "Test response."),
                ("Test response.", {"result1": 42, "result2": "something", "result3": "x = 42"}, "Test response.\nresult1: 42\nresult2: something\nresult3: x = 42")
            ]
            for ai_response, call_results, expected_output in test_cases:
                output = self._create_ai_response_text(ai_response, call_results)
                assert output == expected_output, f"Expected '{expected_output}', got '{output}'"
            print("All create_ai_message tests passed.")   # DEBUG

        def test_build_prompt():
            canvas_state = {"objects": []}
            previous_results = [42, "42 for something", "x = 42"]
            user_message = "User message"
            prompt = self._build_prompt(canvas_state, previous_results, user_message)
            assert isinstance(prompt, str), "Prompt should be a string."
            print("build_prompt test passed.")   # DEBUG

        # Run the class unit tests
        print("Running AIInterface class unit tests...")
        test_graphics_drawing()
        test_undoable_functions()
        test_create_ai_response_text()
        test_build_prompt()
        tests.run_tests()

    def _create_ai_response_text(self, ai_response, call_results):
        if not isinstance(call_results, dict):
            raise ValueError("Invalid input for call_results. Expected a dictionary.")
        ai_response_text = ai_response if ai_response else "..."
        if call_results and ProcessFunctionCalls.validate_results(call_results):
            call_results_text = '\n'.join([f"{key}: {value}" for key, value in call_results.items() if not (isinstance(value, str) and \
                                                                                                            (value in ["Call successful!", "",] or value.startswith("Error:")))])
            if call_results_text:  # If there's meaningful call_results_text
                if ai_response_text != "...":
                    ai_response_text += '\n' + call_results_text
                else:
                    ai_response_text = call_results_text
        return ai_response_text

    def _parse_ai_response(self, ai_message, ai_function_calls):
        try:
            # Load the JSON from the AI's reply and call the appropriate functions
            print(f"AI message: {ai_message}")   # DEBUG
            print(f"AI function calls: {ai_function_calls}")   # DEBUG
            # Get the results of the AI's function calls
            call_results = ProcessFunctionCalls.get_results(ai_function_calls, self.available_functions, self.undoable_functions, self.canvas)
            if ProcessFunctionCalls.validate_results(call_results):
                self.function_call_results.update(call_results)
            # Get the text part of the AI's reply
            ai_response_text = self._create_ai_response_text(ai_message, self.function_call_results).replace('\n', '<br>')               
            # Add an empty AI response placeholder to the chat history
            document["chat-history"] <= html.P(f'<strong>AI:</strong> {ai_response_text}', innerHTML=True)
        except Exception as e:
            print(f"Error while processing AI's response: {e}")
            traceback.print_exc()
        finally:
            # Scroll the chat history to the bottom
            document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _build_prompt(self, canvas_state, previous_results, user_message):
        prompt = json.dumps({"canvas_state": canvas_state, "previous_results": previous_results, "user_message": user_message})
        return prompt

    def _on_error(self, request):
        print(f"Error: {request.status}, {request.text}")

    def _on_complete(self, request):
        if request.status == 200 or request.status == 0:
            ai_response = request.json
            ai_message, ai_function_calls = ai_response.get('ai_message'), ai_response.get('ai_tool_calls')
            # Parse the AI's response and create / delete drawables as needed
            self._parse_ai_response(ai_message, ai_function_calls)
        else:
            self._on_error(request)

    def _send_request(self, prompt):
        # Updated to handle new API response format and tool calls
        req = ajax.ajax()
        req.bind('complete', self._on_complete)  # Add self. before _on_complete
        req.bind('error', self._on_error)  # Add self. before _on_error
        req.open('POST', '/send_message', True)
        req.set_header('content-type', 'application/json')  # Ensure this matches expected content type
        # Update to send JSON including any necessary data for tools
        req.send(json.dumps({'message': prompt}))

    # Send message, receive response from the AI and call functions as needed
    def interact_with_ai(self, event):            
        # Get the user's message from the input field
        user_message = document["chat-input"].value
        # Add the user's message to the chat history
        document["chat-history"] <= html.P(f'<strong>User:</strong> {user_message}')
        # Clear the input field
        document["chat-input"].value = ''
        # Scroll the chat history to the bottom
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight
        # Get the canvas state with on-screen drawables original properties 
        canvas_state = self.canvas.get_canvas_state()
        # Build the prompt for the AI
        prompt = self._build_prompt(canvas_state, self.function_call_results, user_message)
        print(f'Prompt to be sent to the AI: {prompt}')
        self._send_request(prompt)