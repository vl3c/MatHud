import json
import traceback
from browser import document, html, ajax, window
from function_registry import FunctionRegistry
from process_function_calls import ProcessFunctionCalls
from test_runner import TestRunner
from workspace_manager import WorkspaceManager
from markdown_parser import MarkdownParser


class AIInterface:
    def __init__(self, canvas):
        self.canvas = canvas
        self.workspace_manager = WorkspaceManager(canvas)
        self.is_processing = False  # Track whether we're processing an AI response
        self.available_functions = FunctionRegistry.get_available_functions(canvas, self.workspace_manager, self)
        self.undoable_functions = FunctionRegistry.get_undoable_functions()
        self.markdown_parser = MarkdownParser()

    def run_tests(self):
        """Run unit tests for the AIInterface class and return results to the AI as the function result."""
        test_runner = TestRunner(self.canvas, self.available_functions, self.undoable_functions)
        
        # Run tests and get formatted results in one step
        results = test_runner.run_tests()
        return test_runner.format_results_for_ai(results)

    def _store_results_in_canvas_state(self, call_results):
        """Store valid function call results in the canvas state, skipping special cases and formatting values."""
        if not ProcessFunctionCalls.validate_results(call_results):
            return
            
        for key, value in call_results.items():
            # Skip storing workspace management functions and test results in computations
            if key.startswith("list_workspaces") or \
               key.startswith("save_workspace") or \
               key.startswith("load_workspace") or \
               key.startswith("run_tests"):
                continue

            if not ProcessFunctionCalls.is_successful_result(value):
                continue

            # Format numeric results consistently
            if isinstance(value, (int, float)):
                formatted_value = float(value)  # Always convert numeric values to float
            else:
                formatted_value = value
                
            self.canvas.add_computation(
                expression=key,  # The key is already the expression
                result=formatted_value
            )

    def _parse_markdown_to_html(self, text):
        """Parse markdown text to HTML using the dedicated markdown parser."""
        return self.markdown_parser.parse(text)
    
    def _render_math(self):
        """Trigger MathJax rendering for newly added content."""
        try:
            # Check if MathJax is available
            if hasattr(window, 'MathJax') and hasattr(window.MathJax, 'typesetPromise'):
                # Re-render math in the chat history
                window.MathJax.typesetPromise([document["chat-history"]])
        except Exception as e:
            # MathJax not available or error occurred, continue silently
            pass

    
    def _create_message_element(self, sender, message, message_type="normal"):
        """Create a styled message element with markdown support."""
        try:
            # Create message container
            message_container = html.DIV(Class=f"chat-message {message_type}")
            
            # Create sender label
            sender_label = html.SPAN(f"{sender}: ", Class=f"chat-sender {sender.lower()}")
            
            # Parse markdown and create content element
            if sender == "AI":
                parsed_content = self._parse_markdown_to_html(message)
                content_element = html.DIV(Class="chat-content markdown")
                content_element.innerHTML = parsed_content
            else:
                # For user messages, keep them as plain text for now
                content_element = html.SPAN(message, Class="chat-content")
            
            # Assemble the message
            message_container <= sender_label
            message_container <= content_element
            
            return message_container
            
        except Exception as e:
            print(f"Error creating message element: {e}")
            # Fall back to simple paragraph
            if sender == "AI":
                content = message.replace('\n', '<br>')
                return html.P(f'<strong>{sender}:</strong> {content}', innerHTML=True)
            else:
                return html.P(f'<strong>{sender}:</strong> {message}')

    def _print_ai_message_in_chat(self, ai_message):
        """Print an AI message to the chat history with markdown support and scroll to bottom."""
        if ai_message:
            message_element = self._create_message_element("AI", ai_message)
            document["chat-history"] <= message_element
            # Trigger MathJax rendering for new content
            self._render_math()
            # Scroll the chat history to the bottom
            document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _print_user_message_in_chat(self, user_message):
        """Print a user message to the chat history, clear input field, and scroll to bottom."""
        # Add the user's message to the chat history with markdown support
        message_element = self._create_message_element("User", user_message)
        document["chat-history"] <= message_element
        # Trigger MathJax rendering for new content
        self._render_math()
        # Clear the input field
        document["chat-input"].value = ''
        # Scroll the chat history to the bottom
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight

    def _debug_log_ai_response(self, ai_message, ai_function_calls, finish_reason):
        """Log debug information about the AI response."""
        print(f"### AI message: {ai_message}")
        print(f"### AI function calls: {ai_function_calls}")
        print(f"### AI finish reason: {finish_reason}")

    def _disable_send_controls(self):
        """Disable only the send functionality while processing."""
        try:
            self.is_processing = True
            if "chat-button" in document:
                document["chat-button"].disabled = True
        except Exception as e:
            print(f"Error disabling send controls: {e}")

    def _enable_send_controls(self):
        """Enable send functionality after processing."""
        try:
            self.is_processing = False
            if "chat-button" in document:
                document["chat-button"].disabled = False
        except Exception as e:
            print(f"Error enabling send controls: {e}")

    def _process_ai_response(self, ai_message, tool_calls, finish_reason):     
        self._debug_log_ai_response(ai_message, tool_calls, finish_reason)

        if finish_reason == "stop" or finish_reason == "error":
            self._print_ai_message_in_chat(ai_message)
            self._enable_send_controls()
        else: # finish_reason == "tool_calls" or "function_call"
            try:
                call_results = ProcessFunctionCalls.get_results(tool_calls, self.available_functions, self.undoable_functions, self.canvas)
                self._store_results_in_canvas_state(call_results)
                self._send_prompt_to_ai(None, json.dumps(call_results))
            except Exception as e:
                print(f"Error processing tool calls: {e}")
                traceback.print_exc()
                self._enable_send_controls()  # Enable controls if there's an error

    def _on_error(self, request):
        """Handle request errors and ensure send controls are re-enabled."""
        print(f"Error: {request.status}, {request.text}")
        self._enable_send_controls()

    def _on_complete(self, request):
        """Handle request completion and process AI response."""
        try:
            if request.status == 200 or request.status == 0:                
                # Extract data from the proper response structure
                response_data = request.json.get('data')
                if not response_data:
                    error_msg = request.json.get('message', 'Invalid response format')
                    print(f"Error: {error_msg}")
                    document["ai-response"].text = error_msg
                    self._enable_send_controls()
                    return

                ai_message = response_data.get('ai_message')
                ai_function_calls = response_data.get('ai_tool_calls')
                finish_reason = response_data.get('finish_reason')

                # Parse the AI's response and create / delete drawables as needed
                self._process_ai_response(ai_message, ai_function_calls, finish_reason)
            else:
                self._on_error(request)
        except Exception as e:
            print(f"Error processing AI response: {e}")
            traceback.print_exc()
            self._enable_send_controls()

    def _create_request_payload(self, prompt, include_svg=True):
        """Create the JSON payload for the request, optionally including SVG state."""
        if not include_svg:
            return {'message': prompt}
            
        # Get the SVG element and its content
        svg_element = document["math-svg"]
        svg_content = svg_element.outerHTML
        
        # Get container dimensions
        container = document["math-container"]
        rect = container.getBoundingClientRect()
        
        payload = {
            'message': prompt,
            'svg_state': {
                'content': svg_content,
                'dimensions': {
                    'width': rect.width,
                    'height': rect.height
                },
                'viewBox': svg_element.getAttribute("viewBox"),
                'transform': svg_element.getAttribute("transform")
            }
        }
        return payload

    def _make_request(self, payload):
        """Send an AJAX request with the given payload."""
        req = ajax.ajax()
        req.bind('complete', self._on_complete)
        req.bind('error', self._on_error)
        req.open('POST', '/send_message', True)
        req.set_header('content-type', 'application/json')
        req.send(json.dumps(payload))

    def _send_request(self, prompt):
        try:
            # Try to send request with SVG state
            payload = self._create_request_payload(prompt, include_svg=True)
            self._make_request(payload)
        except Exception as e:
            print(f"Error preparing request with SVG: {str(e)}")
            # Fall back to sending request without SVG state
            payload = self._create_request_payload(prompt, include_svg=False)
            self._make_request(payload)

    def _send_prompt_to_ai(self, user_message=None, tool_call_results=None):
        canvas_state = self.canvas.get_canvas_state()
        
        # Only use vision when we have a user message and no tool call results
        use_vision = document["vision-toggle"].checked and user_message is not None and tool_call_results is None
        
        prompt_json = {
            "canvas_state": canvas_state,
            "user_message": user_message,
            "tool_call_results": tool_call_results,
            "use_vision": use_vision,
            "ai_model": document["ai-model-selector"].value
        }
        
        # Convert to JSON string
        prompt = json.dumps(prompt_json)
        print(f'Prompt for AI: {prompt}')
        self._send_request(prompt)

    def interact_with_ai(self, event):
        # Don't process if we're already handling a request
        if self.is_processing:
            return
            
        # Get the user's message from the input field
        user_message = document["chat-input"].value
        # Print the user message in chat
        self._print_user_message_in_chat(user_message)
        # Disable send controls while processing
        self._disable_send_controls()
        # Send the user's message to the AI
        self._send_prompt_to_ai(user_message)