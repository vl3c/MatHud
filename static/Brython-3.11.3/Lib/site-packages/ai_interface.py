from browser import document, html, ajax
from process_function_calls import ProcessFunctionCalls
from math_util import MathUtil
import json
import Tests.tests as tests
import traceback

class AIInterface:
    def __init__(self, canvas):
        self.canvas = canvas
        self.available_functions = {
            "reset_canvas": self.canvas.reset,
            "clear_canvas": self.canvas.clear,
            "create_point": self.canvas.create_point,
            "delete_point": self.canvas.delete_point,
            "create_segment": self.canvas.create_segment,
            "delete_segment": self.canvas.delete_segment,
            "create_vector": self.canvas.create_vector,
            "delete_vector": self.canvas.delete_vector,
            "create_triangle": self.canvas.create_triangle,
            "delete_triangle": self.canvas.delete_triangle,
            "create_rectangle": self.canvas.create_rectangle,
            "delete_rectangle": self.canvas.delete_rectangle,
            "create_circle": self.canvas.create_circle,
            "delete_circle": self.canvas.delete_circle,
            "create_ellipse": self.canvas.create_ellipse,
            "delete_ellipse": self.canvas.delete_ellipse,
            "draw_function": self.canvas.draw_function,
            "delete_function": self.canvas.delete_function,
            "evaluate_expression": ProcessFunctionCalls.evaluate_expression,
            "undo": self.canvas.undo,
            "redo": self.canvas.redo,
            "run_tests": self.run_tests,
            "convert": MathUtil.convert,
            "limit": MathUtil.limit,
            "derivative": MathUtil.derivative,
            "integral": MathUtil.integral,
            "simplify": MathUtil.simplify,
            "expand": MathUtil.expand,
            "factor": MathUtil.factor,
            "solve": MathUtil.solve,
            "solve_system_of_equations": MathUtil.solve_system_of_equations,
        }
        self.undoable_functions = ["clear_canvas", "reset_canvas", "create_point", "delete_point", "create_segment", "delete_segment", "create_vector", "delete_vector", \
                    "create_triangle", "delete_triangle", "create_rectangle", "delete_rectangle", "create_circle", "delete_circle", "create_ellipse", "delete_ellipse", \
                    "draw_function", "delete_function"]

    def run_tests(self):
        function_calls = [
            {
                "function_name": "create_point",
                "arguments": {"x": -200, "y": 100, "name": "A"}
            },
            {
                "function_name": "create_point",
                "arguments": {"x": 250, "y": -150, "name": "B"}
            },
            {
                "function_name": "create_segment",
                "arguments": {"x1": -200, "y1": 100, "x2": 250, "y2": -150, "name": "AB"}
            },
            {
                "function_name": "create_vector",
                "arguments": {"origin_x": -150, "origin_y": -200, "tip_x": 100, "tip_y": 200, "name": "v1"}
            },
            {
                "function_name": "create_triangle",
                "arguments": {"x1": -100, "y1": -150, "x2": 120, "y2": 130, "x3": 150, "y3": -100, "name": "ABC"}
            },
            {
                "function_name": "create_rectangle",
                "arguments": {"px": -250, "py": 250, "opposite_px": 220, "opposite_py": -220, "name": "Rect1"}
            },
            {
                "function_name": "create_circle",
                "arguments": {"center_x": 0, "center_y": 0, "radius": 150, "name": "Circle1"}
            },
            {
                "function_name": "create_ellipse",
                "arguments": {"center_x": 200, "center_y": -100, "radius_x": 60, "radius_y": 90, "name": "Ellipse1"}
            },
            {
                "function_name": "draw_function",
                "arguments": {"function_string": "100 * sin(x / 50) + 50 * tan(x / 100)", "name": "f1", "left_bound": -300, "right_bound": 300}
            },
            {
                "function_name": "draw_function",
                "arguments": {"function_string": "100 * sin(x / 30)", "name": "f2", "left_bound": -300, "right_bound": 300}
            },
            {
                "function_name": "clear_canvas",
                "arguments": {}
            },
            {
                "function_name": "undo",
                "arguments": {}
            },
            {
                "function_name": "redo",
                "arguments": {}
            },
            {
                "function_name": "undo",
                "arguments": {}
            }
        ]
        ProcessFunctionCalls.get_results(function_calls, self.available_functions, self.undoable_functions, self.canvas)
        tests.run_tests()


    # Send message, receive response from the AI and call functions as needed
    def interact_with_ai(self, event):
        # Global variable to store the result of an AI function call
        g_function_call_results = []

        def parse_ai_response(ai_message, ai_function_calls):
            def create_ai_message(ai_response, call_results):
                # This function should return the text part of the AI's reply
                ai_response_text = ""
                if ai_response:
                    ai_response_text = ai_response
                if call_results and ProcessFunctionCalls.validate_results(call_results):
                    ai_response_text += ', '.join(map(str, call_results))
                if not ai_response_text:
                    ai_response_text = "..."
                return ai_response_text
            
            try:
                # Load the JSON from the AI's reply and call the appropriate functions
                print(f"AI message: {ai_message}")   # DEBUG
                print(f"AI function calls: {ai_function_calls}")   # DEBUG

                call_results = ProcessFunctionCalls.get_results(ai_function_calls, self.available_functions, self.undoable_functions, self.canvas)
                ProcessFunctionCalls.set_function_call_result(call_results, g_function_call_results)
                call_results = g_function_call_results
                # Get the text part of the AI's reply
                ai_response_text = create_ai_message(ai_message, call_results).replace('\n', '<br>')               
                # Add an empty AI response placeholder to the chat history
                document["chat-history"] <= html.P(f'<strong>AI:</strong> {ai_response_text}', innerHTML=True)
            except Exception as e:
                print(f"Error while processing AI's response: {e}")
                traceback.print_exc()
            finally:
                # Scroll the chat history to the bottom
                document["chat-history"].scrollTop = document["chat-history"].scrollHeight
            
        def build_prompt(canvas_state, function_call_results, user_message):
            prompt = json.dumps({"canvas_state": canvas_state, "previous_results": function_call_results, "user_message": user_message})
            return prompt

        def on_complete(request):
            if request.status == 200 or request.status == 0:
                ai_response = request.json
                ai_message, ai_function_calls = ai_response.get('ai_message'), ai_response.get('ai_tool_calls')
                # Parse the AI's response and create / delete drawables as needed
                parse_ai_response(ai_message, ai_function_calls)
            else:
                on_error(request)
        
        def on_error(request):
            print(f"Error: {request.status}, {request.text}")
        
        def send_request(prompt):
            # Updated to handle new API response format and tool calls
            req = ajax.ajax()
            req.bind('complete', on_complete)
            req.bind('error', on_error)
            req.open('POST', '/send_message', True)
            req.set_header('content-type', 'application/json')  # Ensure this matches expected content type
            # Update to send JSON including any necessary data for tools
            req.send(json.dumps({'message': prompt}))

        # Get the user's message from the input field
        user_message = document["chat-input"].value
        # Add the user's message to the chat history
        document["chat-history"] <= html.P(f'<strong>User:</strong> {user_message}')
        # Clear the input field
        document["chat-input"].value = ''
        # Scroll the chat history to the bottom
        document["chat-history"].scrollTop = document["chat-history"].scrollHeight
        # Get the canvas state with on-screen drawables original properties 
        canvas_state = self.canvas.get_canvas_state()
        # Build the prompt for the AI
        prompt = build_prompt(canvas_state, g_function_call_results, user_message)
        print(prompt)
        send_request(prompt)