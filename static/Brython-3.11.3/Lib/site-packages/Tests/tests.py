import copy
import json
import math
from random import randint
import unittest
from collections import namedtuple
from canvas import Canvas
from cartesian_system_2axis import Cartesian2Axis
from expression_validator import ExpressionValidator
from math_geometry import Circle, Ellipse, Function, Rectangle, Segment, Triangle, Vector
from math_util import MathUtil
from name_generator import DrawableNameGenerator
from point import Position, Point


class SimpleMock:
    def __init__(self, **kwargs):
        self._attributes = {}
        self._return_value = None
        self.calls = []
        for key, value in kwargs.items():
            if key == 'return_value':
                self._return_value = value
            else:
                self._attributes[key] = value

    def __getitem__(self, item):
        if item in self._attributes:
            return self._attributes[item]
        else:
            raise KeyError(f"'{type(self).__name__}' object has no attribute '{item}'")

    def __setitem__(self, key, value):
        self._attributes[key] = value

    def __contains__(self, item):
        return item in self._attributes

    def __getattr__(self, attr):
        if attr in self._attributes:
            return self._attributes[attr]
        elif attr == 'return_value':
            return self._return_value
        else:
            raise AttributeError(f"'{type(self).__name__}' object has no attribute '{attr}'")

    def __call__(self, *args, **kwargs):
        self.calls.append((args, kwargs))
        return self._return_value

    def assert_called_once_with(self, *args, **kwargs):
        if len(self.calls) != 1:
            raise AssertionError(f'Expected one call, got {len(self.calls)}')
        call_args, call_kwargs = self.calls[0]
        if call_args != args or call_kwargs != kwargs:
            raise AssertionError(f'Expected call with ({args}, {kwargs}), got ({call_args}, {call_kwargs})')

    def reset_mock(self):
        self.calls = []


class TestMathFunctions(unittest.TestCase):
    def setUp(self):
        # Mock points for use in some tests
        self.point1 = SimpleMock(original_position=SimpleMock(x=0, y=0), name='A')
        self.point2 = SimpleMock(original_position=SimpleMock(x=1, y=1), name='B')
        # Mock segment using mocked points
        self.segment = SimpleMock(point1=self.point1, point2=self.point2)
    
    def test_format_number_for_cartesian(self):
        test_cases = [
            (123456789, 6, '1.2e+8'),
            (0.000123456789, 6, '0.00012'),
            (123456, 6, '123456'),
            (123.456, 6, '123.456'),
            (0, 6, '0'),
            (-123456789, 6, '-1.2e+8'),
            (-0.000123456789, 6, '-0.00012'),
            (-123456, 6, '-123456'),
            (-123.456, 6, '-123.456'),
            (1.23456789, 6, '1.23457'),
            (0.000000123456789, 6, '1.2e-7'),
            (123456.789, 6, '123457'),
            (123.456789, 6, '123.457'),
            (0.00000000000001, 6, '1e-14'),
            (-1.23456789, 6, '-1.23457'),
            (-0.000000123456789, 6, '-1.2e-7'),
            (-123456.789, 6, '-123457'),
            (-123.456789, 6, '-123.457'),
            (-0.00000000000001, 6, '-1e-14'),
            (123456789, 3, '1.2e+8'),
            (0.000123456789, 3, '1.2e-4'),
            (123456, 3, '1.2e+5'),
            (123.456, 3, '123'),
            (1.23456789, 3, '1.23'),
            (0.000000123456789, 3, '1.2e-7'),
            (123456.789, 3, '1.2e+5'),
            (123.456789, 3, '123'),
            (0.00000000000001, 3, '1e-14'),
        ]
        for i, (input, max_digits, expected) in enumerate(test_cases):
            with self.subTest(i=i):
                self.assertEqual(MathUtil.format_number_for_cartesian(input, max_digits=max_digits), expected)

    def test_point_matches_coordinates(self):
        self.assertTrue(MathUtil.point_matches_coordinates(self.point1, 0, 0))
        self.assertFalse(MathUtil.point_matches_coordinates(self.point1, 1, 1))

    def test_segment_matches_coordinates(self):
        self.assertTrue(MathUtil.segment_matches_coordinates(self.segment, 0, 0, 1, 1))
        self.assertTrue(MathUtil.segment_matches_coordinates(self.segment, 1, 1, 0, 0))  # Reverse order
        self.assertFalse(MathUtil.segment_matches_coordinates(self.segment, 2, 2, 3, 3))  # Incorrect coordinates

    def test_segment_matches_point_names(self):
        self.assertTrue(MathUtil.segment_matches_point_names(self.segment, 'A', 'B'))
        self.assertTrue(MathUtil.segment_matches_point_names(self.segment, 'B', 'A'))  # Reverse order
        self.assertFalse(MathUtil.segment_matches_point_names(self.segment, 'C', 'D'))  # Incorrect names

    def test_segment_has_end_point(self):
        self.assertTrue(MathUtil.segment_has_end_point(self.segment, 0, 0))
        self.assertTrue(MathUtil.segment_has_end_point(self.segment, 1, 1))
        self.assertFalse(MathUtil.segment_has_end_point(self.segment, 2, 2))  # Point not in segment

    def test_get_2D_distance(self):
        p1 = Position(0, 0)
        p2 = Position(3, 4)
        self.assertEqual(MathUtil.get_2D_distance(p1, p2), 5)

    def test_get_2D_midpoint(self):
        p1 = Position(0, 0)
        p2 = Position(2, 2)
        x, y = MathUtil.get_2D_midpoint(p1, p2)
        self.assertEqual(x, 1)
        self.assertEqual(y, 1)

    def test_is_point_on_segment(self):
        self.assertTrue(MathUtil.is_point_on_segment(1, 1, 0, 0, 2, 2))
        self.assertFalse(MathUtil.is_point_on_segment(3, 3, 0, 0, 2, 2))

    def test_get_triangle_area(self):
        p1 = Position(0, 0)
        p2 = Position(1, 0)
        p3 = Position(0, 1)
        self.assertAlmostEqual(MathUtil.get_triangle_area(p1, p2, p3), 0.5)

    def test_get_rectangle_area(self):
        p1 = Position(0, 0)
        p2 = Position(2, 3)
        self.assertEqual(MathUtil.get_rectangle_area(p1, p2), 6)

    def test_cross_product(self):
        self.assertEqual(MathUtil.cross_product(Position(0, 0), Position(1, 0), Position(0, 1)), 1)       # "Perpendicular vectors"
        self.assertEqual(MathUtil.cross_product(Position(0, 0), Position(1, 1), Position(1, 1)), 0)       # "Zero vector test"
        self.assertEqual(MathUtil.cross_product(Position(1, 2), Position(-1, -1), Position(2, -3)), 13)   # "Negative values test"
        self.assertEqual(MathUtil.cross_product(Position(0, 0), Position(1, 0), Position(2, 0)), 0)       # "Collinear vectors"

    def test_dot_product(self):
        self.assertEqual(MathUtil.dot_product(Position(0, 0), Position(1, 0), Position(1, 0)), 1)      # "Parallel vectors"
        self.assertEqual(MathUtil.dot_product(Position(0, 0), Position(0, 0), Position(0, 1)), 0)      # "Zero vector test"
        self.assertEqual(MathUtil.dot_product(Position(1, 2), Position(-1, -1), Position(2, -3)), 13)  # "Negative values test"
        self.assertEqual(MathUtil.dot_product(Position(0, 0), Position(1, 0), Position(0, 1)), 0)      # "Perpendicular vectors"

    def test_is_right_angle(self):
        self.assertEqual(MathUtil.is_right_angle(Position(0, 0), Position(1, 0), Position(0, 1)), True)   # "Right angle"
        self.assertEqual(MathUtil.is_right_angle(Position(0, 0), Position(1, 1), Position(1, 0)), False)  # "Not right angle"
        self.assertEqual(MathUtil.is_right_angle(Position(0, 0), Position(1, 0), Position(1, 1)), False)  # "Almost right angle but not quite"

    def test_validate_rectangle(self):
        # square
        self.assertTrue(MathUtil.is_rectangle(0, 0, 1, 0, 1, 1, 0, 1))
        self.assertTrue(MathUtil.is_rectangle(0, 0, 0, 1, 1, 1, 1, 0))
        # rectangle
        self.assertTrue(MathUtil.is_rectangle(0, 0, 2, 0, 2, 1, 0, 1))
        self.assertTrue(MathUtil.is_rectangle(0, 0, 0, 1, 2, 1, 2, 0))
        # square skewed by 45 degrees
        self.assertTrue(MathUtil.is_rectangle(0, 1, 1, 0, 2, 1, 1, 2))
        self.assertTrue(MathUtil.is_rectangle(0, 1, 1, 2, 2, 1, 1, 0))
        # rectangle skewed by 45 degrees
        self.assertTrue(MathUtil.is_rectangle(0, 2, 2, 0, 3, 1, 1, 3))
        self.assertTrue(MathUtil.is_rectangle(0, 2, 1, 3, 3, 1, 2, 0))
        # Invalid rectangles
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 0, 1, 1, 2))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 1, 2, 0, 1, 2, 0))
        # Invalid cases with repeating points
        self.assertFalse(MathUtil.is_rectangle(0, 0, 0, 0, 2, 1, 0, 1))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 2, 0, 0, 1))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 2, 1, 2, 1))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 0, 0, 0, 0, 0, 0))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 0, 0, 2, 0))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 0, 0, 2, 0, 2, 0))
        self.assertFalse(MathUtil.is_rectangle(2, 0, 2, 0, 0, 0, 0, 0))

    def test_segments_intersect(self):
        self.assertTrue(MathUtil.segments_intersect(0, 0, 10, 10, 0, 10, 10, 0))
        self.assertFalse(MathUtil.segments_intersect(0, 0, 10, 10, 20, 20, 30, 30))
        self.assertTrue(MathUtil.segments_intersect(0, 0, 10, 10, 0, 0, 10, 10))
        self.assertTrue(MathUtil.segments_intersect(0, 0, 10, 10, 0, 0, 5, 5))

    def test_get_segments_intersection(self):
        x_intersection, y_intersection = MathUtil.get_segments_intersection(0, 0, 1, 1, 0, 1, 1, 0)
        self.assertAlmostEqual(x_intersection, 0.5, places=7)
        self.assertAlmostEqual(y_intersection, 0.5, places=7)

    def test_get_segments_intersection_parallel(self):
        # Define two parallel segments
        result = MathUtil.get_segments_intersection(0, 0, 1, 1, 2, 2, 3, 3)
        # Since the segments are parallel, the result should be None
        self.assertIsNone(result, "Expected None for parallel segments")

    def test_get_line_formula(self):
        self.assertEqual(MathUtil.get_line_formula(0, 0, 1, 1), "y = 1.0 * x + 0.0")
        self.assertEqual(MathUtil.get_line_formula(0, 0, 0, 1), "x = 0")

    def test_get_circle_formula(self):
        self.assertEqual(MathUtil.get_circle_formula(0, 0, 1), "(x - 0)**2 + (y - 0)**2 = 1**2")

    def test_get_ellipse_formula(self):
        self.assertEqual(MathUtil.get_ellipse_formula(0, 0, 1, 2), "((x - 0)**2)/1**2 + ((y - 0)**2)/2**2 = 1")

    def test_sqrt(self):
        result = MathUtil.sqrt(-4)
        self.assertEqual(result, "2i")
        result = MathUtil.sqrt(4)
        self.assertEqual(int(result), 2)

    def test_pow(self):
        result = MathUtil.pow(2, 3)
        self.assertEqual(int(result), 8)
        matrix = [[-1, 2], [3, 1]]
        result = MathUtil.pow(matrix, 2)
        self.assertEqual(result, "[[7, 0], [0, 7]]")

    def test_evaluate_conversion(self):
        result = MathUtil.convert(12.7, "cm", "inch")
        self.assertEqual(result, "5 inch")

    def test_evaluate_division(self):
        result = MathUtil.evaluate("12 / (2.3 + 0.7)")
        self.assertEqual(int(result), 4)

    def test_evaluate_sin(self):
        result = MathUtil.evaluate("sin(45 deg) ^ 2")
        print(f"sin(45 deg) ^ 2 = {result}")
        self.assertAlmostEqual(float(result), 0.5, places=9)

    def test_evaluate_js_power_symbol(self):
        result = MathUtil.evaluate("9^2 / 3")
        self.assertEqual(int(result), 27)

    def test_evaluate_py_power_symbol(self):
        result = MathUtil.evaluate("9**2 / 3")
        self.assertEqual(int(result), 27)

    def test_evaluate_complex(self):
        result = MathUtil.evaluate("1 + 2i + 1j")
        self.assertEqual(result, "1 + 3i")

    def test_evaluate_det(self):
        matrix = [[-1, 2], [3, 1]]
        result = MathUtil.det(matrix)
        self.assertEqual(int(result), -7)

    def test_random(self):
        result = MathUtil.random()
        self.assertTrue(0 <= result <= 1)

    def test_round(self):
        result = MathUtil.round(1.2345, 2)
        self.assertEqual(result, 1.23)

    def test_gcd(self):
        result = MathUtil.gcd(48, 18)
        self.assertEqual(result, 6)

    def test_lcm(self):
        result = MathUtil.lcm(4, 5)
        self.assertEqual(result, 20)

    def test_mean(self):
        result = MathUtil.mean([1, 2, 3, 4, 5])
        self.assertEqual(result, 3)

    def test_median(self):
        result = MathUtil.median([1, 2, 3, 4, 5])
        self.assertEqual(result, 3)

    def test_mode(self):
        result = MathUtil.mode([1, 2, 2, 3])
        self.assertEqual(result, 2)

    def test_stdev(self):
        result = MathUtil.stdev([2, 4, 6, 8, 10])
        self.assertAlmostEqual(result, 3.1623, places=4)

    def test_variance(self):
        result = MathUtil.variance([2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5])
        self.assertAlmostEqual(result, 1.372, places=3)

    def test_limit(self):
        result = MathUtil.limit('sin(x) / x', 'x', 0)
        result = float(result)  # convert result to float
        self.assertEqual(result, 1.0)

    def test_derivative(self):
        result = MathUtil.derivative('x^2', 'x')
        self.assertEqual(result, "2*x")

    def test_integral_indefinite(self):
        result = MathUtil.integral('x^2', 'x')
        result = MathUtil.simplify(result)  # simplify the result
        self.assertEqual(result, "0.3333333333333333*x^3")

    def test_integral(self):
        result = MathUtil.integral('x^2', 'x', 0, 1)
        result = float(result)  # convert result to float
        self.assertAlmostEqual(result, 0.333, places=3)

    def test_simplify(self):
        result = MathUtil.simplify('x^2 + 2*x + 1')
        self.assertEqual(result, "(1+x)^2")

    def test_expand(self):
        result = MathUtil.expand('(x + 1)^2')
        self.assertEqual(result, "1+2*x+x^2")

    def test_factor(self):
        result = MathUtil.factor('x^2 - 1')
        self.assertEqual(result, "(-1+x)*(1+x)")

    def test_solve(self):
        result = MathUtil.solve('x^2 - 4', 'x')
        result = json.loads(result)  # parse result from JSON string to list
        result = [float(r) for r in result]  # convert results to floats
        self.assertEqual(result, [2.0, -2.0])

    def test_solve_system_of_equations(self):
        result = MathUtil.solve_system_of_equations(['x + y = 4', 'x - y = 2'])
        result = dict(item.split(" = ") for item in result.split(", "))  # parse result from string to dictionary
        result = {k: float(v) for k, v in result.items()}  # convert results to floats
        self.assertEqual(result, {"x": 3.0, "y": 1.0})


class TestDrawableNameGenerator(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock()
        self.generator = DrawableNameGenerator(self.canvas)

    def test_get_drawable_names(self):
        # Here, get_drawables_by_class_name is expected to be a callable that returns a list of mocks when called
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='Point1'), SimpleMock(name='Point2')]
        )
        result = self.generator.get_drawable_names('Point')
        self.assertEqual(result, ['Point1', 'Point2'])

    def test_filter_string(self):
        # Test with a string that contains letters, digits, apostrophes, and parentheses
        result = self.generator.filter_string("Test(123)'")
        self.assertEqual(result, "Test(123)'")
        # Test with a string that contains special characters
        result = self.generator.filter_string("Hello, World!")
        self.assertEqual(result, "HelloWorld")
        # Test with a string that contains whitespace
        result = self.generator.filter_string("Hello World")
        self.assertEqual(result, "HelloWorld")
        # Test with a string that contains only disallowed characters
        result = self.generator.filter_string("!@#$%^&*")
        self.assertEqual(result, "")
        # Test with an empty string
        result = self.generator.filter_string("")
        self.assertEqual(result, "")

    def test_split_point_names(self):
        result = self.generator.split_point_names("A'B'CD", 4)
        self.assertEqual(result, ["A'", "B'", "C", "D"])

    def test_generate_unique_point_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(return_value=[])
        point_names = []
        for _ in range(52):
            new_name = self.generator._generate_unique_point_name()
            point_names.append(new_name)
            # Update the return_value of get_drawables_by_class_name with each new name
            self.canvas.get_drawables_by_class_name.return_value.append(SimpleMock(name=new_name))
        # The next point name should be 'A'' (A with two apostrophes)
        result = self.generator._generate_unique_point_name()
        self.assertEqual(result, "A''")

    def test_generate_point_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A')]
        )
        result = self.generator.generate_point_name(None)
        self.assertEqual(result, 'B')

    def test_generate_point_name_with_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A')]
        )
        result = self.generator.generate_point_name('B')
        self.assertEqual(result, 'B')

    def test_generate_point_name_with_used_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A'), SimpleMock(name='B')]
        )
        result = self.generator.generate_point_name('B')
        self.assertNotEqual(result, 'B')

    def test_increment_function_name(self):
        # Test with a function name that ends with a number
        result = self.generator._increment_function_name('f4')
        self.assertEqual(result, 'f5')
        # Test with a function name that does not end with a number
        result = self.generator._increment_function_name('f')
        self.assertEqual(result, 'f1')
        # Test with a function name that ends with a large number
        result = self.generator._increment_function_name('f99')
        self.assertEqual(result, 'f100')
        # Test with a function name that ends with a number and has other numbers in it
        result = self.generator._increment_function_name('f4f4')
        self.assertEqual(result, 'f4f5')
        # Test with a function name that does not end with a number and has other numbers in it
        result = self.generator._increment_function_name('f4f')
        self.assertEqual(result, 'f4f1')

    def test_generate_unique_function_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(return_value=[])
        function_names = []
        for _ in range(42):
            new_name = self.generator._generate_unique_function_name()
            function_names.append(new_name)
            # Update the return_value of get_drawables_by_class_name with each new name
            self.canvas.get_drawables_by_class_name.return_value.append(SimpleMock(name=new_name))
        # The next function name should be 'r1'
        result = self.generator._generate_unique_function_name()
        self.assertEqual(result, "v1")

    def test_generate_function_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f'), SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name(None)
        self.assertEqual(result, 'g')

    def test_generate_function_name_with_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name('f2')
        self.assertEqual(result, 'f2')

    def test_generate_function_name_with_used_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1'), SimpleMock(name='f2')]
        )
        result = self.generator.generate_function_name('f2')
        self.assertEqual(result, 'f3')

    def test_generate_function_name_with_preferred_name_and_parentheses(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name('f2(x)')
        self.assertEqual(result, 'f2')

    def test_generate_function_name_with_used_preferred_name_and_parentheses(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1'), SimpleMock(name='f2')]
        )
        result = self.generator.generate_function_name('f2(x)')
        self.assertEqual(result, 'f3')


class TestPosition(unittest.TestCase):
    def test_init(self):
        pos = Position(1, 2)
        self.assertEqual(pos.x, 1)
        self.assertEqual(pos.y, 2)

    def test_str(self):
        pos = Position(1, 2)
        self.assertEqual(str(pos), 'Position: 1, 2')

    def test_get_state(self):
        pos = Position(1, 2)
        expected_state = {"Position": {"x": 1, "y": 2}}
        self.assertEqual(pos.get_state(), expected_state)


class TestPoint(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)), 
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 zoom_point=Position(1, 1), zoom_direction=1, zoom_step=0.1, offset=Position(0.5, 0.5))
        self.point = Point(1, 2, self.canvas, name="p1", color="red")

    def test_initialize(self):
        self.point._initialize()
        self.assertEqual(self.point.x, 1)
        self.assertEqual(self.point.y, -2) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_init(self):
        self.assertEqual(self.point.original_position.x, 1)
        self.assertEqual(self.point.original_position.y, 2)
        self.assertEqual(self.point.name, "p1")
        self.assertEqual(self.point.color, "red")

    def test_get_class_name(self):
        self.assertEqual(self.point.get_class_name(), 'Point')

    def test_str(self):
        self.assertEqual(str(self.point), '1,-2')

    def test_get_state(self):
        expected_state = {"name": "p1", "args": {"position": {"x": 1, "y": 2}}}
        self.assertEqual(self.point.get_state(), expected_state)

    def test_is_visible(self):
        self.assertTrue(self.point.is_visible())

    def test_deepcopy(self):
        point_copy = copy.deepcopy(self.point)
        self.assertEqual(point_copy.original_position.x, self.point.original_position.x)
        self.assertEqual(point_copy.original_position.y, self.point.original_position.y)
        self.assertEqual(point_copy.name, self.point.name)
        self.assertEqual(point_copy.color, self.point.color)
        self.assertIsNot(point_copy, self.point)
        self.assertIsNot(point_copy.original_position, self.point.original_position)

    def test_translate(self):
        self.point._translate(Position(1, 1))
        self.assertEqual(self.point.x, 2)
        self.assertEqual(self.point.y, -1) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_translate_towards(self):
        self.point._translate_towards(Position(2, 2), 1)
        self.assertAlmostEqual(round(self.point.x, 4), 1.2425, places=4)
        self.assertAlmostEqual(round(self.point.y, 5), -1.02986, places=5) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_zoom(self):
        self.point.zoom()
        self.assertAlmostEqual(self.point.x, 1.0, places=4)
        self.assertAlmostEqual(self.point.y, -1.7, places=4) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_pan(self):
        self.point.pan()
        self.assertEqual(self.point.x, 1.5)
        self.assertEqual(self.point.y, -1.5) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestSegment(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 any_segment_part_visible_in_canvas_area=SimpleMock(return_value=True))
        self.p1 = Point(0, 0, self.canvas, name="A", color="red")
        self.p2 = Point(3, 4, self.canvas, name="B", color="red")
        self.segment = Segment(self.p1, self.p2, self.canvas, color="blue")

    def test_initialize(self):
        self.segment._initialize()
        self.assertEqual(self.segment.point1.x, 0)
        self.assertEqual(self.segment.point1.y, 0)
        self.assertEqual(self.segment.point2.x, 3)
        self.assertEqual(self.segment.point2.y, -4)  # Assuming coordinate system adjustments with 0,0 at top-left

    def test_init(self):
        self.assertEqual(self.segment.point1, self.p1)
        self.assertEqual(self.segment.point2, self.p2)
        self.assertEqual(self.segment.color, "blue")

    def test_get_class_name(self):
        self.assertEqual(self.segment.get_class_name(), 'Segment')

    def test_calculate_line_algebraic_formula(self):
        line_formula = self.segment._calculate_line_algebraic_formula()
        # Expected formula depends on MathUtil.get_line_formula implementation
        self.assertIsNotNone(line_formula)  # Assert based on expected output

    def test_any_segment_part_visible_in_canvas_area(self):
        visible = self.segment._any_segment_part_visible_in_canvas_area()
        self.assertTrue(visible)

    def test_is_visible(self):
        self.segment.children = [SimpleMock()]
        self.assertFalse(self.segment.is_visible())  # Assuming children make segment hidden
        self.segment.children = []
        self.assertTrue(self.segment.is_visible())

    def test_get_state(self):
        state = self.segment.get_state()
        expected_state = {"name": "AB", "args": {"p1": "A", "p2": "B", "line_formula": self.segment.line_formula}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        segment_copy = copy.deepcopy(self.segment)
        self.assertIsNot(segment_copy, self.segment)
        self.assertIsNot(segment_copy.point1, self.segment.point1)
        self.assertIsNot(segment_copy.point2, self.segment.point2)
        self.assertEqual(segment_copy.color, self.segment.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestVector(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 any_segment_part_visible_in_canvas_area=SimpleMock(return_value=True))
        self.origin = Point(0, 0, self.canvas, name="O", color="black")
        self.tip = Point(3, 4, self.canvas, name="T", color="black")
        self.vector = Vector(self.origin, self.tip, self.canvas, color="green")

    def test_initialize(self):
        self.vector._initialize()
        # Test that the vector's segment has been initialized correctly
        self.assertEqual(self.vector.segment.point1.x, 0)
        self.assertEqual(self.vector.segment.point1.y, 0)
        self.assertEqual(self.vector.segment.point2.x, 3)
        self.assertEqual(self.vector.segment.point2.y, -4)  # Assuming coordinate system adjustments

    def test_init(self):
        # Test the initial properties of the vector
        self.assertEqual(self.vector.segment.point1, self.origin)
        self.assertEqual(self.vector.segment.point2, self.tip)
        self.assertEqual(self.vector.color, "green")

    def test_get_class_name(self):
        self.assertEqual(self.vector.get_class_name(), 'Vector')

    def test_get_state(self):
        state = self.vector.get_state()
        expected_state = {"name": "OT", "args": {"origin": "O", "tip": "T", "line_formula": self.vector.segment.line_formula}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        vector_copy = copy.deepcopy(self.vector)
        self.assertIsNot(vector_copy, self.vector)
        self.assertIsNot(vector_copy.segment, self.vector.segment)
        self.assertEqual(vector_copy.color, self.vector.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestTriangle(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 any_segment_part_visible_in_canvas_area=SimpleMock(return_value=True))
        # Setup points for the triangle
        self.p1 = Point(0, 0, self.canvas, name="P1", color="red")
        self.p2 = Point(4, 0, self.canvas, name="P2", color="green")
        self.p3 = Point(0, 3, self.canvas, name="P3", color="blue")
        # Setup segments for the triangle
        self.segment1 = Segment(self.p1, self.p2, self.canvas, "red")
        self.segment2 = Segment(self.p2, self.p3, self.canvas, "green")
        self.segment3 = Segment(self.p3, self.p1, self.canvas, "blue")
        # Setup the triangle
        self.triangle = Triangle(self.segment1, self.segment2, self.segment3, self.canvas, color="yellow")

    def test_initialize(self):
        self.triangle._initialize()
        # Test that the triangle's segments have been initialized correctly
        self.assertEqual(self.triangle.segment1.point1.x, 0)
        self.assertEqual(self.triangle.segment1.point1.y, 0)
        self.assertEqual(self.triangle.segment1.point2.x, 4)
        self.assertEqual(self.triangle.segment1.point2.y, 0)
        self.assertEqual(self.triangle.segment2.point1.x, 4)
        self.assertEqual(self.triangle.segment2.point1.y, 0)
        self.assertEqual(self.triangle.segment2.point2.x, 0)
        self.assertEqual(self.triangle.segment2.point2.y, -3) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.triangle.segment3.point1.x, 0)
        self.assertEqual(self.triangle.segment3.point1.y, -3) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.triangle.segment3.point2.x, 0)
        self.assertEqual(self.triangle.segment3.point2.y, 0)

    def test_init(self):
        # Test the initial properties of the triangle
        self.assertEqual(self.triangle.segment1, self.segment1)
        self.assertEqual(self.triangle.segment2, self.segment2)
        self.assertEqual(self.triangle.segment3, self.segment3)
        self.assertEqual(self.triangle.color, "yellow")

    def test_segments_form_triangle(self):
        # Given the corrected logic, ensure your segments are connected as per the new requirements
        self.assertTrue(self.triangle._segments_form_triangle(self.segment1, self.segment2, self.segment3))

    def test_segments_do_not_form_triangle(self):
        # Ensure this test reflects an incorrect connection based on the new logic
        incorrect_segment = Segment(self.p1, Point(2, 2, self.canvas, name="D"), self.canvas, "red")
        self.assertFalse(self.triangle._segments_form_triangle(self.segment1, self.segment2, incorrect_segment))

    def test_identical_points_not_forming_triangle(self):
        # Adjust if necessary to ensure the segments do not meet the new criteria for forming a triangle
        p4 = Point(1, 1, self.canvas, name="D", color="black")
        segment4 = Segment(self.p2, p4, self.canvas, "orange")
        segment5 = Segment(p4, self.p3, self.canvas, "purple")
        self.assertFalse(self.triangle._segments_form_triangle(self.segment1, segment4, segment5))

    def test_get_class_name(self):
        self.assertEqual(self.triangle.get_class_name(), 'Triangle')

    def test_get_state(self):
        state = self.triangle.get_state()
        expected_state = {"name": self.triangle.name, "args": {"p1": "P1", "p2": "P2", "p3": "P3"}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        triangle_copy = copy.deepcopy(self.triangle)
        self.assertIsNot(triangle_copy, self.triangle)
        self.assertIsNot(triangle_copy.segment1, self.triangle.segment1)
        self.assertEqual(triangle_copy.color, self.triangle.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestRectangle(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 any_segment_part_visible_in_canvas_area=SimpleMock(return_value=True))
        # Setup points for the rectangle
        self.p1 = Point(0, 0, self.canvas, name="P1", color="red")
        self.p2 = Point(4, 0, self.canvas, name="P2", color="green")
        self.p3 = Point(4, 3, self.canvas, name="P3", color="blue")
        self.p4 = Point(0, 3, self.canvas, name="P4", color="yellow")
        # Setup segments for the rectangle
        self.segment1 = Segment(self.p1, self.p2, self.canvas, "red")
        self.segment2 = Segment(self.p2, self.p3, self.canvas, "green")
        self.segment3 = Segment(self.p3, self.p4, self.canvas, "blue")
        self.segment4 = Segment(self.p4, self.p1, self.canvas, "yellow")
        # Setup the rectangle
        self.rectangle = Rectangle(self.segment1, self.segment2, self.segment3, self.segment4, self.canvas, color="orange")

    def test_initialize(self):
        self.rectangle._initialize()
        self.assertEqual(self.rectangle.segment1.point1.x, 0)
        self.assertEqual(self.rectangle.segment1.point1.y, 0)
        self.assertEqual(self.rectangle.segment1.point2.x, 4)
        self.assertEqual(self.rectangle.segment1.point2.y, 0)
        self.assertEqual(self.rectangle.segment2.point1.x, 4)
        self.assertEqual(self.rectangle.segment2.point1.y, 0)
        self.assertEqual(self.rectangle.segment2.point2.x, 4)
        self.assertEqual(self.rectangle.segment2.point2.y, -3) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.rectangle.segment3.point1.x, 4)
        self.assertEqual(self.rectangle.segment3.point1.y, -3) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_init(self):
        # Test the initial properties of the rectangle
        self.assertEqual(self.rectangle.segment1, self.segment1)
        self.assertEqual(self.rectangle.segment2, self.segment2)
        self.assertEqual(self.rectangle.segment3, self.segment3)
        self.assertEqual(self.rectangle.segment4, self.segment4)
        self.assertEqual(self.rectangle.color, "orange")

    def test_get_class_name(self):
        self.assertEqual(self.rectangle.get_class_name(), 'Rectangle')

    def test_get_state(self):
        state = self.rectangle.get_state()
        # Expected state needs to account for the names of the points, which should be sorted and unique
        expected_state = {"name": self.rectangle.name, "args": {"p1": "P1", "p2": "P2", "p3": "P3", "p4": "P4"}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        rectangle_copy = copy.deepcopy(self.rectangle)
        self.assertIsNot(rectangle_copy, self.rectangle)
        self.assertIsNot(rectangle_copy.segment1, self.rectangle.segment1)
        self.assertEqual(rectangle_copy.color, self.rectangle.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestCircle(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True))
        self.center = Point(1, 1, self.canvas, name="Center", color="black")
        self.radius = 5
        self.circle = Circle(self.center, self.radius, self.canvas, color="blue")

    def test_initialize(self):
        self.circle._initialize()
        self.assertEqual(self.circle.drawn_radius, self.radius * self.canvas.scale_factor)
        self.assertEqual(self.circle.center, self.center)

    def test_init(self):
        self.assertEqual(self.circle.center, self.center)
        self.assertEqual(self.circle.radius, self.radius)
        self.assertEqual(self.circle.color, "blue")

    def test_get_class_name(self):
        self.assertEqual(self.circle.get_class_name(), 'Circle')

    def test_calculate_circle_algebraic_formula(self):
        formula = self.circle._calculate_circle_algebraic_formula()
        self.assertIsNotNone(formula)

    def test_zoom(self):
        new_scale_factor = 2
        self.canvas.scale_factor = new_scale_factor
        self.circle.zoom()
        self.assertEqual(self.circle.drawn_radius, self.radius * new_scale_factor)

    def test_get_state(self):
        state = self.circle.get_state()
        expected_state = {"name": self.circle.name, "args": {"center": self.center.name, "radius": self.radius, "circle_formula": self.circle.circle_formula}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        circle_copy = copy.deepcopy(self.circle)
        self.assertIsNot(circle_copy, self.circle)
        self.assertIsNot(circle_copy.center, self.circle.center)
        self.assertEqual(circle_copy.radius, self.circle.radius)
        self.assertEqual(circle_copy.color, self.circle.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestEllipse(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True))
        self.center = Point(2, 2, self.canvas, name="Center", color="black")
        self.radius_x = 5
        self.radius_y = 3
        self.ellipse = Ellipse(self.center, self.radius_x, self.radius_y, self.canvas, color="red")

    def test_initialize(self):
        self.ellipse._initialize()
        self.assertEqual(self.ellipse.drawn_radius_x, self.radius_x * self.canvas.scale_factor)
        self.assertEqual(self.ellipse.drawn_radius_y, self.radius_y * self.canvas.scale_factor)
        self.assertEqual(self.ellipse.center, self.center)

    def test_init(self):
        self.assertEqual(self.ellipse.center, self.center)
        self.assertEqual(self.ellipse.radius_x, self.radius_x)
        self.assertEqual(self.ellipse.radius_y, self.radius_y)
        self.assertEqual(self.ellipse.color, "red")

    def test_get_class_name(self):
        self.assertEqual(self.ellipse.get_class_name(), 'Ellipse')

    def test_calculate_ellipse_algebraic_formula(self):
        formula = self.ellipse._calculate_ellipse_algebraic_formula()
        self.assertIsNotNone(formula)

    def test_zoom(self):
        new_scale_factor = 2
        self.canvas.scale_factor = new_scale_factor
        self.ellipse.zoom()
        self.assertEqual(self.ellipse.drawn_radius_x, self.radius_x * new_scale_factor)
        self.assertEqual(self.ellipse.drawn_radius_y, self.radius_y * new_scale_factor)

    def test_get_state(self):
        state = self.ellipse.get_state()
        expected_state = {"name": self.ellipse.name, "args": {"center": self.center.name, "radius_x": self.radius_x, "radius_y": self.radius_y, "ellipse_formula": self.ellipse.ellipse_formula}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        ellipse_copy = copy.deepcopy(self.ellipse)
        self.assertIsNot(ellipse_copy, self.ellipse)
        self.assertIsNot(ellipse_copy.center, self.ellipse.center)
        self.assertEqual(ellipse_copy.radius_x, self.ellipse.radius_x)
        self.assertEqual(ellipse_copy.radius_y, self.ellipse.radius_y)
        self.assertEqual(ellipse_copy.color, self.ellipse.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestFunction(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0),
                                 get_visible_left_bound=SimpleMock(return_value=-10),
                                 get_visible_right_bound=SimpleMock(return_value=10),
                                 get_visible_top_bound=SimpleMock(return_value=10),
                                 get_visible_bottom_bound=SimpleMock(return_value=-10)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True))
        self.left_bound = -9
        self.right_bound = 9
        self.function_string = "x*2"
        self.name = "DoubleX"
        self.function = Function(self.function_string, self.canvas, self.name, left_bound=self.left_bound, right_bound=self.right_bound)

    def test_initialize(self):
        # Test that the function is correctly initialized
        self.assertEqual(self.function.function_string, ExpressionValidator.fix_math_expression(self.function_string))
        self.assertIsNotNone(self.function.function)
        self.assertEqual(self.function.name, self.name)

    def test_init_with_invalid_function_explicit(self):
        with self.assertRaises(ValueError):
            _ = Function("sin(/0)", self.canvas, "InvalidFunction")

    def test_get_class_name(self):
        self.assertEqual(self.function.get_class_name(), 'Function')

    def test_generate_values(self):
        # Test the generation of function values within canvas bounds
        values = self.function._generate_values()
        self.assertTrue(len(values) > 0)
        for value in values:
            self.assertTrue(self.canvas.cartesian2axis.get_visible_left_bound() <= value.x <= self.canvas.cartesian2axis.get_visible_right_bound())
            self.assertTrue(self.canvas.cartesian2axis.get_visible_bottom_bound() <= value.y <= self.canvas.cartesian2axis.get_visible_top_bound())

    def test_zoom(self):
        # Test zoom functionality (mainly impacts _generate_values)
        self.function.zoom()  # This might not change anything directly but can prepare for future tests with scale_factor changes

    def test_get_state(self):
        state = self.function.get_state()
        expected_state = {"name": self.name, "args": {"function_string": self.function_string, "left_bound": self.left_bound, "right_bound": self.right_bound}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        function_copy = copy.deepcopy(self.function)
        self.assertIsNot(function_copy, self.function)
        self.assertEqual(function_copy.function_string, self.function.function_string)
        self.assertEqual(function_copy.name, self.function.name)

    def test_scaled_to_original_and_back(self):
        # Test conversion from scaled to original coordinates and back
        original = (2, 4)
        scaled = self.function._original_to_scaled(*original)
        back_to_original = self.function._scaled_to_original(scaled.x, scaled.y)
        self.assertAlmostEqual(original[0], back_to_original.x)
        self.assertAlmostEqual(original[1], back_to_original.y)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestCartesian2Axis(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(width=800, height=600, center=Position(400, 300), scale_factor=1, cartesian2axis=None, \
                                 zoom_direction=0, offset=Position(10, 10), zoom_point=Position(0, 0), zoom_step=0.1)
        self.cartesian_system = Cartesian2Axis(canvas=self.canvas)
        self.canvas.cartesian2axis = self.cartesian_system
        self.cartesian_system.origin = Point(x=0, y=0, canvas=self.canvas, name="o")

    def test_init(self):
        self.assertEqual(self.cartesian_system.name, "cartesian-2axis-system")
        self.assertEqual(self.cartesian_system.width, self.canvas.width)
        self.assertEqual(self.cartesian_system.height, self.canvas.height)
        self.assertEqual(self.cartesian_system.origin.x, self.canvas.center.x)
        self.assertEqual(self.cartesian_system.origin.y, self.canvas.center.y)
        self.assertEqual(self.cartesian_system.current_tick_spacing, self.cartesian_system.default_tick_spacing)

    def test_get_visible_bounds(self):
        left_bound = self.cartesian_system.get_visible_left_bound()
        right_bound = self.cartesian_system.get_visible_right_bound()
        top_bound = self.cartesian_system.get_visible_top_bound()
        bottom_bound = self.cartesian_system.get_visible_bottom_bound()
        # Test the visible bounds
        self.assertEqual(left_bound, -400.0)  # -self.origin.x / self.canvas.scale_factor
        self.assertEqual(right_bound, 400.0)  # (self.width - self.origin.x) / self.canvas.scale_factor
        self.assertEqual(top_bound, 300.0)    # self.origin.y / self.canvas.scale_factor
        self.assertEqual(bottom_bound, -300.0)  # (self.origin.y - self.height) / self.canvas.scale_factor

    def test_reset(self):
        # Changing the state of the Cartesian2Axis instance
        self.cartesian_system.current_tick_spacing = 50
        self.cartesian_system.reset()
        # Testing reset functionality
        self.assertEqual(self.cartesian_system.current_tick_spacing, self.cartesian_system.default_tick_spacing)
        self.assertEqual(self.cartesian_system.origin.x, self.canvas.center.x)
        self.assertEqual(self.cartesian_system.origin.y, self.canvas.center.y)

    def test_calculate_tick_spacing(self):
        # Set up a Cartesian2Axis object with a specific width, max_ticks, and canvas scale factor
        self.cartesian_system.width = 1000
        self.cartesian_system.max_ticks = 10
        self.cartesian_system.canvas.scale_factor = 2  # Add this line
        # Calculate the tick spacing
        tick_spacing = self.cartesian_system._calculate_tick_spacing()
        # The relative width is self.width / self.canvas.scale_factor: 1000 / 2 = 500.
        # The ideal tick spacing is relative_width / max_ticks: 500 / 10 = 50.
        # The order of magnitude of the ideal tick spacing is 10 ** math.floor(math.log10(ideal_tick_spacing)): 10^1 = 10.
        # The possible spacings are [10, 25, 50, 100].
        # The closest spacing to the ideal tick spacing that is larger or equal to it is 50.
        self.assertEqual(tick_spacing, 50)

    def test_zoom(self):
        # Set up a Cartesian2Axis object with specific properties
        self.cartesian_system.width = 1000
        self.cartesian_system.max_ticks = 10
        self.cartesian_system.canvas.scale_factor = 2
        self.cartesian_system.current_tick_spacing = 100
        self.cartesian_system.canvas.zoom_direction = -1  # Zoom in
        # Call the zoom method
        self.cartesian_system.zoom()
        # The relative width is 500, so the ideal tick spacing is 50.
        # The proposed tick spacing is also 50, which is less than twice the current tick spacing (200).
        # Therefore, the current tick spacing should be updated to the proposed tick spacing.
        self.assertEqual(self.cartesian_system.current_tick_spacing, 50)
        # Change the zoom direction to zoom out
        self.cartesian_system.canvas.zoom_direction = 1
        self.cartesian_system.canvas.scale_factor = 0.5  # Decrease scale factor to simulate zooming out
        # Call the zoom method again
        self.cartesian_system.zoom()
        # Now, the relative width is 2000, so the ideal tick spacing is 200.
        # The order of magnitude of the ideal tick spacing is 100.
        # The possible spacings are [100, 250, 500, 1000].
        # The closest spacing to the ideal tick spacing that is larger or equal to it is 250.
        # Therefore, the current tick spacing should be updated to 250.
        self.assertEqual(self.cartesian_system.current_tick_spacing, 250)

    def test_pan(self):
        original_origin = Position(self.cartesian_system.origin.x, self.cartesian_system.origin.y)
        self.cartesian_system.pan()
        # Verifying that the origin has been moved according to the canvas offset
        self.assertNotEqual(self.cartesian_system.origin.x, original_origin.x)
        self.assertNotEqual(self.cartesian_system.origin.y, original_origin.y)

    def test_state_retrieval(self):
        state = self.cartesian_system.get_state()
        expected_keys = ["Cartesian_System_Visibility"]
        # Test the state retrieval
        self.assertTrue(all(key in state for key in expected_keys))
        self.assertTrue(isinstance(state["Cartesian_System_Visibility"], dict))


class TestCanvas(unittest.TestCase):
    def setUp(self):
        self.canvas = Canvas(500, 500, draw_enabled=False)
        self.mock_cartesian2axis = SimpleMock(draw=SimpleMock(return_value=None), reset=SimpleMock(return_value=None),
                                              get_state=SimpleMock(return_value={'Cartesian_System_Visibility': 'cartesian_state'}),
                                              origin=Position(0, 0))
        self.canvas.cartesian2axis = self.mock_cartesian2axis
        self.mock_point1 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Point'), reset=SimpleMock(return_value=None),
                                      get_state=SimpleMock(return_value='point1_state'),
                                      original_position=Position(10, 10), x=10, y=10, name='A')
        self.mock_point2 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Point'), reset=SimpleMock(return_value=None),
                                      get_state=SimpleMock(return_value='point2_state'),
                                      original_position=Position(20, 20), x=20, y=20, name='B')
        self.mock_point3 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Point'), reset=SimpleMock(return_value=None),
                                      get_state=SimpleMock(return_value='point3_state'), 
                                      original_position=Position(30, 30), x=30, y=30, name='C')
        self.mock_segment1 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Segment'), reset=SimpleMock(return_value=None),
                                        get_state=SimpleMock(return_value='segment1_state'), point1=self.mock_point1, point2=self.mock_point2)
        self.mock_segment2 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Segment'), reset=SimpleMock(return_value=None),
                                        get_state=SimpleMock(return_value='segment2_state'), point1=self.mock_point2, point2=self.mock_point3)
        self.mock_segment3 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Segment'), reset=SimpleMock(return_value=None),
                                        get_state=SimpleMock(return_value='segment3_state'), point1=self.mock_point3, point2=self.mock_point1)

    def test_init(self):
        self.assertEqual(self.canvas.width, 500)
        self.assertEqual(self.canvas.height, 500)
        self.assertEqual(self.canvas.scale_factor, 1)
        self.assertEqual(self.canvas.zoom_point.x, 0)
        self.assertEqual(self.canvas.zoom_point.y, 0)
        self.assertEqual(self.canvas.zoom_direction, 0)
        self.assertEqual(self.canvas.zoom_step, 0.1)
        self.assertEqual(self.canvas.dragging, False)
        self.assertEqual(self.canvas.offset.x, 0)
        self.assertEqual(self.canvas.offset.y, 0)
        self.assertEqual(self.canvas.cartesian2axis, self.mock_cartesian2axis)

    def test_add_drawable(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.assertEqual(self.mock_point1.canvas, self.canvas)
        self.assertIn('Point', self.canvas.drawables)
        self.assertIn('Segment', self.canvas.drawables)
        self.assertIn(self.mock_point1, self.canvas.drawables['Point'])
        self.assertIn(self.mock_segment1, self.canvas.drawables['Segment'])

    def test_get_drawables(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        drawables = self.canvas.get_drawables()
        self.assertEqual(drawables, [self.mock_point1, self.mock_segment1])

    def test_get_drawables_by_class_name(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        drawables = self.canvas.get_drawables_by_class_name('Point')
        self.assertEqual(drawables, [self.mock_point1])

    def test_fix_drawable_canvas_references(self):
        self.canvas.drawables = {'Point': [self.mock_point1], 'Segment': [self.mock_segment1]}
        self.assertEqual(self.mock_point1.canvas, None)
        self.assertEqual(self.mock_segment1.canvas, None)
        self.canvas._fix_drawable_canvas_references()
        self.assertEqual(self.mock_point1.canvas, self.canvas)
        self.assertEqual(self.mock_segment1.canvas, self.canvas)

    def test_get_drawables_state(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        state = self.canvas.get_drawables_state()
        self.assertEqual(state, {'Points': ['point1_state'], 'Segments': ['segment1_state']})

    def test_get_cartesian2axis_state(self):
        state = self.canvas.get_cartesian2axis_state()
        self.assertEqual(state, {'Cartesian_System_Visibility': 'cartesian_state'})

    def test_get_canvas_state(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        state = self.canvas.get_canvas_state()
        self.assertEqual(state, {'Points': ['point1_state'], 'Segments': ['segment1_state'], 'Cartesian_System_Visibility': 'cartesian_state'})

    def test_clear(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.canvas.clear()
        self.mock_cartesian2axis.reset.assert_called_once_with()
        self.assertEqual(self.canvas.drawables, {})

    def test_reset(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.canvas.center = Position(randint(1, 100), randint(1, 100))
        self.canvas.scale_factor = randint(1, 100)
        self.canvas.offset = Position(randint(1, 100), randint(1, 100))
        self.dragging = True
        # Reset the canvas
        self.canvas.reset()
        # Test the canvas properties
        self.assertEqual(self.canvas.center.x, self.canvas.width / 2)
        self.assertEqual(self.canvas.center.y, self.canvas.height / 2)
        self.assertEqual(self.canvas.scale_factor, 1)
        self.assertEqual(self.canvas.offset.x, 0)
        self.assertEqual(self.canvas.offset.y, 0)
        self.assertEqual(self.canvas.dragging, False)
        self.mock_cartesian2axis.reset.assert_called_once_with()
        self.mock_point1.reset.assert_called_once_with()
        self.mock_segment1.reset.assert_called_once_with()

    def test_get_point(self):
        self.canvas.add_drawable(self.mock_point1)
        point = self.canvas.get_point(10, 10)
        self.assertEqual(point, self.mock_point1)
        point = self.canvas.get_point(5, 5)
        self.assertIsNone(point)

    def test_get_point_by_name(self):
        self.canvas.add_drawable(self.mock_point1)
        point = self.canvas.get_point_by_name('A')
        self.assertEqual(point, self.mock_point1)
        point = self.canvas.get_point_by_name('Z')
        self.assertIsNone(point)

    def test_create_point_existing(self):
        self.canvas.add_drawable(self.mock_point1)
        point = self.canvas.create_point(10, 10)
        self.assertEqual(point, self.mock_point1)

    def test_create_point_new_unnamed(self):
        self.canvas.add_drawable(self.mock_point1)
        point = self.canvas.create_point(30, 30)
        self.assertIsNotNone(point)
        self.assertEqual(point.name, 'B')
        self.assertIn(point, self.canvas.drawables['Point'])

    def test_create_point_new_named(self):
        point = self.canvas.create_point(30, 30, 'C')
        self.assertIsNotNone(point)
        self.assertEqual(point.name, 'C')
        self.assertIn(point, self.canvas.drawables['Point'])

    def test_delete_point(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.delete_point(10, 10)
        self.assertNotIn(self.mock_point1, self.canvas.get_drawables_by_class_name(self.mock_point1.get_class_name()))

    def test_is_point_within_canvas_visible_area(self):
        self.assertTrue(self.canvas.is_point_within_canvas_visible_area(250, 250))
        self.assertFalse(self.canvas.is_point_within_canvas_visible_area(-1, 501))

    def test_get_segment_by_coordinates(self):
        self.canvas.add_drawable(self.mock_segment1)
        segment = self.canvas.get_segment_by_coordinates(self.mock_point1.x, self.mock_point1.y, 
                                                         self.mock_point2.x, self.mock_point2.y)
        self.assertEqual(segment, self.mock_segment1)
        segment = self.canvas.get_segment_by_coordinates(5, 5, 15, 15)
        self.assertIsNone(segment)

    def test_get_segment_by_points(self):
        self.canvas.add_drawable(self.mock_segment1)
        segment = self.canvas.get_segment_by_points(self.mock_point1, self.mock_point2)
        self.assertEqual(segment, self.mock_segment1)

    def test_create_segment_existing(self):
        self.canvas.add_drawable(self.mock_segment1)
        segment = self.canvas.create_segment(10, 10, 20, 20)
        self.assertEqual(segment, self.mock_segment1)

    def test_create_segment_new(self):
        segment = self.canvas.create_segment(100, 100, 300, 300)
        self.assertIsNotNone(segment)
        self.assertIn(segment, self.canvas.get_drawables_by_class_name('Segment'))
        self.assertEqual(segment.point1.x, 100)
        self.assertEqual(segment.point1.y, -100)
        self.assertEqual(segment.point2.x, 300)
        self.assertEqual(segment.point2.y, -300)

    def test_delete_segment(self):
        self.canvas.create_segment(10, 10, 20, 20)
        self.canvas.delete_segment(10, 10, 20, 20)
        self.assertNotIn(self.mock_segment1, self.canvas.get_drawables_by_class_name('Segment'))
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)

    def test_any_segment_part_visible_in_canvas_area(self):
        center = self.canvas.center
        width = self.canvas.width
        height = self.canvas.height
        visible = self.canvas.any_segment_part_visible_in_canvas_area(0, 0, width, height)
        self.assertTrue(visible)
        visible = self.canvas.any_segment_part_visible_in_canvas_area(center.x, height + 100, width + 100, center.y)
        self.assertTrue(visible)
        not_visible = self.canvas.any_segment_part_visible_in_canvas_area(width + 10, height + 10, height + 100, width + 100)
        self.assertFalse(not_visible)

    def test_get_vector(self):
        p1 = self.mock_point1
        p2 = self.mock_point2
        created_vector = self.canvas.create_vector(p1.x, p1.y, p2.x, p2.y)
        retrieved_vector = self.canvas.get_vector(p1.x, p1.y, p2.x, p2.y)
        self.assertEqual(created_vector, retrieved_vector) 
        # Test retrieving a non-existent vector by coordinates
        vector = self.canvas.get_vector(100, 100, 200, 200)
        self.assertIsNone(vector, "Retrieved a vector when expected none.")

    def test_create_vector_existing(self):
        mock_vector = SimpleMock(canvas=self.canvas, get_class_name=SimpleMock(return_value='Vector'), segment=self.mock_segment1)
        self.canvas.add_drawable(mock_vector)
        vector = self.canvas.create_vector(mock_vector.segment.point1.x, mock_vector.segment.point1.y, mock_vector.segment.point2.x, mock_vector.segment.point2.y)
        self.assertEqual(vector, mock_vector)

    def test_create_vector_new(self):
        vector = self.canvas.create_vector(100, 100, 300, 300)
        p1 = vector.segment.point1
        p2 = vector.segment.point2
        self.assertIsNotNone(vector)
        self.assertIn(vector, self.canvas.get_drawables_by_class_name('Vector'))
        self.assertEqual(p1.x, 100)
        self.assertEqual(p1.y, -100)
        self.assertEqual(p2.x, 300)
        self.assertEqual(p2.y, -300)

    def test_delete_vector(self):
        vector = self.canvas.create_vector(10, 10, 20, 20)
        self.canvas.delete_vector(10, 10, 20, 20)
        self.assertNotIn(vector, self.canvas.get_drawables_by_class_name('Vector'))
        # Check points are still present after deleting the vector
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)


class TestExpressionValidator(unittest.TestCase):
    def test_validate_expression_tree_valid(self):
        valid_expressions = [
            "x**2",
            "sin(x) + cos(x)",
            "sqrt(x) * log(x)",
            "exp(x) / tan(x)",
            "log10(x) + log2(x)",
            "factorial(5) - asin(0.5)",
            "acos(0.5) + atan(1)",
            "sinh(x) - cosh(x)",
            "tanh(x) + exp(1)",
            "abs(-x) + pi",
            "e * pow(2, 3)",
            "bin(10)"
        ]
        for expr in valid_expressions:
            with self.subTest(expr=expr):
                try:
                    ExpressionValidator.validate_expression_tree(expr)
                except ValueError as e:
                    self.fail(f"Unexpected exception for '{expr}': {e}")

    def test_validate_expression_tree_invalid(self):
        invalid_expressions = [
            "", " ", "\t", "\n",  # Empty or whitespace-only strings
            "import os",  # Import statements
            "from os import system",  # From...import statements
            "__import__('os')",  # Disallowed function call
            "__import__('os').system('ls')",  # Attribute access and disallowed function call
            "os.system('ls')",  # Attribute access and disallowed function call
            "[1, 2, 3][0]",  # Subscripting
            "x = 1",  # Assignment
            "x += 1",  # Augmented assignment
            "exec('print(1)')",  # Exec statements
            "global x",  # Global statements
            "nonlocal x",  # Nonlocal statements
            "lambda x: x + 2",  # Lambda expressions
            "tan2(x)",
            "fact(5)",
            "asinn(0.5)",
            "acoss(0.5)",
            "atann(1)",
            "sinhh(x)",
            "cossh(x)",
            "tanhh(x)",
            "expp(1)",
        ]
        for expr in invalid_expressions:
            with self.subTest(expr=expr):
                with self.assertRaises(ValueError):
                    ExpressionValidator.validate_expression_tree(expr)

    def test_evaluate_expression(self):
        x = 2  # Define x for use in expressions
        expressions = {
            "sin(pi/2)": math.sin(math.pi / 2),
            "sqrt(16)": 4,
            "sqrt(-4)": '2i',
            "log(e)": 1.0,
            "cos(pi)": math.cos(math.pi),
            "tan(pi/4)": math.tan(math.pi / 4),
            "log10(100)": 2.0,
            "log2(16)": 4.0,
            "factorial(5)": 120.0,
            "asin(1)": math.pi / 2,
            "acos(0)": math.pi / 2,
            "atan(1)": math.pi / 4,
            "sinh(0)": 0.0,
            "cosh(0)": 1.0,
            "tanh(0)": 0.0,
            "exp(1)": math.e,
            "abs(-5)": 5.0,
            "pow(2, 3)": 8,
            "bin(10)": '0b1010',
            "x": x
        }
        for expr, expected in expressions.items():
            with self.subTest(expr=expr):
                result = ExpressionValidator.evaluate_expression(expr, x=x)
                if isinstance(expected, float):
                    self.assertAlmostEqual(result, expected)
                else:
                    self.assertEqual(result, expected)

    def test_degree_to_radian_conversion(self):
        expressions_and_expected = {
            "sin(30deg)": f"sin({30 * math.pi / 180})",  # Should convert 30 degrees to radians
            "cos(45deg) + sin(90deg)": f"cos({45 * math.pi / 180}) + sin({90 * math.pi / 180})",  # Converts both 45 and 90 degrees to radians
            "tan(60deg)": f"tan({60 * math.pi / 180})",  # Converts 60 degrees to radians
            "sin(30)": f"sin({30 * math.pi / 180})",  # Should convert 30 degrees to radians
            "cos(45 degrees) + sin(90 degree)": f"cos({45 * math.pi / 180}) + sin({90 * math.pi / 180})",  # Converts both 45 and 90 degrees to radians
        }
        for expr, expected in expressions_and_expected.items():
            with self.subTest(expr=expr):
                fixed_expr = ExpressionValidator.fix_math_expression(expr, python_compatible=False)
                self.assertAlmostEqual(eval(fixed_expr, {"sin": math.sin, "cos": math.cos, "tan": math.tan, "pi": math.pi}), \
                                       eval(expected, {"sin": math.sin, "cos": math.cos, "tan": math.tan, "pi": math.pi}))

    def test_fix_math_expression_python_compatibility(self):
        expressions_and_fixes = {
            "sin(pi/4)^2": "sin(pi/4)**2",
            "2x": "2*x",
            "e^x": "e**x",
            "2sin(x)": "2*sin(x)",
            "|x|": "abs(x)",
            "x": "sqrt(x)",
            "{x}": "(x)",
            "2j": "2j",
            "3.14i": "3.14j",
        }
        for expr, expected_fix in expressions_and_fixes.items():
            with self.subTest(expr=expr):
                fixed_expr = ExpressionValidator.fix_math_expression(expr, python_compatible=True)
                self.assertEqual(fixed_expr, expected_fix)

    def test_fix_math_expression_js_compatibility(self):
        expressions_and_expected = {
            # Checks for reverting Python-compatible transformations
            "sqrt(x)**2": "sqrt(x)^2",
            "x**2": "x^2",  # Power operator replaced with '^'
            "|x|": "|x|",
            "{x}": "(x)",  # Curly braces reverted to parentheses
            "[x]": "(x)",  # Square brackets reverted to parentheses
            "3.14j": "3.14i",  # Complex number notation reverted to 'i'
            "2i": "2i",
            "e**x": "e^x",  # Exponential notation
        }
        for expr, expected in expressions_and_expected.items():
            with self.subTest(expr=expr):
                fixed_expr = ExpressionValidator.fix_math_expression(expr, python_compatible=False)
                self.assertEqual(fixed_expr, expected)

    def test_parse_function_string_returns_number(self):
        function_elements = [
            "sin(pi/4)",
            "cos(/3)",
            "sqrt(16)",
            "tan(5)",
            "log(e)",
            "log10(100)",
            "log2(8)",
            "factorial(3)",
            "asin(0.5)",
            "acos(0.5)",
            "atan(1)",
            "sinh(1)",
            "cosh(1)",
            "tanh(0)",
            "exp(1)",
            "abs(-pi)",
            "pow(2, 3)"
        ]
        for element in function_elements:
            with self.subTest(element=element):
                f = ExpressionValidator.parse_function_string(element)
                # Test with a range of values
                for x in range(-10, 11):
                    result = f(x)
                    self.assertIsInstance(result, (int, float), f"Result of expression '{element}' for x={x} is not a number: {result}")

    def test_parse_function_string(self):
        expressions = {
            "x^2": lambda x: x**2,
            "sin(x)": math.sin,
            "log(x)": math.log,
            "log10(x)": math.log10,
            "sqrt(x)": math.sqrt,
            "exp(x)": math.exp,
            "tan(x)": math.tan,
            "sin(pi/4) + cos(/3) - tan(sqrt(16)) * log(e) / log10(100) + log2(8) * factorial(3) + asin(0.5) - acos(0.5) + atan(1) + sinh(1) - cosh(1) + tanh(0) + exp(1) - abs(-pi) + pow(2, 3)^2": lambda x: 82.09880526150872
        }
        for use_mathjs in [False, True]:
            for expr, expected_func in expressions.items():
                with self.subTest(expr=expr, use_mathjs=use_mathjs):
                    func = ExpressionValidator.parse_function_string(expr, use_mathjs=use_mathjs)
                    test_values = [0.1, 1, math.pi]
                    for value in test_values:
                        expected_result = expected_func(value)
                        result = func(value)
                        print(f"Expected: {expected_result}, Result: {result}")
                        self.assertAlmostEqual(result, expected_result, msg=f"Failed on expr: {expr} with x={value}")


def run_tests():
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    suite.addTest(loader.loadTestsFromTestCase(TestMathFunctions))
    suite.addTest(loader.loadTestsFromTestCase(TestDrawableNameGenerator))
    suite.addTest(loader.loadTestsFromTestCase(TestPosition))
    suite.addTest(loader.loadTestsFromTestCase(TestPoint))
    suite.addTest(loader.loadTestsFromTestCase(TestSegment))
    suite.addTest(loader.loadTestsFromTestCase(TestVector))
    suite.addTest(loader.loadTestsFromTestCase(TestTriangle))
    suite.addTest(loader.loadTestsFromTestCase(TestRectangle))
    suite.addTest(loader.loadTestsFromTestCase(TestCircle))
    suite.addTest(loader.loadTestsFromTestCase(TestEllipse))
    suite.addTest(loader.loadTestsFromTestCase(TestFunction))
    suite.addTest(loader.loadTestsFromTestCase(TestCartesian2Axis))
    suite.addTest(loader.loadTestsFromTestCase(TestCanvas))
    suite.addTest(loader.loadTestsFromTestCase(TestExpressionValidator))
    runner = unittest.TextTestRunner()
    runner.run(suite)