from collections import namedtuple
from math_util import MathUtil
from name_generator import DrawableNameGenerator
from point import Position, Point
from math_geometry import Segment, Triangle, Vector
import copy
import json
import unittest


class SimpleMock:
    def __init__(self, **kwargs):
        self._attributes = {}
        self._return_value = None
        for key, value in kwargs.items():
            if key == 'return_value':
                self._return_value = value
            else:
                self._attributes[key] = value

    def __getattr__(self, attr):
        if attr in self._attributes:
            return self._attributes[attr]
        elif attr == 'return_value':
            return self._return_value
        else:
            raise AttributeError(f"'{type(self).__name__}' object has no attribute '{attr}'")

    def __call__(self, *args, **kwargs):
        return self._return_value


class TestMathFunctions(unittest.TestCase):
    def test_format_number_1(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123456789, max_digits=6), '1.2e+8')

    def test_format_number_2(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(0.000123456789, max_digits=6), '0.00012')

    def test_format_number_3(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123456, max_digits=6), '123456')

    def test_format_number_4(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123.456, max_digits=6), '123.456')

    def test_format_number_5(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(0, max_digits=6), '0')

    def test_format_number_6(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-123456789, max_digits=6), '-1.2e+8')

    def test_format_number_7(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-0.000123456789, max_digits=6), '-0.00012')

    def test_format_number_8(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-123456, max_digits=6), '-123456')

    def test_format_number_9(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-123.456, max_digits=6), '-123.456')

    def test_format_number_10(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(1.23456789, max_digits=6), '1.23457')

    def test_format_number_11(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(0.000000123456789, max_digits=6), '1.2e-7')

    def test_format_number_12(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123456.789, max_digits=6), '123457')

    def test_format_number_13(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123.456789, max_digits=6), '123.457')

    def test_format_number_14(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(0.00000000000001, max_digits=6), '1e-14')

    def test_format_number_15(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-1.23456789, max_digits=6), '-1.23457')

    def test_format_number_16(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-0.000000123456789, max_digits=6), '-1.2e-7')

    def test_format_number_17(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-123456.789, max_digits=6), '-123457')

    def test_format_number_18(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-123.456789, max_digits=6), '-123.457')

    def test_format_number_19(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(-0.00000000000001, max_digits=6), '-1e-14')

    def test_format_number_20(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123456789, max_digits=3), '1.2e+8')

    def test_format_number_21(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(0.000123456789, max_digits=3), '1.2e-4')

    def test_format_number_22(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123456, max_digits=3), '1.2e+5')

    def test_format_number_23(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123.456, max_digits=3), '123')

    def test_format_number_24(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(1.23456789, max_digits=3), '1.23')

    def test_format_number_25(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(0.000000123456789, max_digits=3), '1.2e-7')

    def test_format_number_26(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123456.789, max_digits=3), '1.2e+5')

    def test_format_number_27(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(123.456789, max_digits=3), '123')

    def test_format_number_28(self):
        self.assertEqual(MathUtil.format_number_for_cartesian(0.00000000000001, max_digits=3), '1e-14')

    def test_get_2D_distance(self):
        Point = namedtuple('Point', ['x', 'y'])
        p1 = Point(0, 0)
        p2 = Point(3, 4)
        self.assertEqual(MathUtil.get_2D_distance(p1, p2), 5)

    def test_get_2D_midpoint(self):
        Point = namedtuple('Point', ['x', 'y'])
        p1 = Point(0, 0)
        p2 = Point(2, 2)
        x, y = MathUtil.get_2D_midpoint(p1, p2)
        self.assertEqual(x, 1)
        self.assertEqual(y, 1)

    def test_is_point_on_segment(self):
        self.assertTrue(MathUtil.is_point_on_segment(1, 1, 0, 0, 2, 2))
        self.assertFalse(MathUtil.is_point_on_segment(3, 3, 0, 0, 2, 2))

    def test_get_triangle_area(self):
        Point = namedtuple('Point', ['x', 'y'])
        p1 = Point(0, 0)
        p2 = Point(1, 0)
        p3 = Point(0, 1)
        self.assertAlmostEqual(MathUtil.get_triangle_area(p1, p2, p3), 0.5)

    def test_get_rectangle_area(self):
        Point = namedtuple('Point', ['x', 'y'])
        p1 = Point(0, 0)
        p2 = Point(2, 3)
        self.assertEqual(MathUtil.get_rectangle_area(p1, p2), 6)

    def test_validate_rectangle(self):
        self.assertTrue(MathUtil.validate_rectangle(0, 0, 1, 0, 1, 1, 0, 1))
        self.assertFalse(MathUtil.validate_rectangle(0, 0, 1, 0, 1, 2, 0, 1))

    def test_segments_intersect(self):
        self.assertTrue(MathUtil.segments_intersect(0, 0, 1, 1, 0, 1, 1, 0))
        self.assertFalse(MathUtil.segments_intersect(0, 0, 1, 1, 2, 2, 3, 3))

    def test_get_segments_intersection(self):
        x_intersection, y_intersection = MathUtil.get_segments_intersection(0, 0, 1, 1, 0, 1, 1, 0)
        self.assertAlmostEqual(x_intersection, 0.5, places=7)
        self.assertAlmostEqual(y_intersection, 0.5, places=7)

    def test_get_segments_intersection_parallel(self):
        # Define two parallel segments
        result = MathUtil.get_segments_intersection(0, 0, 1, 1, 2, 2, 3, 3)
        # Since the segments are parallel, the result should be None
        self.assertIsNone(result, "Expected None for parallel segments")

    def test_get_line_formula(self):
        self.assertEqual(MathUtil.get_line_formula(0, 0, 1, 1), "y = 1.0 * x + 0.0")
        self.assertEqual(MathUtil.get_line_formula(0, 0, 0, 1), "x = 0")

    def test_get_circle_formula(self):
        self.assertEqual(MathUtil.get_circle_formula(0, 0, 1), "(x - 0)**2 + (y - 0)**2 = 1**2")

    def test_get_ellipse_formula(self):
        self.assertEqual(MathUtil.get_ellipse_formula(0, 0, 1, 2), "((x - 0)**2)/1**2 + ((y - 0)**2)/2**2 = 1")

    def test_sqrt(self):
        result = MathUtil.sqrt(-4)
        self.assertEqual(result, "2i")
        result = MathUtil.sqrt(4)
        self.assertEqual(int(result), 2)

    def test_pow(self):
        result = MathUtil.pow(2, 3)
        self.assertEqual(int(result), 8)
        matrix = [[-1, 2], [3, 1]]
        result = MathUtil.pow(matrix, 2)
        self.assertEqual(result, "[[7, 0], [0, 7]]")

    def test_evaluate_conversion(self):
        result = MathUtil.convert(12.7, "cm", "inch")
        self.assertEqual(result, "5 inch")

    def test_evaluate_division(self):
        result = MathUtil.evaluate("12 / (2.3 + 0.7)")
        self.assertEqual(int(result), 4)

    def test_evaluate_sin(self):
        result = MathUtil.evaluate("sin(45 deg) ^ 2")
        print(f"sin(45 deg) ^ 2 = {result}")
        self.assertAlmostEqual(float(result), 0.5, places=9)

    def test_evaluate_js_power_symbol(self):
        result = MathUtil.evaluate("9^2 / 3")
        self.assertEqual(int(result), 27)

    def test_evaluate_py_power_symbol(self):
        result = MathUtil.evaluate("9**2 / 3")
        self.assertEqual(int(result), 27)

    def test_evaluate_complex(self):
        result = MathUtil.evaluate("1 + 2i + 1j")
        self.assertEqual(result, "1 + 3i")

    def test_evaluate_det(self):
        matrix = [[-1, 2], [3, 1]]
        result = MathUtil.det(matrix)
        self.assertEqual(int(result), -7)

    def test_random(self):
        result = MathUtil.random()
        self.assertTrue(0 <= result <= 1)

    def test_round(self):
        result = MathUtil.round(1.2345, 2)
        self.assertEqual(result, 1.23)

    def test_gcd(self):
        result = MathUtil.gcd(48, 18)
        self.assertEqual(result, 6)

    def test_lcm(self):
        result = MathUtil.lcm(4, 5)
        self.assertEqual(result, 20)

    def test_mean(self):
        result = MathUtil.mean([1, 2, 3, 4, 5])
        self.assertEqual(result, 3)

    def test_median(self):
        result = MathUtil.median([1, 2, 3, 4, 5])
        self.assertEqual(result, 3)

    def test_mode(self):
        result = MathUtil.mode([1, 2, 2, 3])
        self.assertEqual(result, 2)

    def test_stdev(self):
        result = MathUtil.stdev([2, 4, 6, 8, 10])
        self.assertAlmostEqual(result, 3.1623, places=4)

    def test_variance(self):
        result = MathUtil.variance([2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5])
        self.assertAlmostEqual(result, 1.372, places=3)

    def test_limit(self):
        result = MathUtil.limit('sin(x) / x', 'x', 0)
        result = float(result)  # convert result to float
        self.assertEqual(result, 1.0)

    def test_derivative(self):
        result = MathUtil.derivative('x^2', 'x')
        self.assertEqual(result, "2*x")

    def test_integral_indefinite(self):
        result = MathUtil.integral('x^2', 'x')
        result = MathUtil.simplify(result)  # simplify the result
        self.assertEqual(result, "0.3333333333333333*x^3")

    def test_integral(self):
        result = MathUtil.integral('x^2', 'x', 0, 1)
        result = float(result)  # convert result to float
        self.assertAlmostEqual(result, 0.333, places=3)

    def test_simplify(self):
        result = MathUtil.simplify('x^2 + 2*x + 1')
        self.assertEqual(result, "(1+x)^2")

    def test_expand(self):
        result = MathUtil.expand('(x + 1)^2')
        self.assertEqual(result, "1+2*x+x^2")

    def test_factor(self):
        result = MathUtil.factor('x^2 - 1')
        self.assertEqual(result, "(-1+x)*(1+x)")

    def test_solve(self):
        result = MathUtil.solve('x^2 - 4', 'x')
        result = json.loads(result)  # parse result from JSON string to list
        result = [float(r) for r in result]  # convert results to floats
        self.assertEqual(result, [2.0, -2.0])

    def test_solve_system_of_equations(self):
        result = MathUtil.solve_system_of_equations(['x + y = 4', 'x - y = 2'])
        result = dict(item.split(" = ") for item in result.split(", "))  # parse result from string to dictionary
        result = {k: float(v) for k, v in result.items()}  # convert results to floats
        self.assertEqual(result, {"x": 3.0, "y": 1.0})


class TestDrawableNameGenerator(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock()
        self.generator = DrawableNameGenerator(self.canvas)

    def test_get_drawable_names(self):
        # Here, get_drawables_by_class_name is expected to be a callable that returns a list of mocks when called
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='Point1'), SimpleMock(name='Point2')]
        )
        result = self.generator.get_drawable_names('Point')
        self.assertEqual(result, ['Point1', 'Point2'])

    def test_filter_string(self):
        # Test with a string that contains letters, digits, apostrophes, and parentheses
        result = self.generator.filter_string("Test(123)'")
        self.assertEqual(result, "Test(123)'")
        # Test with a string that contains special characters
        result = self.generator.filter_string("Hello, World!")
        self.assertEqual(result, "HelloWorld")
        # Test with a string that contains whitespace
        result = self.generator.filter_string("Hello World")
        self.assertEqual(result, "HelloWorld")
        # Test with a string that contains only disallowed characters
        result = self.generator.filter_string("!@#$%^&*")
        self.assertEqual(result, "")
        # Test with an empty string
        result = self.generator.filter_string("")
        self.assertEqual(result, "")

    def test_split_point_names(self):
        result = self.generator.split_point_names("A'B'CD", 4)
        self.assertEqual(result, ["A'", "B'", "C", "D"])

    def test_generate_unique_point_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(return_value=[])
        point_names = []
        for _ in range(52):
            new_name = self.generator._generate_unique_point_name()
            point_names.append(new_name)
            # Update the return_value of get_drawables_by_class_name with each new name
            self.canvas.get_drawables_by_class_name.return_value.append(SimpleMock(name=new_name))
        # The next point name should be 'A'' (A with two apostrophes)
        result = self.generator._generate_unique_point_name()
        self.assertEqual(result, "A''")

    def test_generate_point_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A')]
        )
        result = self.generator.generate_point_name(None)
        self.assertEqual(result, 'B')

    def test_generate_point_name_with_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A')]
        )
        result = self.generator.generate_point_name('B')
        self.assertEqual(result, 'B')

    def test_generate_point_name_with_used_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='A'), SimpleMock(name='B')]
        )
        result = self.generator.generate_point_name('B')
        self.assertNotEqual(result, 'B')

    def test_increment_function_name(self):
        # Test with a function name that ends with a number
        result = self.generator._increment_function_name('f4')
        self.assertEqual(result, 'f5')
        # Test with a function name that does not end with a number
        result = self.generator._increment_function_name('f')
        self.assertEqual(result, 'f1')
        # Test with a function name that ends with a large number
        result = self.generator._increment_function_name('f99')
        self.assertEqual(result, 'f100')
        # Test with a function name that ends with a number and has other numbers in it
        result = self.generator._increment_function_name('f4f4')
        self.assertEqual(result, 'f4f5')
        # Test with a function name that does not end with a number and has other numbers in it
        result = self.generator._increment_function_name('f4f')
        self.assertEqual(result, 'f4f1')

    def test_generate_unique_function_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(return_value=[])
        function_names = []
        for _ in range(42):
            new_name = self.generator._generate_unique_function_name()
            function_names.append(new_name)
            # Update the return_value of get_drawables_by_class_name with each new name
            self.canvas.get_drawables_by_class_name.return_value.append(SimpleMock(name=new_name))
        # The next function name should be 'r1'
        result = self.generator._generate_unique_function_name()
        self.assertEqual(result, "v1")

    def test_generate_function_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f'), SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name(None)
        self.assertEqual(result, 'g')

    def test_generate_function_name_with_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name('f2')
        self.assertEqual(result, 'f2')

    def test_generate_function_name_with_used_preferred_name(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1'), SimpleMock(name='f2')]
        )
        result = self.generator.generate_function_name('f2')
        self.assertEqual(result, 'f3')

    def test_generate_function_name_with_preferred_name_and_parentheses(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1')]
        )
        result = self.generator.generate_function_name('f2(x)')
        self.assertEqual(result, 'f2')

    def test_generate_function_name_with_used_preferred_name_and_parentheses(self):
        self.canvas.get_drawables_by_class_name = SimpleMock(
            return_value=[SimpleMock(name='f1'), SimpleMock(name='f2')]
        )
        result = self.generator.generate_function_name('f2(x)')
        self.assertEqual(result, 'f3')


class TestPosition(unittest.TestCase):
    def test_init(self):
        pos = Position(1, 2)
        self.assertEqual(pos.x, 1)
        self.assertEqual(pos.y, 2)

    def test_str(self):
        pos = Position(1, 2)
        self.assertEqual(str(pos), 'Position: 1, 2')

    def test_get_state(self):
        pos = Position(1, 2)
        expected_state = {"Position": {"x": 1, "y": 2}}
        self.assertEqual(pos.get_state(), expected_state)


class TestPoint(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)), 
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 zoom_point=Position(1, 1), zoom_direction=1, zoom_step=0.1, offset=Position(0.5, 0.5))
        self.point = Point(1, 2, self.canvas, name="p1", color="red")

    def test_initialize(self):
        self.point._initialize()
        self.assertEqual(self.point.x, 1)
        self.assertEqual(self.point.y, -2) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_init(self):
        self.assertEqual(self.point.original_position.x, 1)
        self.assertEqual(self.point.original_position.y, 2)
        self.assertEqual(self.point.name, "p1")
        self.assertEqual(self.point.color, "red")

    def test_get_class_name(self):
        self.assertEqual(self.point.get_class_name(), 'Point')

    def test_str(self):
        self.assertEqual(str(self.point), '1,-2')

    def test_get_state(self):
        expected_state = {"name": "p1", "args": {"position": {"x": 1, "y": 2}}}
        self.assertEqual(self.point.get_state(), expected_state)

    def test_is_visible(self):
        self.assertTrue(self.point.is_visible())

    def test_deepcopy(self):
        point_copy = copy.deepcopy(self.point)
        self.assertEqual(point_copy.original_position.x, self.point.original_position.x)
        self.assertEqual(point_copy.original_position.y, self.point.original_position.y)
        self.assertEqual(point_copy.name, self.point.name)
        self.assertEqual(point_copy.color, self.point.color)
        self.assertIsNot(point_copy, self.point)
        self.assertIsNot(point_copy.original_position, self.point.original_position)

    def test_translate(self):
        self.point._translate(Position(1, 1))
        self.assertEqual(self.point.x, 2)
        self.assertEqual(self.point.y, -1) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_scale_coordinates(self):
        self.point._scale_coordinates(2)
        self.assertEqual(self.point.x, 2)
        self.assertEqual(self.point.y, -4) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_translate_towards(self):
        self.point._translate_towards(Position(2, 2), 1)
        self.assertAlmostEqual(round(self.point.x, 4), 1.2425, places=4)
        self.assertAlmostEqual(round(self.point.y, 5), -1.02986, places=5) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_zoom(self):
        self.point.zoom()
        self.assertAlmostEqual(self.point.x, 1.0, places=4)
        self.assertAlmostEqual(self.point.y, -1.7, places=4) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_pan(self):
        self.point.pan()
        self.assertEqual(self.point.x, 1.5)
        self.assertEqual(self.point.y, -1.5) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestSegment(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 any_segment_part_visible_in_canvas_area=SimpleMock(return_value=True))
        self.p1 = Point(0, 0, self.canvas, name="A", color="red")
        self.p2 = Point(3, 4, self.canvas, name="B", color="red")
        self.segment = Segment(self.p1, self.p2, self.canvas, color="blue")

    def test_initialize(self):
        self.segment._initialize()
        self.assertEqual(self.segment.point1.x, 0)
        self.assertEqual(self.segment.point1.y, 0)
        self.assertEqual(self.segment.point2.x, 3)
        self.assertEqual(self.segment.point2.y, -4)  # Assuming coordinate system adjustments with 0,0 at top-left

    def test_init(self):
        self.assertEqual(self.segment.point1, self.p1)
        self.assertEqual(self.segment.point2, self.p2)
        self.assertEqual(self.segment.color, "blue")

    def test_get_class_name(self):
        self.assertEqual(self.segment.get_class_name(), 'Segment')

    def test_calculate_line_algebraic_formula(self):
        line_formula = self.segment._calculate_line_algebraic_formula()
        # Expected formula depends on MathUtil.get_line_formula implementation
        self.assertIsNotNone(line_formula)  # Assert based on expected output

    def test_any_segment_part_visible_in_canvas_area(self):
        visible = self.segment._any_segment_part_visible_in_canvas_area()
        self.assertTrue(visible)

    def test_is_visible(self):
        self.segment.children = [SimpleMock()]
        self.assertFalse(self.segment.is_visible())  # Assuming children make segment hidden
        self.segment.children = []
        self.assertTrue(self.segment.is_visible())

    def test_translate(self):
        self.segment._translate(Position(1, 1))
        self.assertEqual(self.segment.point1.x, 1)
        self.assertEqual(self.segment.point1.y, 1) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.segment.point2.x, 4)
        self.assertEqual(self.segment.point2.y, -3) # Assuming coordinate system adjustments with 0,0 at top-left

    def test_translate_towards(self):
        destination = Point(5, 5, self.canvas)
        self.segment._translate_towards(destination, 1)
        # Expected new positions after translation
        expected_p1_x = 0.7071067811865475
        expected_p1_y = -0.7071067811865475
        expected_p2_x = 3.8944271909999157
        expected_p2_y = -4.447213595499958
        # Verify new positions of points
        self.assertAlmostEqual(self.segment.point1.x, expected_p1_x, places=4) 
        self.assertAlmostEqual(self.segment.point1.y, expected_p1_y, places=4)
        self.assertAlmostEqual(self.segment.point2.x, expected_p2_x, places=4)
        self.assertAlmostEqual(self.segment.point2.y, expected_p2_y, places=4) 

    def test_scale(self):
        original_length = MathUtil.get_2D_distance(self.segment.point1, self.segment.point2)
        self.segment._scale(2)  # Scaling by a factor of 2
        new_length = MathUtil.get_2D_distance(self.segment.point1, self.segment.point2)
        # Verify the length of the segment has doubled
        self.assertAlmostEqual(new_length, 2 * original_length, places=4)
        # Verify the midpoint remains constant
        new_midpoint_x, new_midpoint_y = MathUtil.get_2D_midpoint(self.segment.point1, self.segment.point2)
        expected_midpoint_x = (self.p1.x + self.p2.x) / 2
        expected_midpoint_y = (self.p1.y + self.p2.y) / 2
        self.assertAlmostEqual(new_midpoint_x, expected_midpoint_x, places=4)
        self.assertAlmostEqual(new_midpoint_y, expected_midpoint_y, places=4)

    def test_get_state(self):
        state = self.segment.get_state()
        expected_state = {"name": "AB", "args": {"p1": "A", "p2": "B", "line_formula": self.segment.line_formula}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        segment_copy = copy.deepcopy(self.segment)
        self.assertIsNot(segment_copy, self.segment)
        self.assertIsNot(segment_copy.point1, self.segment.point1)
        self.assertIsNot(segment_copy.point2, self.segment.point2)
        self.assertEqual(segment_copy.color, self.segment.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestVector(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 any_segment_part_visible_in_canvas_area=SimpleMock(return_value=True))
        self.origin = Point(0, 0, self.canvas, name="O", color="black")
        self.tip = Point(3, 4, self.canvas, name="T", color="black")
        self.vector = Vector(self.origin, self.tip, self.canvas, color="green")

    def test_initialize(self):
        self.vector._initialize()
        # Test that the vector's segment has been initialized correctly
        self.assertEqual(self.vector.segment.point1.x, 0)
        self.assertEqual(self.vector.segment.point1.y, 0)
        self.assertEqual(self.vector.segment.point2.x, 3)
        self.assertEqual(self.vector.segment.point2.y, -4)  # Assuming coordinate system adjustments

    def test_init(self):
        # Test the initial properties of the vector
        self.assertEqual(self.vector.segment.point1, self.origin)
        self.assertEqual(self.vector.segment.point2, self.tip)
        self.assertEqual(self.vector.color, "green")

    def test_get_class_name(self):
        self.assertEqual(self.vector.get_class_name(), 'Vector')

    def test_translate(self):
        self.vector._translate(Position(1, 1))
        # Verify the segment (and thus the vector) has been translated correctly
        self.assertEqual(self.vector.segment.point1.x, 1)
        self.assertEqual(self.vector.segment.point1.y, 1)
        self.assertEqual(self.vector.segment.point2.x, 4)
        self.assertEqual(self.vector.segment.point2.y, -3)

    def test_scale(self):
        original_length = MathUtil.get_2D_distance(self.vector.segment.point1, self.vector.segment.point2)
        self.vector._scale(2)  # Scaling by a factor of 2
        new_length = MathUtil.get_2D_distance(self.vector.segment.point1, self.vector.segment.point2)
        # Verify the length of the segment (and thus the vector) has doubled
        self.assertAlmostEqual(new_length, 2 * original_length, places=4)

    def test_get_state(self):
        state = self.vector.get_state()
        expected_state = {"name": "OT", "args": {"origin": "O", "tip": "T", "line_formula": self.vector.segment.line_formula}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        vector_copy = copy.deepcopy(self.vector)
        self.assertIsNot(vector_copy, self.vector)
        self.assertIsNot(vector_copy.segment, self.vector.segment)
        self.assertEqual(vector_copy.color, self.vector.color)

    def test_draw(self):
        # This test would check if draw calls create_svg_element with expected arguments
        # Might require a more complex setup or mocking to verify SVG output
        pass


class TestTriangle(unittest.TestCase):
    def setUp(self):
        self.canvas = SimpleMock(scale_factor=1, cartesian2axis=SimpleMock(origin=Position(0, 0)),
                                 is_point_within_canvas_visible_area=SimpleMock(return_value=True),
                                 any_segment_part_visible_in_canvas_area=SimpleMock(return_value=True))
        # Setup points for the triangle
        self.p1 = Point(0, 0, self.canvas, name="P1", color="red")
        self.p2 = Point(4, 0, self.canvas, name="P2", color="green")
        self.p3 = Point(0, 3, self.canvas, name="P3", color="blue")
        # Setup segments for the triangle
        self.segment1 = Segment(self.p1, self.p2, self.canvas, "red")
        self.segment2 = Segment(self.p2, self.p3, self.canvas, "green")
        self.segment3 = Segment(self.p3, self.p1, self.canvas, "blue")
        # Setup the triangle
        self.triangle = Triangle(self.segment1, self.segment2, self.segment3, self.canvas, color="yellow")

    def test_initialize(self):
        self.triangle._initialize()
        # Test that the triangle's segments have been initialized correctly
        self.assertEqual(self.triangle.segment1.point1.x, 0)
        self.assertEqual(self.triangle.segment1.point1.y, 0)
        self.assertEqual(self.triangle.segment1.point2.x, 4)
        self.assertEqual(self.triangle.segment1.point2.y, 0)
        self.assertEqual(self.triangle.segment2.point1.x, 4)
        self.assertEqual(self.triangle.segment2.point1.y, 0)
        self.assertEqual(self.triangle.segment2.point2.x, 0)
        self.assertEqual(self.triangle.segment2.point2.y, -3) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.triangle.segment3.point1.x, 0)
        self.assertEqual(self.triangle.segment3.point1.y, -3) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.triangle.segment3.point2.x, 0)
        self.assertEqual(self.triangle.segment3.point2.y, 0)

    def test_init(self):
        # Test the initial properties of the triangle
        self.assertEqual(self.triangle.segment1, self.segment1)
        self.assertEqual(self.triangle.segment2, self.segment2)
        self.assertEqual(self.triangle.segment3, self.segment3)
        self.assertEqual(self.triangle.color, "yellow")

    def test_segments_form_triangle(self):
        # Given the corrected logic, ensure your segments are connected as per the new requirements
        self.assertTrue(self.triangle._segments_form_triangle(self.segment1, self.segment2, self.segment3))

    def test_segments_do_not_form_triangle(self):
        # Ensure this test reflects an incorrect connection based on the new logic
        incorrect_segment = Segment(self.p1, Point(2, 2, self.canvas, name="D"), self.canvas, "red")
        self.assertFalse(self.triangle._segments_form_triangle(self.segment1, self.segment2, incorrect_segment))

    def test_identical_points_not_forming_triangle(self):
        # Adjust if necessary to ensure the segments do not meet the new criteria for forming a triangle
        p4 = Point(1, 1, self.canvas, name="D", color="black")
        segment4 = Segment(self.p2, p4, self.canvas, "orange")
        segment5 = Segment(p4, self.p3, self.canvas, "purple")
        self.assertFalse(self.triangle._segments_form_triangle(self.segment1, segment4, segment5))

    def test_get_class_name(self):
        self.assertEqual(self.triangle.get_class_name(), 'Triangle')

    def test_translate(self):
        self.triangle._translate(Position(1, 1))
        # Verify the triangle (and thus its segments) has been translated correctly
        self.assertEqual(self.triangle.segment1.point1.x, 1)
        self.assertEqual(self.triangle.segment1.point1.y, 1)
        self.assertEqual(self.triangle.segment1.point2.x, 5)
        self.assertEqual(self.triangle.segment1.point2.y, 1)
        self.assertEqual(self.triangle.segment2.point1.x, 5)
        self.assertEqual(self.triangle.segment2.point1.y, 1)
        self.assertEqual(self.triangle.segment2.point2.x, 1)
        self.assertEqual(self.triangle.segment2.point2.y, -2) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.triangle.segment3.point1.x, 1)
        self.assertEqual(self.triangle.segment3.point1.y, -2) # Assuming coordinate system adjustments with 0,0 at top-left
        self.assertEqual(self.triangle.segment3.point2.x, 1)
        self.assertEqual(self.triangle.segment3.point2.y, 1)

    def test_scale(self):
        original_area = MathUtil.get_triangle_area(self.p1, self.p2, self.p3)
        self.triangle._scale(2)  # Scaling by a factor of 2
        new_area = MathUtil.get_triangle_area(self.triangle.segment1.point1, self.triangle.segment2.point1, self.triangle.segment3.point1)
        # Verify the area of the triangle has quadrupled (since area scales by the square of the scaling factor)
        self.assertAlmostEqual(new_area, 4 * original_area, places=4)

    def test_get_state(self):
        state = self.triangle.get_state()
        expected_state = {"name": self.triangle.name, "args": {"p1": "P1", "p2": "P2", "p3": "P3"}}
        self.assertEqual(state, expected_state)

    def test_deepcopy(self):
        triangle_copy = copy.deepcopy(self.triangle)
        self.assertIsNot(triangle_copy, self.triangle)
        self.assertIsNot(triangle_copy.segment1, self.triangle.segment1)
        self.assertEqual(triangle_copy.color, self.triangle.color)


def run_tests():
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    suite.addTest(loader.loadTestsFromTestCase(TestMathFunctions))
    suite.addTest(loader.loadTestsFromTestCase(TestDrawableNameGenerator))
    suite.addTest(loader.loadTestsFromTestCase(TestPosition))
    suite.addTest(loader.loadTestsFromTestCase(TestPoint))
    suite.addTest(loader.loadTestsFromTestCase(TestSegment))
    suite.addTest(loader.loadTestsFromTestCase(TestVector))
    suite.addTest(loader.loadTestsFromTestCase(TestTriangle))
    runner = unittest.TextTestRunner()
    runner.run(suite)