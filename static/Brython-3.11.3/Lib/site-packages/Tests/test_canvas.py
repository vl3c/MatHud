import unittest
from random import randint

from canvas import Canvas
from point import Position
from .simple_mock import SimpleMock


class TestCanvas(unittest.TestCase):
    def setUp(self):
        self.canvas = Canvas(500, 500, draw_enabled=False)
        self.mock_cartesian2axis = SimpleMock(draw=SimpleMock(return_value=None), reset=SimpleMock(return_value=None),
                                              get_state=SimpleMock(return_value={'Cartesian_System_Visibility': 'cartesian_state'}),
                                              origin=Position(0, 0))
        self.canvas.cartesian2axis = self.mock_cartesian2axis
        self.mock_point1 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Point'), reset=SimpleMock(return_value=None),
                                      get_state=SimpleMock(return_value='point1_state'),
                                      original_position=Position(10, 10), x=10, y=10, name='A')
        self.mock_point2 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Point'), reset=SimpleMock(return_value=None),
                                      get_state=SimpleMock(return_value='point2_state'),
                                      original_position=Position(20, 20), x=20, y=20, name='B')
        self.mock_segment1 = SimpleMock(canvas=None, get_class_name=SimpleMock(return_value='Segment'), reset=SimpleMock(return_value=None),
                                        get_state=SimpleMock(return_value='segment1_state'), point1=self.mock_point1, point2=self.mock_point2)

    def test_init(self):
        self.assertEqual(self.canvas.width, 500)
        self.assertEqual(self.canvas.height, 500)
        self.assertEqual(self.canvas.scale_factor, 1)
        self.assertEqual(self.canvas.zoom_point.x, 0)
        self.assertEqual(self.canvas.zoom_point.y, 0)
        self.assertEqual(self.canvas.zoom_direction, 0)
        self.assertEqual(self.canvas.zoom_step, 0.1)
        self.assertEqual(self.canvas.dragging, False)
        self.assertEqual(self.canvas.offset.x, 0)
        self.assertEqual(self.canvas.offset.y, 0)
        self.assertEqual(self.canvas.cartesian2axis, self.mock_cartesian2axis)

    def test_add_drawable(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.assertEqual(self.mock_point1.canvas, self.canvas)
        self.assertIn('Point', self.canvas.drawables)
        self.assertIn('Segment', self.canvas.drawables)
        self.assertIn(self.mock_point1, self.canvas.drawables['Point'])
        self.assertIn(self.mock_segment1, self.canvas.drawables['Segment'])

    def test_get_drawables(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        drawables = self.canvas.get_drawables()
        self.assertEqual(drawables, [self.mock_point1, self.mock_segment1])

    def test_get_drawables_by_class_name(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        drawables = self.canvas.get_drawables_by_class_name(self.mock_point1.get_class_name())
        self.assertEqual(drawables, [self.mock_point1])

    def test_fix_drawable_canvas_references(self):
        self.canvas.drawables = {'Point': [self.mock_point1], 'Segment': [self.mock_segment1]}
        self.assertEqual(self.mock_point1.canvas, None)
        self.assertEqual(self.mock_segment1.canvas, None)
        self.canvas._fix_drawable_canvas_references()
        self.assertEqual(self.mock_point1.canvas, self.canvas)
        self.assertEqual(self.mock_segment1.canvas, self.canvas)

    def test_get_drawables_state(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        state = self.canvas.get_drawables_state()
        self.assertEqual(state, {'Points': ['point1_state'], 'Segments': ['segment1_state']})

    def test_get_cartesian2axis_state(self):
        state = self.canvas.get_cartesian2axis_state()
        self.assertEqual(state, {'Cartesian_System_Visibility': 'cartesian_state'})

    def test_get_canvas_state(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        state = self.canvas.get_canvas_state()
        self.assertEqual(state, {'Points': ['point1_state'], 'Segments': ['segment1_state'], 'Cartesian_System_Visibility': 'cartesian_state'})

    def test_clear(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.canvas.clear()
        self.mock_cartesian2axis.reset.assert_called_once_with()
        self.assertEqual(self.canvas.drawables, {})

    def test_reset(self):
        self.canvas.add_drawable(self.mock_point1)
        self.canvas.add_drawable(self.mock_segment1)
        self.canvas.center = Position(randint(1, 100), randint(1, 100))
        self.canvas.scale_factor = randint(1, 100)
        self.canvas.offset = Position(randint(1, 100), randint(1, 100))
        self.dragging = True
        # Reset the canvas
        self.canvas.reset()
        # Test the canvas properties
        self.assertEqual(self.canvas.center.x, self.canvas.width / 2)
        self.assertEqual(self.canvas.center.y, self.canvas.height / 2)
        self.assertEqual(self.canvas.scale_factor, 1)
        self.assertEqual(self.canvas.offset.x, 0)
        self.assertEqual(self.canvas.offset.y, 0)
        self.assertEqual(self.canvas.dragging, False)
        self.mock_cartesian2axis.reset.assert_called_once_with()
        self.mock_point1.reset.assert_called_once_with()
        self.mock_segment1.reset.assert_called_once_with()

    def test_undo_redo(self):
        # Test basic undo/redo functionality
        point = self.canvas.create_point(0, 0, "A")
        segment = self.canvas.create_segment(0, 0, 10, 10, "AB")
        
        # Store initial state properties
        initial_point_pos = (point.original_position.x, point.original_position.y)
        initial_segment_points = (
            (segment.point1.original_position.x, segment.point1.original_position.y),
            (segment.point2.original_position.x, segment.point2.original_position.y)
        )
        
        # Make some changes
        self.canvas.delete_point_by_name("A")
        self.canvas.delete_segment_by_name("AB")
        
        # Verify changes
        self.assertIsNone(self.canvas.get_point_by_name("A"))
        self.assertIsNone(self.canvas.get_segment_by_name("AB"))
        
        # Undo changes
        self.canvas.undo()
        
        # Verify state is restored
        restored_point = self.canvas.get_point_by_name("A")
        restored_segment = self.canvas.get_segment_by_name("AB")
        
        self.assertIsNotNone(restored_point)
        self.assertIsNotNone(restored_segment)
        self.assertEqual(
            (restored_point.original_position.x, restored_point.original_position.y),
            initial_point_pos
        )
        self.assertEqual(
            (restored_segment.point1.original_position.x, restored_segment.point1.original_position.y),
            initial_segment_points[0]
        )
        self.assertEqual(
            (restored_segment.point2.original_position.x, restored_segment.point2.original_position.y),
            initial_segment_points[1]
        )
        
        # Redo changes
        self.canvas.redo()
        self.assertIsNone(self.canvas.get_point_by_name("A"))
        self.assertIsNone(self.canvas.get_segment_by_name("AB"))

    # Point tests
    def test_create_point_existing(self):
        p1 = self.canvas.create_point(10, 10)
        p2 = self.canvas.create_point(10, 10)
        self.assertEqual(p2, p1)

    def test_create_point_new_unnamed(self):
        p1 = self.canvas.create_point(10, 10)
        p2 = self.canvas.create_point(30, 30)
        self.assertIsNotNone(p1)
        self.assertIsNotNone(p2)
        self.assertEqual(p1.name, 'A')
        self.assertEqual(p2.name, 'B')
        self.assertIn(p1, self.canvas.drawables['Point'])
        self.assertIn(p2, self.canvas.drawables['Point'])

    def test_create_point_new_named(self):
        point = self.canvas.create_point(30, 30, 'C')
        self.assertIsNotNone(point)
        self.assertEqual(point.name, 'C')
        self.assertIn(point, self.canvas.drawables['Point'])

    def test_get_point(self):
        point_created = self.canvas.create_point(10, 10)
        point_retrieved = self.canvas.get_point(10, 10)
        self.assertEqual(point_created, point_retrieved)
        point = self.canvas.get_point(5, 5)
        self.assertIsNone(point)

    def test_get_point_by_name(self):
        point_created = self.canvas.create_point(10, 10)
        point_retrieved = self.canvas.get_point_by_name('A')
        self.assertEqual(point_created, point_retrieved)
        point = self.canvas.get_point_by_name('Z')
        self.assertIsNone(point)

    def test_delete_point(self):
        p1 = self.canvas.create_point(10, 10)
        self.canvas.delete_point(10, 10)
        self.assertNotIn(p1, self.canvas.get_drawables_by_class_name(p1.get_class_name()))

    def test_delete_point_by_name(self):
        p1 = self.canvas.create_point(10, 10)
        self.canvas.delete_point_by_name('A')
        self.assertNotIn(p1, self.canvas.get_drawables_by_class_name(p1.get_class_name()))

    def test_is_point_within_canvas_visible_area(self):
        self.assertTrue(self.canvas.is_point_within_canvas_visible_area(250, 250))
        self.assertFalse(self.canvas.is_point_within_canvas_visible_area(-1, 501))

    # Segment tests
    def test_create_segment_existing(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        s2 = self.canvas.create_segment(10, 10, 20, 20)
        self.assertEqual(s2, s1)

    def test_create_segment_new(self):
        s = self.canvas.create_segment(100, 100, 300, 300)
        self.assertIsNotNone(s)
        self.assertIn(s, self.canvas.get_drawables_by_class_name(s.get_class_name()))
        self.assertEqual(s.point1.x, 100)
        self.assertEqual(s.point1.y, -100)
        self.assertEqual(s.point2.x, 300)
        self.assertEqual(s.point2.y, -300)

    def test_get_segment_by_coordinates(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        s = self.canvas.get_segment_by_coordinates(10, 10, 20, 20)
        self.assertEqual(s, s1)
        s = self.canvas.get_segment_by_coordinates(5, 5, 15, 15)
        self.assertIsNone(s)

    def test_get_segment_by_points(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        self.assertIsNotNone(s1)
        p1 = self.canvas.get_point(10, 10)
        self.assertIsNotNone(p1)
        p2 = self.canvas.get_point(20, 20)
        self.assertIsNotNone(p2)
        s2 = self.canvas.get_segment_by_points(p1, p2)
        self.assertIsNotNone(s2)
        self.assertEqual(s2, s1)

    def test_delete_segment(self):
        s = self.canvas.create_segment(10, 10, 20, 20)
        self.canvas.delete_segment(10, 10, 20, 20)
        self.assertNotIn(s, self.canvas.get_drawables_by_class_name(s.get_class_name()))
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)

    def test_delete_segment_by_name(self):
        # Create a segment and get its name
        segment = self.canvas.create_segment(10, 10, 20, 20)
        segment_name = segment.name
        
        # Delete the segment by name
        self.canvas.delete_segment_by_name(segment_name)
        
        # Verify segment was deleted
        self.assertNotIn(segment, self.canvas.get_drawables_by_class_name(segment.get_class_name()))
        
        # Verify points still exist
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)

    def test_any_segment_part_visible_in_canvas_area(self):
        center = self.canvas.center
        width = self.canvas.width
        height = self.canvas.height
        visible = self.canvas.any_segment_part_visible_in_canvas_area(0, 0, width, height)
        self.assertTrue(visible)
        visible = self.canvas.any_segment_part_visible_in_canvas_area(center.x, height + 100, width + 100, center.y)
        self.assertTrue(visible)
        not_visible = self.canvas.any_segment_part_visible_in_canvas_area(width + 10, height + 10, height + 100, width + 100)
        self.assertFalse(not_visible)

    def test_delete_segments_depending_on_point(self):
        segment = self.canvas.create_segment(10, 10, 30, 30)
        self.assertIsNotNone(segment)
        self.assertIn(segment, self.canvas.get_drawables_by_class_name(segment.get_class_name()))
        self.canvas._delete_point_dependencies(10, 10)
        self.assertNotIn(segment, self.canvas.get_drawables_by_class_name(segment.get_class_name()))

    def test_remove_segment_from_parents(self):
        segment = self.canvas.create_segment(10, 20, 30, 20)
        point = self.canvas.create_point(20, 20)
        self.assertIsNotNone(segment)
        self.assertIsNotNone(point)
        self.assertEquals(len(segment.children), 2, "Segment should have 2 children.")
        child = list(segment.children)[0]
        self.canvas._remove_segment_from_parents(child)
        self.assertEquals(len(segment.children), 1, "Segment should have 1 child.")

    def test_delete_segment_children(self):
        ad = self.canvas.create_segment(0, 0, 30, 0)
        self.canvas.create_point(10, 0)
        self.canvas.create_point(20, 0)
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 6, "There should be 6 segments in total.")
        self.assertEquals(len(ad.children), 5, "Parent segment should have 5 children.")
        # Execute: Delete AD segment's children
        self.canvas._delete_segment_dependencies(0, 0, 30, 0, delete_children=True, delete_parents=False)
        # Verify: All contained child segments should be deleted
        self.assertEquals(len(ad.children), 0, "Parent segment should have no children.")
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 1, "There should be one segment left.")

    def test_delete_segment_parents(self):
        s = self.canvas.create_segment(50, 0, 60, 0) # distinct segment
        self.canvas.create_segment(0, 0, 30, 0)  # root segment
        self.canvas.create_point(10, 0)
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 4, "There should be 4 segments in total.")
        self.canvas.create_point(20, 0)
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 7, "There should be 7 segments in total.")
        # Delete segment's parents
        self.canvas._delete_segment_dependencies(0, 0, 10, 0, delete_children=False, delete_parents=True)
        # Verify: Segment parents should be deleted
        self.assertEquals(len(self.canvas.get_drawables_by_class_name('Segment')), 1, "There should be one segment left - deleting the parent also deletes its children.")
        self.assertIn(s, self.canvas.get_drawables_by_class_name('Segment'), "Distinct segment should not be deleted.")

    def test_get_unique_point_names_from_segments(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        s2 = self.canvas.create_segment(20, 20, 30, 30)
        s3 = self.canvas.create_segment(40, 40, 50, 50)
        self.assertIsNotNone(s1)
        self.assertIsNotNone(s2)
        self.assertIsNotNone(s3)
        point_names = self.canvas._get_unique_point_names_from_segments([s1, s2, s3])
        self.assertTrue(len(point_names) == 5, "There should be 5 unique point names.")

    def test_are_points_connected(self):
        s1 = self.canvas.create_segment(10, 10, 20, 20)
        s2 = self.canvas.create_segment(20, 20, 30, 30)
        p1 = self.canvas.get_point(10, 10)
        p2 = self.canvas.get_point(20, 20)
        p3 = self.canvas.get_point(30, 30)
        points = [p1.name, p2.name, p3.name]
        # Check if the points are not connected
        are_not_connected = self.canvas._is_fully_connected_graph(points)
        self.assertFalse(are_not_connected, "All points should not be connected.")
        # Create a segment connecting the points
        s3 = self.canvas.create_segment(30, 30, 10, 10)
        # Check again if the points are fully connected
        are_connected = self.canvas._is_fully_connected_graph(points)
        self.assertTrue(are_connected, "The points should be fully connected.")

    # Vector tests
    def test_create_vector_existing(self):
        v1 = self.canvas.create_vector(10, 10, 20, 20)
        v2 = self.canvas.create_vector(10, 10, 20, 20)
        self.assertEqual(v2, v1)

    def test_create_vector_new(self):
        vector = self.canvas.create_vector(100, 100, 300, 300)
        p1 = vector.segment.point1
        p2 = vector.segment.point2
        self.assertIsNotNone(vector)
        self.assertIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))
        self.assertEqual(p1.x, 100)
        self.assertEqual(p1.y, -100)
        self.assertEqual(p2.x, 300)
        self.assertEqual(p2.y, -300)

    def test_get_vector(self):
        p1 = self.mock_point1
        p2 = self.mock_point2
        created_vector = self.canvas.create_vector(p1.x, p1.y, p2.x, p2.y)
        retrieved_vector = self.canvas.get_vector(p1.x, p1.y, p2.x, p2.y)
        self.assertEqual(created_vector, retrieved_vector)
        # Test retrieving a non-existent vector by coordinates
        vector = self.canvas.get_vector(100, 100, 200, 200)
        self.assertIsNone(vector, "Retrieved a vector when expected none.")

    def test_delete_vector(self):
        vector = self.canvas.create_vector(10, 10, 20, 20)
        self.canvas.delete_vector(10, 10, 20, 20)
        self.assertNotIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))
        # Check points are still present after deleting the vector
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertIn(self.canvas.get_point(10, 10), points)
        self.assertIn(self.canvas.get_point(20, 20), points)

    def test_delete_vectors_depending_on_point(self):
        vector = self.canvas.create_vector(10, 10, 20, 20)
        self.assertIsNotNone(vector)
        self.assertIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))
        self.canvas._delete_point_dependencies(10, 10)
        self.assertNotIn(vector, self.canvas.get_drawables_by_class_name(vector.get_class_name()))

    # Triangle tests
    def test_create_triangle_existing(self):
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        retrieved_triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.assertEqual(triangle, retrieved_triangle)

    def test_create_triangle_new(self):
        new_triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.assertIsNotNone(new_triangle)
        self.assertIn(new_triangle, self.canvas.get_drawables_by_class_name('Triangle'))

    def test_get_triangle(self):
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        retrieved_triangle = self.canvas.get_triangle(10, 10, 20, 20, 30, 30)
        self.assertEqual(triangle, retrieved_triangle)
        # Test retrieving a non-existent triangle
        non_existent_triangle = self.canvas.get_triangle(100, 100, 200, 200, 300, 300)
        self.assertIsNone(non_existent_triangle)

    def test_delete_triangle(self):
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.canvas.delete_triangle(10, 10, 20, 20, 30, 30)
        self.assertNotIn(triangle, self.canvas.get_drawables_by_class_name(triangle.get_class_name()))
        # Verifying segments and points still exist after deleting the triangle
        points = self.canvas.get_drawables_by_class_name('Point')
        self.assertTrue(all(p in points for p in [self.canvas.get_point(10, 10), self.canvas.get_point(20, 20), self.canvas.get_point(30, 30)]))

    def test_delete_triangles_depending_on_point(self):
        triangle = self.canvas.create_triangle(10, 10, 20, 20, 30, 30)
        self.assertIsNotNone(triangle)
        self.assertIn(triangle, self.canvas.get_drawables_by_class_name(triangle.get_class_name()))
        self.canvas._delete_point_dependencies(10, 10)
        self.assertNotIn(triangle, self.canvas.get_drawables_by_class_name(triangle.get_class_name()))

    def test_create_triangle_from_connected_segments(self):
        # Setup: Create segments that form a triangle
        self.canvas.create_segment(10, 10, 20, 20, name="AB", extra_graphics=False)
        self.canvas.create_segment(20, 20, 10, 30, name="BC", extra_graphics=False)
        self.canvas.create_segment(10, 30, 10, 10, name="CA", extra_graphics=False)
        # Verify initial conditions
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Segment")), 3, "Canvas should initially have 3 segments.")
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Triangle")), 0, "Canvas should initially have no triangles.")
        # Execute: Attempt to create new triangles from connected segments
        self.canvas._create_new_triangles_from_connected_segments()
        # Verify: A triangle should be created from the three segments
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Triangle")), 1, "Canvas should have 1 triangle after operation.")

    def test_no_triangle_from_unconnected_segments(self):
        # Setup: Create segments that do not form a triangle
        self.canvas.create_segment(10, 10, 20, 20)
        self.canvas.create_segment(20, 20, 30, 20)
        self.canvas.create_segment(40, 40, 50, 50)
        # Execute: Attempt to create new triangles from unconnected segments
        self.canvas._create_new_triangles_from_connected_segments()
        # Verify: No triangle should be created as the segments are not connected
        self.assertEqual(len(self.canvas.get_drawables_by_class_name("Triangle")), 0, "Canvas should have no triangles as segments are unconnected.")

    # Rectangle tests
    def test_create_rectangle_new(self):
        # Directly test creating a new rectangle without previous setup
        new_rectangle = self.canvas.create_rectangle(10, 10, 40, 40)
        self.assertIsNotNone(new_rectangle, "Failed to create a new rectangle.")
        self.assertIn(new_rectangle, self.canvas.get_drawables_by_class_name('Rectangle'), "New rectangle should be in canvas.")

    def test_get_rectangle_by_diagonal_points(self):
        # Create a rectangle for this test
        rectangle_created = self.canvas.create_rectangle(10, 10, 30, 30)
        # Test retrieving an existing rectangle
        rectangle_retrieved = self.canvas.get_rectangle_by_diagonal_points(10, 10, 30, 30)
        self.assertIsNotNone(rectangle_retrieved, "Rectangle should exist.")
        self.assertEqual(rectangle_created, rectangle_retrieved, "Retrieved rectangle should be the same as the created one.")
        # Test retrieving a non-existent rectangle
        non_existent_rectangle = self.canvas.get_rectangle_by_diagonal_points(100, 100, 200, 200)
        self.assertIsNone(non_existent_rectangle, "Should not retrieve a non-existent rectangle.")

    def test_get_rectangle_by_name(self):
        # Create a rectangle for this test
        rectangle_created = self.canvas.create_rectangle(10, 10, 20, 20)
        # Test retrieving an existing rectangle by name
        rectangle_retrieved = self.canvas.get_rectangle_by_name(rectangle_created.name)
        self.assertIsNotNone(rectangle_retrieved, "Rectangle should exist.")
        self.assertEqual(rectangle_created, rectangle_retrieved, "Retrieved rectangle should be the same as the created one.")
        # Test retrieving a non-existent rectangle by name
        non_existent_rectangle = self.canvas.get_rectangle_by_name("NonExistent")
        self.assertIsNone(non_existent_rectangle, "Should not retrieve a non-existent rectangle by name.")

    def test_create_rectangle_existing(self):
        # Create a rectangle to test reusing existing rectangles
        created_rectangle = self.canvas.create_rectangle(10, 10, 30, 30)
        # Test creating a rectangle with the same coordinates
        retrieved_rectangle = self.canvas.create_rectangle(10, 10, 30, 30)
        self.assertEqual(created_rectangle, retrieved_rectangle, "Should reuse the existing rectangle.")

    def test_delete_rectangle(self):
        # Create a rectangle to test deletion
        rectangle = self.canvas.create_rectangle(10, 10, 30, 30, name="ABCD")
        # Test deleting the rectangle
        self.canvas.delete_rectangle(rectangle.name)
        self.assertIsNone(self.canvas.get_rectangle_by_diagonal_points(10, 10, 30, 30), "Rectangle should be deleted.")
        self.assertIsNone(self.canvas.get_rectangle_by_name("ABCD"), "Rectangle should be deleted.")

    def test_delete_rectangles_depending_on_point(self):
        rectangle = self.canvas.create_rectangle(10, 10, 30, 30)
        self.assertIsNotNone(rectangle)
        self.assertIn(rectangle, self.canvas.get_drawables_by_class_name(rectangle.get_class_name()))
        self.canvas._delete_point_dependencies(10, 10)
        self.assertNotIn(rectangle, self.canvas.get_drawables_by_class_name(rectangle.get_class_name()))

    # Circle tests
    def test_create_circle_new(self):
        center_x, center_y, radius = 100, 100, 50
        # Directly test creating a new circle
        new_circle = self.canvas.create_circle(center_x, center_y, radius)
        self.assertIsNotNone(new_circle, "Failed to create a new circle.")
        self.assertIn(new_circle, self.canvas.get_drawables_by_class_name('Circle'), "New circle should be in canvas.")

    def test_get_circle(self):
        center_x, center_y, radius = 150, 150, 30
        # Create a circle for this test
        self.canvas.create_circle(center_x, center_y, radius)
        # Test retrieving an existing circle
        circle = self.canvas.get_circle(center_x, center_y, radius)
        self.assertIsNotNone(circle, "Circle should exist.")
        # Test retrieving a non-existent circle
        non_existent_circle = self.canvas.get_circle(200, 200, 30)
        self.assertIsNone(non_existent_circle, "Should not retrieve a non-existent circle.")

    def test_get_circle_by_name(self):
        center_x, center_y, radius = 120, 120, 25
        # Create a circle for this test
        self.canvas.create_circle(center_x, center_y, radius)
        # Test retrieving an existing circle by name
        circle = self.canvas.get_circle_by_name("A(25)")
        self.assertIsNotNone(circle, "Circle should exist.")
        # Test retrieving a non-existent circle by name
        non_existent_circle = self.canvas.get_circle_by_name("NonExistent")
        self.assertIsNone(non_existent_circle, "Should not retrieve a non-existent circle by name.")

    def test_create_circle_existing(self):
        center_x, center_y, radius = 130, 130, 40
        # Create a circle to test reusing existing circles
        created_circle = self.canvas.create_circle(center_x, center_y, radius)
        # Test creating a circle with the same parameters
        retrieved_circle = self.canvas.create_circle(center_x, center_y, radius)
        self.assertEqual(created_circle, retrieved_circle, "Should reuse the existing circle.")

    def test_delete_circle(self):
        center_x, center_y, radius = 140, 140, 35
        # Create a circle to test deletion
        circle = self.canvas.create_circle(center_x, center_y, radius)
        # Test deleting the circle
        self.canvas.delete_circle(circle.name)
        self.assertIsNone(self.canvas.get_circle(center_x, center_y, radius), "Circle should be deleted.")
        self.assertIsNone(self.canvas.get_circle_by_name('A(35)'), "Circle should be deleted.")

    def test_delete_circles_depending_on_point(self):
        center_x, center_y, radius = 130, 130, 40
        circle = self.canvas.create_circle(center_x, center_y, radius)
        self.assertIsNotNone(circle)
        self.assertIn(circle, self.canvas.get_drawables_by_class_name(circle.get_class_name()))
        self.canvas._delete_point_dependencies(center_x, center_y)
        self.assertNotIn(circle, self.canvas.get_drawables_by_class_name(circle.get_class_name()))

    # Ellipse tests
    def test_create_ellipse_new(self):
        center_x, center_y, radius_x, radius_y = 100, 100, 50, 30
        # Directly test creating a new ellipse
        new_ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(new_ellipse, "Failed to create a new ellipse.")
        self.assertIn(new_ellipse, self.canvas.get_drawables_by_class_name(new_ellipse.get_class_name()), "New ellipse should be in canvas.")

    def test_create_ellipse_existing(self):
        center_x, center_y, radius_x, radius_y = 130, 130, 40, 25
        # Create an ellipse to test reusing existing ellipses
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(ellipse, "Ellipse should exist.")
        # Test creating an ellipse with the same parameters
        retrieved_ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(retrieved_ellipse, "Ellipse should exist.")
        self.assertEqual(ellipse, retrieved_ellipse, "Should reuse the existing ellipse.")

    def test_get_ellipse(self):
        center_x, center_y, radius_x, radius_y = 150, 150, 30, 20
        # Create an ellipse for this test
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        # Test retrieving an existing ellipse
        retrieved_ellipse = self.canvas.get_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(ellipse, "Ellipse should exist.")
        self.assertIsNotNone(retrieved_ellipse, "Ellipse should exist.")
        self.assertEqual(ellipse, retrieved_ellipse, "Retrieved ellipse should be the same as the created one.")
        # Test retrieving a non-existent ellipse
        non_existent_ellipse = self.canvas.get_ellipse(200, 200, 30, 20)
        self.assertIsNone(non_existent_ellipse, "Should not retrieve a non-existent ellipse.")

    def test_get_ellipse_by_name(self):
        center_x, center_y, radius_x, radius_y = 120, 120, 25, 15
        # Create an ellipse for this test
        self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        # Test retrieving an existing ellipse by name
        ellipse = self.canvas.get_ellipse_by_name("A(25, 15)")
        self.assertIsNotNone(ellipse, "Ellipse should exist.")
        # Test retrieving a non-existent ellipse by name
        non_existent_ellipse = self.canvas.get_ellipse_by_name("B(50, 100)")
        self.assertIsNone(non_existent_ellipse, "Should not retrieve a non-existent ellipse by name.")

    def test_delete_ellipse(self):
        center_x, center_y, radius_x, radius_y = 140, 140, 35, 20
        # Create an ellipse to test deletion
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        # Test deleting the ellipse
        self.canvas.delete_ellipse("A(35, 20)")
        self.assertIsNone(self.canvas.get_ellipse(center_x, center_y, radius_x, radius_y), "Ellipse should be deleted.")
        self.assertIsNone(self.canvas.get_ellipse_by_name(ellipse.name), "Ellipse should be deleted.")

    def test_delete_ellipses_depending_on_point(self):
        center_x, center_y, radius_x, radius_y = 130, 130, 40, 20
        ellipse = self.canvas.create_ellipse(center_x, center_y, radius_x, radius_y)
        self.assertIsNotNone(ellipse)
        self.assertIn(ellipse, self.canvas.get_drawables_by_class_name(ellipse.get_class_name()))
        self.canvas._delete_point_dependencies(center_x, center_y)
        self.assertNotIn(ellipse, self.canvas.get_drawables_by_class_name(ellipse.get_class_name()))

    # Function tests
    def test_draw_function_new(self):
        function_string, name = "x^2", "Quadratic"
        left_bound, right_bound = -10, 10
        # Directly test drawing a new math function
        f = self.canvas.draw_function(function_string, name, left_bound, right_bound)
        self.assertIsNotNone(f, "Failed to draw a new math function.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "New function should be in canvas.")
        self.assertEqual(f.function_string, "x^2", "Function string should match.")
        self.assertEqual(f.left_bound, left_bound, "Left bound should match.")
        self.assertEqual(f.right_bound, right_bound, "Right bound should match.")
        self.assertEqual(f, f, "Retrieved function should be the same as the created one.")

    def test_draw_function_update(self):
        function_string, name = "x^2", "Quadratic"
        f = self.canvas.draw_function(function_string, name)
        # Update the function
        updated_function_string = "x^3"
        new_f = self.canvas.draw_function(updated_function_string, f.name, -5, 5)
        self.assertIsNotNone(new_f, "Math function should exist.")
        self.assertEqual(new_f.function_string, "x^3", "Function string should be updated.")
        self.assertEqual(new_f.left_bound, -5, "Left bound should be updated.")
        self.assertEqual(new_f.right_bound, 5, "Right bound should be updated.")

    def test_delete_math_function(self):
        function_string, name = "sin(x)", "SineWave"
        f = self.canvas.draw_function(function_string, name)
        # Ensure the function exists before deletion
        self.assertIsNotNone(f, "Math function should exist before deletion.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "Math function should exist before deletion.")
        # Test deleting the math function
        self.canvas.delete_function(f.name)
        deleted_function = self.canvas.get_function(f.name)
        self.assertIsNone(deleted_function, "Math function should be deleted.")

    def test_draw_invalid_function_name_error(self):
        function_string, name = "invalid_function", "Invalid"
        with self.assertRaises(NameError, msg="Should raise a NameError for an invalid function string."):
            f = self.canvas.draw_function(function_string, name)
            f.function(10)

    def test_draw_invalid_function_value_error(self):
        function_string, name = "x = 1", "Invalid"
        with self.assertRaises(ValueError, msg="Should raise a ValueError for an invalid function string."):
            f = self.canvas.draw_function(function_string, name)
            f.function(10)

    def test_draw_valid_identity_function(self):
        function_string, name = "x", "Identity"
        f = self.canvas.draw_function(function_string, name)
        self.assertIsNotNone(f, "Math function should exist.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "Math function should exist.")
        self.assertEqual(f.function(10), 10, "Function should return the input value.")

    def test_draw_function_default_bounds(self):
        function_string, name = "x^2 - 2*x + 1", "Parabola"
        # Test drawing a function without specifying bounds
        f = self.canvas.draw_function(function_string, name)
        self.assertIsNotNone(f, "Math function should be drawn.")
        self.assertIn(f, self.canvas.get_drawables_by_class_name(f.get_class_name()), "Function should be in canvas.")
        self.assertIsNone(f.left_bound, "Left bound should be None for default bounds.")
        self.assertIsNone(f.right_bound, "Right bound should be None for default bounds.")

    # Other canvas tests
    def test_find_segment_children(self):
        s1 = self.canvas.create_segment(0, 0, 10, 0, name="", extra_graphics=False)
        s2 = self.canvas.create_segment(10, 0, 20, 0, name="", extra_graphics=False)
        s3 = self.canvas.create_segment(0, 0, 20, 0, name="", extra_graphics=False)
        s3_children = self.canvas._find_segment_children(s3)
        self.assertIn(s1, s3_children, "Segment s1 should be a child of s3.")
        self.assertIn(s2, s3_children, "Segment s2 should be a child of s3.")
        self.assertNotIn(s3, s3_children, "Segment s3 should not be a child of itself.")
        self.assertEquals(len(s3_children), 2, "Segment s3 should have 2 children.")
    
    def test_get_segment_parents(self):
        segment = self.canvas.create_segment(0, 0, 30, 0)
        self.canvas.create_point(10, 0)
        self.assertEqual(len(segment.children), 2, "Segment should have 2 children.")
        children = list(segment.children)
        parent1 = self.canvas._get_segment_parents(children[0])
        parent2 = self.canvas._get_segment_parents(children[1])
        self.assertEquals(parent1, parent2, "Parent should be the same.")

    def test_add_segment_to_parents(self):
        ab = self.canvas.create_segment(0, 0, 30, 0, name="AB", extra_graphics=True)
        cd = self.canvas.create_segment(40, 0, 60, 0, name="CD", extra_graphics=True)
        ef = self.canvas.create_segment(70, 0, 90, 0, name="EF", extra_graphics=True)
        ab.children.add(cd)
        cd.children.add(ef)
        self.canvas._add_segment_to_parents(ef)
        ef_parents = self.canvas._get_segment_parents(ef)
        self.assertIn(ab, ef_parents, "Segment AD should be in AB parents.")
        self.assertIn(cd, ef_parents, "Segment AC should be in AB parents.")

    def test_split_segment(self):
        segment = self.canvas.create_segment(0, 0, 30, 0)
        self.canvas._split_segments_with_point(20, 0)
        self.assertIsNotNone(segment)
        self.assertTrue(len(segment.children) == 2, "Segment should have 2 children.")
        self.assertTrue(len(self.canvas.get_drawables_by_class_name("Point")) == 3, "Canvas should have 3 points.")
        self.assertTrue(len(self.canvas.get_drawables_by_class_name(segment.get_class_name())) == 3, "Canvas should have 3 segments.")

    def test_translate_point(self):
        # Test translating a point
        point = self.canvas.create_point(10, 10, "A")
        self.canvas.translate_object("A", 5, -5)
        
        # Check new position
        self.assertEqual(point.original_position.x, 15)
        self.assertEqual(point.original_position.y, 5)

    def test_translate_segment(self):
        # Test translating a segment
        segment = self.canvas.create_segment(0, 0, 10, 10)
        original_p1_x = segment.point1.original_position.x
        original_p1_y = segment.point1.original_position.y
        original_p2_x = segment.point2.original_position.x
        original_p2_y = segment.point2.original_position.y
        
        self.canvas.translate_object(segment.name, 5, 5)
        
        # Check both points were translated
        self.assertEqual(segment.point1.original_position.x, original_p1_x + 5)
        self.assertEqual(segment.point1.original_position.y, original_p1_y + 5)
        self.assertEqual(segment.point2.original_position.x, original_p2_x + 5)
        self.assertEqual(segment.point2.original_position.y, original_p2_y + 5)

    def test_translate_vector(self):
        # Test translating a vector
        vector = self.canvas.create_vector(0, 0, 10, 10, "V", True)
        
        original_p1_x = vector.segment.point1.original_position.x
        original_p1_y = vector.segment.point1.original_position.y
        original_p2_x = vector.segment.point2.original_position.x
        original_p2_y = vector.segment.point2.original_position.y
        
        self.canvas.translate_object(vector.name, 5, 5)
        
        # Check both points were translated
        self.assertEqual(vector.segment.point1.original_position.x, original_p1_x + 5)
        self.assertEqual(vector.segment.point1.original_position.y, original_p1_y + 5)
        self.assertEqual(vector.segment.point2.original_position.x, original_p2_x + 5)
        self.assertEqual(vector.segment.point2.original_position.y, original_p2_y + 5)

    def test_translate_circle(self):
        # Test translating a circle
        circle = self.canvas.create_circle(100, 100, 50)
        original_center_x = circle.center.original_position.x
        original_center_y = circle.center.original_position.y
        
        self.canvas.translate_object(circle.name, -10, 20)
        
        # Check center was translated
        self.assertEqual(circle.center.original_position.x, original_center_x - 10)
        self.assertEqual(circle.center.original_position.y, original_center_y + 20)

    def test_translate_nonexistent_object(self):
        # Test attempting to translate an object that doesn't exist
        with self.assertRaises(ValueError):
            self.canvas.translate_object("NonexistentObject", 10, 10)

    def test_translate_multiple_objects(self):
        # Test translating multiple objects and checking their relative positions
        p1 = self.canvas.create_point(0, 0, name="A")
        p2 = self.canvas.create_point(10, 10, name="B")
        segment = self.canvas.create_segment(0, 0, 10, 10, name="AB")

        # Store original distances
        original_dx = p2.original_position.x - p1.original_position.x
        original_dy = p2.original_position.y - p1.original_position.y
        
        # Translate each object
        self.canvas.translate_object("A", 5, 5)
        self.canvas.translate_object("B", 5, 5)
        self.canvas.translate_object(segment.name, 5, 5)
        
        # Check relative distances are maintained
        new_dx = p2.original_position.x - p1.original_position.x
        new_dy = p2.original_position.y - p1.original_position.y
        
        self.assertEqual(original_dx, new_dx)
        self.assertEqual(original_dy, new_dy)

    def test_translate_with_zero_offset(self):
        # Test translating with zero offset doesn't change position
        point = self.canvas.create_point(10, 10, "C")
        original_x = point.original_position.x
        original_y = point.original_position.y
        
        self.canvas.translate_object("C", 0, 0)
        
        self.assertEqual(point.original_position.x, original_x)
        self.assertEqual(point.original_position.y, original_y)

    def test_translate_undo_redo(self):
        # Test that translation can be undone and redone
        point = self.canvas.create_point(10, 10, "A")
        original_x = point.original_position.x
        original_y = point.original_position.y
        
        # Perform translation
        self.canvas.translate_object("A", 5, 5)
        point = self.canvas.get_point_by_name("A")  # Get fresh reference
        translated_x = point.original_position.x
        translated_y = point.original_position.y
        
        # Undo translation
        self.canvas.undo()
        point = self.canvas.get_point_by_name("A")  # Get fresh reference
        self.assertEqual(point.original_position.x, original_x)
        self.assertEqual(point.original_position.y, original_y)
        
        # Redo translation
        self.canvas.redo()
        point = self.canvas.get_point_by_name("A")  # Get fresh reference
        self.assertEqual(point.original_position.x, translated_x)
        self.assertEqual(point.original_position.y, translated_y)

    def test_translate_triangle(self):
        # Test translating a triangle
        triangle = self.canvas.create_triangle(0, 0, 10, 0, 5, 10)
        
        # Get original positions of all points from the segments
        original_points = [
            (triangle.segment1.point1.original_position.x, triangle.segment1.point1.original_position.y),
            (triangle.segment1.point2.original_position.x, triangle.segment1.point2.original_position.y),
            (triangle.segment2.point2.original_position.x, triangle.segment2.point2.original_position.y)
        ]
        
        self.canvas.translate_object(triangle.name, 5, 5)
        
        # Check all points were translated
        points = [
            triangle.segment1.point1,
            triangle.segment1.point2,
            triangle.segment2.point2
        ]
        
        for i, point in enumerate(points):
            self.assertEqual(point.original_position.x, original_points[i][0] + 5)
            self.assertEqual(point.original_position.y, original_points[i][1] + 5)

    def test_translate_function(self):
        # Test that translating a function has no effect (functions are relative to cartesian system)
        function = self.canvas.draw_function("x^2", "f")
        original_string = function.function_string
        
        self.canvas.translate_object("f", 5, 5)
        
        # Function should remain unchanged
        self.assertEqual(function.function_string, original_string)

