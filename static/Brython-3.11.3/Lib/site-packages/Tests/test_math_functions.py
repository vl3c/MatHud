import unittest
import json
from math_util import MathUtil
from geometry import Position
from .simple_mock import SimpleMock


class TestMathFunctions(unittest.TestCase):
    def setUp(self):
        # Mock points for use in some tests
        self.point1 = SimpleMock(original_position=SimpleMock(x=0, y=0), name='A')
        self.point2 = SimpleMock(original_position=SimpleMock(x=1, y=1), name='B')
        # Mock segment using mocked points
        self.segment = SimpleMock(point1=self.point1, point2=self.point2)
    
    def test_format_number_for_cartesian(self):
        test_cases = [
            (123456789, 6, '1.2e+8'),
            (0.000123456789, 6, '0.00012'),
            (123456, 6, '123456'),
            (123.456, 6, '123.456'),
            (0, 6, '0'),
            (-123456789, 6, '-1.2e+8'),
            (-0.000123456789, 6, '-0.00012'),
            (-123456, 6, '-123456'),
            (-123.456, 6, '-123.456'),
            (1.23456789, 6, '1.23457'),
            (0.000000123456789, 6, '1.2e-7'),
            (123456.789, 6, '123457'),
            (123.456789, 6, '123.457'),
            (0.00000000000001, 6, '1e-14'),
            (-1.23456789, 6, '-1.23457'),
            (-0.000000123456789, 6, '-1.2e-7'),
            (-123456.789, 6, '-123457'),
            (-123.456789, 6, '-123.457'),
            (-0.00000000000001, 6, '-1e-14'),
            (123456789, 3, '1.2e+8'),
            (0.000123456789, 3, '1.2e-4'),
            (123456, 3, '1.2e+5'),
            (123.456, 3, '123'),
            (1.23456789, 3, '1.23'),
            (0.000000123456789, 3, '1.2e-7'),
            (123456.789, 3, '1.2e+5'),
            (123.456789, 3, '123'),
            (0.00000000000001, 3, '1e-14'),
        ]
        for i, (input, max_digits, expected) in enumerate(test_cases):
            with self.subTest(i=i):
                self.assertEqual(MathUtil.format_number_for_cartesian(input, max_digits=max_digits), expected)

    def test_point_matches_coordinates(self):
        self.assertTrue(MathUtil.point_matches_coordinates(self.point1, 0, 0))
        self.assertFalse(MathUtil.point_matches_coordinates(self.point1, 1, 1))

    def test_segment_matches_coordinates(self):
        self.assertTrue(MathUtil.segment_matches_coordinates(self.segment, 0, 0, 1, 1))
        self.assertTrue(MathUtil.segment_matches_coordinates(self.segment, 1, 1, 0, 0))  # Reverse order
        self.assertFalse(MathUtil.segment_matches_coordinates(self.segment, 2, 2, 3, 3))  # Incorrect coordinates

    def test_segment_matches_point_names(self):
        self.assertTrue(MathUtil.segment_matches_point_names(self.segment, 'A', 'B'))
        self.assertTrue(MathUtil.segment_matches_point_names(self.segment, 'B', 'A'))  # Reverse order
        self.assertFalse(MathUtil.segment_matches_point_names(self.segment, 'C', 'D'))  # Incorrect names

    def test_segment_has_end_point(self):
        self.assertTrue(MathUtil.segment_has_end_point(self.segment, 0, 0))
        self.assertTrue(MathUtil.segment_has_end_point(self.segment, 1, 1))
        self.assertFalse(MathUtil.segment_has_end_point(self.segment, 2, 2))  # Point not in segment

    def test_get_2D_distance(self):
        p1 = Position(0, 0)
        p2 = Position(3, 4)
        self.assertEqual(MathUtil.get_2D_distance(p1, p2), 5)

    def test_get_2D_midpoint(self):
        p1 = Position(0, 0)
        p2 = Position(2, 2)
        x, y = MathUtil.get_2D_midpoint(p1, p2)
        self.assertEqual(x, 1)
        self.assertEqual(y, 1)

    def test_is_point_on_segment(self):
        self.assertTrue(MathUtil.is_point_on_segment(1, 1, 0, 0, 2, 2))
        self.assertTrue(MathUtil.is_point_on_segment(1, 1, 2, 2, 0, 0))
        self.assertTrue(MathUtil.is_point_on_segment(0, 0, 0, 0, 2, 2))
        self.assertTrue(MathUtil.is_point_on_segment(2, 2, 0, 0, 2, 2))
        self.assertFalse(MathUtil.is_point_on_segment(3, 3, 0, 0, 2, 2))

    def test_get_triangle_area(self):
        p1 = Position(0, 0)
        p2 = Position(1, 0)
        p3 = Position(0, 1)
        self.assertAlmostEqual(MathUtil.get_triangle_area(p1, p2, p3), 0.5)

    def test_get_rectangle_area(self):
        p1 = Position(0, 0)
        p2 = Position(2, 3)
        self.assertEqual(MathUtil.get_rectangle_area(p1, p2), 6)

    def test_cross_product(self):
        self.assertEqual(MathUtil.cross_product(Position(0, 0), Position(1, 0), Position(0, 1)), 1)       # "Perpendicular vectors"
        self.assertEqual(MathUtil.cross_product(Position(0, 0), Position(1, 1), Position(1, 1)), 0)       # "Zero vector test"
        self.assertEqual(MathUtil.cross_product(Position(1, 2), Position(-1, -1), Position(2, -3)), 13)   # "Negative values test"
        self.assertEqual(MathUtil.cross_product(Position(0, 0), Position(1, 0), Position(2, 0)), 0)       # "Collinear vectors"

    def test_dot_product(self):
        self.assertEqual(MathUtil.dot_product(Position(0, 0), Position(1, 0), Position(1, 0)), 1)      # "Parallel vectors"
        self.assertEqual(MathUtil.dot_product(Position(0, 0), Position(0, 0), Position(0, 1)), 0)      # "Zero vector test"
        self.assertEqual(MathUtil.dot_product(Position(1, 2), Position(-1, -1), Position(2, -3)), 13)  # "Negative values test"
        self.assertEqual(MathUtil.dot_product(Position(0, 0), Position(1, 0), Position(0, 1)), 0)      # "Perpendicular vectors"

    def test_is_right_angle(self):
        self.assertEqual(MathUtil.is_right_angle(Position(0, 0), Position(1, 0), Position(0, 1)), True)   # "Right angle"
        self.assertEqual(MathUtil.is_right_angle(Position(0, 0), Position(1, 1), Position(1, 0)), False)  # "Not right angle"
        self.assertEqual(MathUtil.is_right_angle(Position(0, 0), Position(1, 0), Position(1, 1)), False)  # "Almost right angle but not quite"

    def test_validate_rectangle(self):
        # square
        self.assertTrue(MathUtil.is_rectangle(0, 0, 1, 0, 1, 1, 0, 1))
        self.assertTrue(MathUtil.is_rectangle(0, 0, 0, 1, 1, 1, 1, 0))
        # rectangle
        self.assertTrue(MathUtil.is_rectangle(0, 0, 2, 0, 2, 1, 0, 1))
        self.assertTrue(MathUtil.is_rectangle(0, 0, 0, 1, 2, 1, 2, 0))
        # square skewed by 45 degrees
        self.assertTrue(MathUtil.is_rectangle(0, 1, 1, 0, 2, 1, 1, 2))
        self.assertTrue(MathUtil.is_rectangle(0, 1, 1, 2, 2, 1, 1, 0))
        # rectangle skewed by 45 degrees
        self.assertTrue(MathUtil.is_rectangle(0, 2, 2, 0, 3, 1, 1, 3))
        self.assertTrue(MathUtil.is_rectangle(0, 2, 1, 3, 3, 1, 2, 0))
        # Invalid rectangles
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 0, 1, 1, 2))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 1, 2, 0, 1, 2, 0))
        # Invalid cases with repeating points
        self.assertFalse(MathUtil.is_rectangle(0, 0, 0, 0, 2, 1, 0, 1))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 2, 0, 0, 1))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 2, 1, 2, 1))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 0, 0, 0, 0, 0, 0))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 2, 0, 0, 0, 2, 0))
        self.assertFalse(MathUtil.is_rectangle(0, 0, 0, 0, 2, 0, 2, 0))
        self.assertFalse(MathUtil.is_rectangle(2, 0, 2, 0, 0, 0, 0, 0))

    def test_segments_intersect(self):
        self.assertTrue(MathUtil.segments_intersect(0, 0, 10, 10, 0, 10, 10, 0))
        self.assertFalse(MathUtil.segments_intersect(0, 0, 10, 10, 20, 20, 30, 30))
        self.assertTrue(MathUtil.segments_intersect(0, 0, 10, 10, 0, 0, 10, 10))
        self.assertTrue(MathUtil.segments_intersect(0, 0, 10, 10, 0, 0, 5, 5))

    def test_get_segments_intersection(self):
        x_intersection, y_intersection = MathUtil.get_segments_intersection(0, 0, 1, 1, 0, 1, 1, 0)
        self.assertAlmostEqual(x_intersection, 0.5, places=7)
        self.assertAlmostEqual(y_intersection, 0.5, places=7)

    def test_get_segments_intersection_parallel(self):
        # Define two parallel segments
        result = MathUtil.get_segments_intersection(0, 0, 1, 1, 2, 2, 3, 3)
        # Since the segments are parallel, the result should be None
        self.assertIsNone(result, "Expected None for parallel segments")

    def test_get_line_formula(self):
        self.assertEqual(MathUtil.get_line_formula(0, 0, 1, 1), "y = 1.0 * x + 0.0")
        self.assertEqual(MathUtil.get_line_formula(0, 0, 0, 1), "x = 0")

    def test_get_circle_formula(self):
        self.assertEqual(MathUtil.get_circle_formula(0, 0, 1), "(x - 0)**2 + (y - 0)**2 = 1**2")

    def test_get_ellipse_formula(self):
        self.assertEqual(MathUtil.get_ellipse_formula(0, 0, 1, 2), "((x - 0)**2)/1**2 + ((y - 0)**2)/2**2 = 1")

    def test_sqrt(self):
        result = MathUtil.sqrt(-4)
        self.assertEqual(result, "2i")
        result = MathUtil.sqrt(4)
        self.assertEqual(int(result), 2)

    def test_pow(self):
        result = MathUtil.pow(2, 3)
        self.assertEqual(int(result), 8)
        matrix = [[-1, 2], [3, 1]]
        result = MathUtil.pow(matrix, 2)
        self.assertEqual(result, "[[7, 0], [0, 7]]")

    def test_evaluate_conversion(self):
        result = MathUtil.convert(12.7, "cm", "inch")
        self.assertEqual(result, "5 inch")

    def test_evaluate_addition(self):
        result = MathUtil.evaluate("7 + 3")
        self.assertEqual(int(result), 10)

    def test_evaluate_division(self):
        result = MathUtil.evaluate("12 / (2.3 + 0.7)")
        self.assertEqual(int(result), 4)

    def test_evaluate_sin(self):
        result = MathUtil.evaluate("sin(45 deg) ^ 2")
        print(f"sin(45 deg) ^ 2 = {result}")
        self.assertAlmostEqual(float(result), 0.5, places=9)

    def test_evaluate_js_power_symbol(self):
        result = MathUtil.evaluate("9^2 / 3")
        self.assertEqual(int(result), 27)

    def test_evaluate_py_power_symbol(self):
        result = MathUtil.evaluate("9**2 / 3")
        self.assertEqual(int(result), 27)

    def test_evaluate_complex(self):
        result = MathUtil.evaluate("1 + 2i + 1j")
        self.assertEqual(result, "1 + 3i")

    def test_evaluate_det(self):
        matrix = [[-1, 2], [3, 1]]
        result = MathUtil.det(matrix)
        self.assertEqual(int(result), -7)

    def test_random(self):
        result = MathUtil.random()
        self.assertTrue(0 <= result <= 1)

    def test_round(self):
        result = MathUtil.round(1.2345, 2)
        self.assertEqual(result, 1.23)

    def test_gcd(self):
        result = MathUtil.gcd(48, 18)
        self.assertEqual(result, 6)

    def test_lcm(self):
        result = MathUtil.lcm(4, 5)
        self.assertEqual(result, 20)

    def test_mean(self):
        result = MathUtil.mean([1, 2, 3, 4, 5])
        self.assertEqual(result, 3)

    def test_median(self):
        result = MathUtil.median([1, 2, 3, 4, 5])
        self.assertEqual(result, 3)

    def test_mode(self):
        result = MathUtil.mode([1, 2, 2, 3])
        self.assertEqual(result, 2)

    def test_stdev(self):
        result = MathUtil.stdev([2, 4, 6, 8, 10])
        self.assertAlmostEqual(result, 3.1623, places=4)

    def test_variance(self):
        result = MathUtil.variance([2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5])
        self.assertAlmostEqual(result, 1.372, places=3)

    def test_limit(self):
        result = MathUtil.limit('sin(x) / x', 'x', 0)
        result = float(result)  # convert result to float
        self.assertEqual(result, 1.0)

    def test_derivative(self):
        result = MathUtil.derivative('x^2', 'x')
        self.assertEqual(result, "2*x")

    def test_integral_indefinite(self):
        result = MathUtil.integral('x^2', 'x')
        result = MathUtil.simplify(result)  # simplify the result
        self.assertEqual(result, "0.3333333333333333*x^3")

    def test_integral(self):
        result = MathUtil.integral('x^2', 'x', 0, 1)
        result = float(result)  # convert result to float
        self.assertAlmostEqual(result, 0.333, places=3)

    def test_simplify(self):
        result = MathUtil.simplify('x^2 + 2*x + 1')
        self.assertEqual(result, "(1+x)^2")

    def test_expand(self):
        result = MathUtil.expand('(x + 1)^2')
        self.assertEqual(result, "1+2*x+x^2")

    def test_factor(self):
        result = MathUtil.factor('x^2 - 1')
        self.assertEqual(result, "(-1+x)*(1+x)")

    def test_get_equation_type_with_linear_equation(self):
        equation = "x + 2"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Linear")

    def test_get_equation_type_with_quadratic_equation(self):
        equation = "x^2 + 2*x + 1"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Quadratic")  # Adjusted to expect "Quadratic"

    def test_get_equation_type_with_cubic_equation(self):
        equation = "x^3 + 3*x^2 + 3*x + 1"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Cubic")  # Testing for cubic equation

    def test_get_equation_type_with_quartic_equation(self):
        equation = "x^4 + 4*x^3 + 6*x^2 + 4*x + 1"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Quartic")  # Testing for quartic equation

    def test_get_equation_type_with_higher_order_equation(self):
        equation = "x^5 + 5*x^4 + 10*x^3 + 10*x^2 + 5*x + 1"
        result = MathUtil.get_equation_type(equation)
        self.assertTrue("Order" in result)  # Testing for higher order equation, expecting "Order 5"

    def test_get_equation_type_with_trigonometric_equation1(self):
        equation = "sin(x) + 2"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Trigonometric")
    
    def test_get_equation_type_with_trigonometric_equation2(self):
        equation = "cos(x + 3) - 2"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Trigonometric")

    def test_get_equation_type_with_trigonometric_equation3(self):
        equation = "tan(x * sin(24)) = 2"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Trigonometric")

    def test_get_equation_type_with_non_linear_due_to_variable_multiplication1(self):
        equation = "x*y + 2"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Other Non-linear")  # Adjusted to expect "Other Non-linear"

    def test_get_equation_type_with_non_linear_due_to_variable_multiplication2(self):
        equation = "xy - 5"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Other Non-linear")  # Adjusted to expect "Other Non-linear"

    def test_get_equation_type_with_linear_after_expansion(self):
        equation = "(x + 1)^2"
        expanded = MathUtil.expand(equation)  # Assuming this correctly expands to "x^2 + 2*x + 1"
        result = MathUtil.get_equation_type(expanded)
        self.assertEqual(result, "Quadratic")  # Adjusted to expect "Quadratic"

    def test_get_equation_type_with_implicit_multiplication_not_detected_as_non_linear(self):
        equation = "2x + 3"
        result = MathUtil.get_equation_type(equation)
        self.assertEqual(result, "Linear")  # Assuming implicit multiplication by constants is handled as linear

    def test_determine_max_number_of_solutions_linear_and_linear(self):
        equations = ["2x + 3 = y", "5x - 2 = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 1, "Linear and linear should have exactly 1 solution.")
    
    def test_determine_max_number_of_solutions_linear_and_quadratic(self):
        equations = ["x + 2 = y", "x^2 - 4x + 3 = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 2, "Linear and quadratic should have at most 2 solutions.")
    
    def test_determine_max_number_of_solutions_linear_and_cubic(self):
        equations = ["3x + 1 = y", "x^3 - 6x^2 + 11x - 6 = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 3, "Linear and cubic should intersect in at most 3 points.")
    
    def test_determine_max_number_of_solutions_quadratic_and_quartic(self):
        equations = ["x^2 + x - 2 = y", "x^4 - 5x^2 + 4 = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 8, "Quadratic and quartic should intersect in at most 8 points.")
    
    def test_determine_max_number_of_solutions_cubic_and_quartic_with_higher_order_count(self):
        equations = ["x^3 + x - 4 = y", "x^5 - x^4 + x^3 - x^2 + x - 1 = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 15, "Cubic and quintic equations can theoretically intersect in at most 15 points.")
    
    def test_determine_max_number_of_solutions_single_equation(self):
        equations = ["x^2 + 4x + 4 = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 0, "Single equation should not determine a solution count between equations.")
    
    def test_determine_max_number_of_solutions_no_equations(self):
        equations = []
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 0, "No equations should not determine a solution count.")

    def test_determine_max_number_of_solutions_trigonometric(self):
        equations = ["sin(x) = y", "cos(x) = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 0, "Trigonometric combinations should indicate complex or uncertain scenarios.")

    def test_determine_max_number_of_solutions_other_non_linear(self):
        equations = ["x*y - 2 = 0", "x^2 + y = 4"]  # Changed second equation to avoid using xy term twice
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 0, "Other non-linear equations should indicate complex or uncertain scenarios.")

    def test_solve1(self):
        result = MathUtil.solve('x^2 - 4', 'x')
        result = json.loads(result)  # parse result from JSON string to list
        result = [float(r) for r in result]  # convert results to floats
        self.assertEqual(result, [2.0, -2.0])

    def test_solve2(self):
        result = MathUtil.solve('0.4 * x + 37.2 = -0.9 * x - 8', 'x')
        result = json.loads(result)  # Parse result from JSON string to list
        # Assuming the result is always a list with a single item for this test case
        solution = float(result[0])  # Convert the first (and only) result to float
        self.assertAlmostEqual(solution, -34.7692307692308, places=5)

    def test_solve_linear_quadratic_invalid_input(self):
        equations = ["y = 2*x + 3"]  # Not enough equations
        with self.assertRaises(ValueError):
            MathUtil.solve_linear_quadratic_system(equations)

    def test_solve_linear_quadratic_no_real_solution(self):
        equations = ["y = 2*x + 3", "y = x^2 + 4*x + 5"]
        with self.assertRaises(ValueError):
            MathUtil.solve_linear_quadratic_system(equations)

    def test_solve_linear_quadratic_returns_string(self):
        equations = ["2x + 3 = y", "x^2 + 4x + 3 = y"]
        result = MathUtil.solve_linear_quadratic_system(equations)
        self.assertTrue(isinstance(result, str))  # Check if the result is correctly formatted as a string

    def test_solve_linear_quadratic_one_real_solution(self):
        equations = ["y = 2x - 1", "y = x^2"]
        result = MathUtil.solve_linear_quadratic_system(equations)
        result = dict(item.split(" = ") for item in result.split(", "))  # parse result from string to dictionary
        result = {k: float(v) for k, v in result.items()}  # convert results to floats
        self.assertEqual(result, {"x": 1.0, "y": 1.0})

    def test_solve_linear_quadratic_two_real_solutions(self):
        equations = ["y = x + 1", "y = x^2 + 2x + 1"]
        result = MathUtil.solve_linear_quadratic_system(equations)
        result = dict(item.split(" = ") for item in result.split(", "))  # parse result from string to dictionary
        result = {k: float(v) for k, v in result.items()}  # convert results to floats
        self.assertEqual(result, {"x1": 0.0, "y1": 1.0, "x2": -1.0, "y2": 0.0})

    def test_solve_system_of_equations_linear(self):
        result = MathUtil.solve_system_of_equations(['x + y = 4', 'x - y = 2'])
        result = dict(item.split(" = ") for item in result.split(", "))  # parse result from string to dictionary
        result = {k: float(v) for k, v in result.items()}  # convert results to floats
        self.assertEqual(result, {"x": 3.0, "y": 1.0})

    def test_solve_system_of_equations_quadratic_linear(self):
        result = MathUtil.solve_system_of_equations(['x^2 = y', '-x + 2 = y'])
        result = dict(item.split(" = ") for item in result.split(", "))  # parse result from string to dictionary
        result = {k: float(v) for k, v in result.items()}  # convert results to floats
        self.assertEqual(result, {"x1": 1.0, "y1": 1.0, "x2": -2.0, "y2": 4.0})

    def test_determine_max_number_of_solutions_cubic_and_quintic(self):
        equations = ["x^3 + x - 4 = y", "x^5 - x^4 + x^3 - x^2 + x - 1 = y"]
        result = MathUtil.determine_max_number_of_solutions(equations)
        self.assertEqual(result, 15, "Cubic and quintic equations can theoretically intersect in at most 15 points.")

    def test_solve_system_of_equations_with_high_order(self):
        equations = ["x^3 + x - 4 = y", "x^5 - x^4 + x^3 - x^2 + x - 1 = y"]
        result = MathUtil.solve_system_of_equations(equations)
        result = dict(item.split(" = ") for item in result.split(", "))  # parse result from string to dictionary
        result = {k: float(v) for k, v in result.items()}  # convert results to floats
        self.assertEqual(result, {"x": -1.0, "y": -6.0})
