import unittest
from canvas import Canvas
from process_function_calls import ProcessFunctionCalls
from point import Position
from .simple_mock import SimpleMock


class TestProcessFunctionCalls(unittest.TestCase):
    def setUp(self):
        # Setup the mock canvas and its functions as described
        self.canvas = Canvas(500, 500, draw_enabled=False)  # Assuming a basic mock or actual Canvas class
        self.mock_cartesian2axis = SimpleMock(draw=SimpleMock(return_value=None), 
                                              reset=SimpleMock(return_value=None),
                                              get_state=SimpleMock(return_value={'Cartesian_System_Visibility': 'cartesian_state'}),
                                              origin=Position(0, 0))  # Assuming Position is defined elsewhere
        self.canvas.cartesian2axis = self.mock_cartesian2axis
        
        # Mocking a function in canvas.drawables['Function']
        self.function_string, self.name = "x^2", "Quadratic"
        # Assuming draw_function method is available to add mock functions
        self.f = self.canvas.draw_function(self.function_string, self.name)

    def test_evaluate_numeric_expression(self):
        expression = "3 + 7"
        result = ProcessFunctionCalls.evaluate_expression(expression, variables=None, canvas=self.canvas)
        self.assertEqual(result, 10)

    def test_evaluate_expression_with_variables(self):
        expression = "x - 4 + y * 5"
        variables = {'x': 7, 'y': 65}
        result = ProcessFunctionCalls.evaluate_expression(expression, variables=variables, canvas=self.canvas)
        self.assertEqual(result, 328)  # Expected result for "x - 4 + y * 5" with x = 7 and y = 65

    def test_evaluate_function_expression(self):
        expression = "Quadratic(5)"
        result = ProcessFunctionCalls.evaluate_expression(expression, variables=None, canvas=self.canvas)
        self.assertEqual(result, 25)  # Expected result for "Quadratic(5)"

    def test_get_results1(self):
        available_functions = {'evaluate_expression': ProcessFunctionCalls.evaluate_expression}
        calls = [{'function_name': 'evaluate_expression', 'arguments': {'expression': 'Quadratic(5)', 'canvas': self.canvas}}]
        undoable_functions = ()  # Example, assuming no undoable functions for simplicity
        results, _ = ProcessFunctionCalls.get_results(calls, available_functions, undoable_functions, self.canvas)
        self.assertTrue(len(results) > 0)
        self.assertIn('Quadratic(5)', results) # Check if the result for "Quadratic(5)" is available
        self.assertEqual(results['Quadratic(5)'], 25)  # Expected result for "Quadratic(5)"

    def test_get_results2(self):
        available_functions = {'evaluate_expression': ProcessFunctionCalls.evaluate_expression}
        calls = [{'function_name': 'evaluate_expression', 'arguments': {'expression': 'x + y', 'variables': {'x': 5, 'y': 1}, 'canvas': self.canvas}}]
        undoable_functions = ()  # Example, assuming no undoable functions for simplicity
        results, _ = ProcessFunctionCalls.get_results(calls, available_functions, undoable_functions, self.canvas)
        self.assertTrue(len(results) > 0)
        self.assertIn('x+y for x:5, y:1', results)
        self.assertEqual(results['x+y for x:5, y:1'], 6)

    def test_evaluate_expression_invalid_function(self):
        # Testing with an invalid function expression
        expression = "NonExistentFunction(10)"
        result = ProcessFunctionCalls.evaluate_expression(expression, variables=None, canvas=self.canvas)
        self.assertTrue("Sorry" in result)

    def test_validate_results_with_valid_input(self):
        # Testing result validation with valid types as dictionary values
        results = {"result1": 1, "result2": "a", "result3": True, "result4": 3.14}
        self.assertTrue(ProcessFunctionCalls.validate_results(results))

    def test_validate_results_with_invalid_input1(self):
        # Testing result validation with an invalid type (list) as one of the dictionary values
        results = {"result1": 1, "result2": "a", "result3": [1, 2, 3], "result4": True}
        self.assertFalse(ProcessFunctionCalls.validate_results(results))

    def test_validate_results_with_invalid_input2(self):
        # Testing result validation with an invalid type (None) as one of the dictionary values
        results = {"result1": 1, "result2": "a", "result3": None, "result4": True}
        self.assertFalse(ProcessFunctionCalls.validate_results(results))

    def test_validate_results_with_empty_string_key(self):
        # Testing result validation with an empty string as a key
        results = {"": 1, "result2": "a", "result3": True, "result4": 3.14}
        self.assertFalse(ProcessFunctionCalls.validate_results(results))

    def test_validate_results_with_none_key(self):
        # Testing result validation with None as a key
        results = {None: 1, "result2": "a", "result3": True, "result4": 3.14}
        self.assertFalse(ProcessFunctionCalls.validate_results(results))

    def test_validate_results_with_all_valid_keys_and_values(self):
        # Testing result validation with all valid keys and values
        results = {"result1": 1, "result2": "a", "result3": True, "result4": 3.14}
        self.assertTrue(ProcessFunctionCalls.validate_results(results))

    def test_validate_results_with_empty_dict(self):
        # Testing result validation with an empty dictionary
        results = {}
        self.assertTrue(ProcessFunctionCalls.validate_results(results))
