import copy

class UndoRedoManager:
    """
    Manages undo and redo operations for a Canvas object.
    
    This class is responsible for:
    - Archiving canvas states (for undo operations)
    - Handling undo operations (restore previous state)
    - Handling redo operations (restore undone state)
    """
    
    def __init__(self, canvas):
        """
        Initialize the UndoRedoManager.
        
        Args:
            canvas: The Canvas object this manager is responsible for
        """
        self.canvas = canvas
        self.undo_stack = []
        self.redo_stack = []
    
    def archive(self):
        """
        Archives the current state of the canvas for undo operations.
        
        This method should be called whenever a change is made to the canvas
        that should be undoable.
        """
        archived_state = {
            'drawables': copy.deepcopy(self.canvas.drawable_manager.drawables._drawables),
            'computations': copy.deepcopy(self.canvas.computations)
        }
        self.undo_stack.append(archived_state)
        # Clear the redo stack when a new state is archived
        self.redo_stack = []
        
    def undo(self):
        """
        Restores the last archived state from the undo stack.
        
        Returns:
            bool: True if an undo was performed, False otherwise
        """
        if not self.undo_stack:
            return False
            
        # Get the last archived state
        last_state = self.undo_stack.pop()
        
        # Archive current state for redo
        current_state = {
            'drawables': copy.deepcopy(self.canvas.drawable_manager.drawables._drawables),
            'computations': copy.deepcopy(self.canvas.computations)
        }
        self.redo_stack.append(current_state)
        
        # Restore only the drawables from the last state
        self.canvas.drawable_manager.drawables._drawables = copy.deepcopy(last_state['drawables'])
        
        # Ensure all objects are properly initialized
        self._fix_drawable_canvas_references()
        
        # Make sure to reset any cached or derived values
        # This ensures a complete state reset
        self.canvas.draw()
        
        return True
    
    def redo(self):
        """
        Restores the last undone state from the redo stack.
        
        Returns:
            bool: True if a redo was performed, False otherwise
        """
        if not self.redo_stack:
            return False
            
        # Get the last undone state
        next_state = self.redo_stack.pop()
        
        # Archive current state for undo
        current_state = {
            'drawables': copy.deepcopy(self.canvas.drawable_manager.drawables._drawables),
            'computations': copy.deepcopy(self.canvas.computations)
        }
        self.undo_stack.append(current_state)
        
        # Restore only the drawables from the next state
        self.canvas.drawable_manager.drawables._drawables = copy.deepcopy(next_state['drawables'])
        
        # Ensure all objects are properly initialized
        self._fix_drawable_canvas_references()
        
        # Make sure to reset any cached or derived values
        # This ensures a complete state reset
        self.canvas.draw()
        
        return True
    
    def can_undo(self):
        """
        Checks if there are any states that can be undone.
        
        Returns:
            bool: True if undo is possible, False otherwise
        """
        return len(self.undo_stack) > 0
    
    def can_redo(self):
        """
        Checks if there are any states that can be redone.
        
        Returns:
            bool: True if redo is possible, False otherwise
        """
        return len(self.redo_stack) > 0
    
    def _fix_drawable_canvas_references(self):
        """
        Ensures all drawables have a reference to the canvas.
        
        This is necessary after loading a saved state, as the serialization
        process may lose these references.
        """
        for drawable_type in self.canvas.drawable_manager.drawables._drawables:
            for drawable in self.canvas.drawable_manager.drawables._drawables[drawable_type]:
                drawable.canvas = self.canvas
                
    def clear(self):
        """
        Clears all undo and redo history.
        """
        self.undo_stack = []
        self.redo_stack = [] 