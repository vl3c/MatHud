from utils.math_utils import MathUtils

class DrawableDependencyManager:
    """
    Manages dependencies between drawable objects to maintain hierarchical structure.
    
    This class:
    - Tracks parent-child relationships between drawables
    - Resolves dependency chains
    - Handles propagation of changes (like canvas references)
    """
    
    def __init__(self):
        """Initialize the dependency manager"""
        # Maps drawable to its immediate parents
        self._parents = {}
        # Maps drawable to its immediate children
        self._children = {}
        # Type hierarchy - which types depend on which other types
        self._type_hierarchy = {
            'Point': [],
            'Segment': ['Point'],
            'Vector': ['Point'],
            'Triangle': ['Segment', 'Point'],
            'Rectangle': ['Segment', 'Point'],
            'Circle': ['Point'],
            'Ellipse': ['Point'],
            'Function': [],
            'ColoredArea': ['Function', 'Segment'],
            'SegmentsBoundedColoredArea': ['Segment'],
            'FunctionSegmentBoundedColoredArea': ['Function', 'Segment'],
            'FunctionsBoundedColoredArea': ['Function']
        }
    
    def register_dependency(self, child, parent):
        """
        Register a child-parent dependency
        
        Args:
            child: The child drawable that depends on the parent
            parent: The parent drawable that child depends on
        """
        print(f"Registering dependency: child={child} depends on parent={parent}")
        
        # Verify objects have get_class_name
        self._verify_get_class_name_method(child, "Child")
        self._verify_get_class_name_method(parent, "Parent")
        
        # Ensure the objects are in the maps
        if child not in self._parents:
            self._parents[child] = set()
        if parent not in self._children:
            self._children[parent] = set()
            
        # Add the relationship
        self._parents[child].add(parent)
        self._children[parent].add(child)
        
        print(f"After registration: {parent} has {len(self._children.get(parent, set()))} children")
        print(f"After registration: {child} has {len(self._parents.get(child, set()))} parents")
    
    def _verify_get_class_name_method(self, obj, obj_type_name):
        """
        Verify that an object has the get_class_name method
        
        Args:
            obj: The object to verify
            obj_type_name: A string indicating the type of object (e.g., "Child", "Parent")
        """
        if not hasattr(obj, 'get_class_name'):
            print(f"WARNING: {obj_type_name} {obj} is missing get_class_name method")
            # If missing, let's make sure we can still identify the object
            print(f"{obj_type_name} object type: {type(obj)}")
    
    def get_parents(self, drawable):
        """
        Get all direct parents of a drawable
        
        Args:
            drawable: The drawable to find parents for
            
        Returns:
            set: Set of parent drawables
        """
        if drawable is None:
            print("Warning: Trying to get parents for None drawable")
            return set()
        
        return self._parents.get(drawable, set())
    
    def get_children(self, drawable):
        """
        Get all direct children of a drawable
        
        Args:
            drawable: The drawable to find children for
            
        Returns:
            set: Set of child drawables
        """
        if drawable is None:
            print("Warning: Trying to get children for None drawable")
            return set()
        
        return self._children.get(drawable, set())
    
    def get_all_parents(self, drawable):
        """
        Get all parents recursively (transitive closure)
        
        Args:
            drawable: The drawable to find all parents for
            
        Returns:
            set: Set of all parent drawables
        """
        if drawable is None:
            print("Warning: Trying to get parents for None drawable")
            return set()
        
        all_parents = set()
        to_process = self.get_parents(drawable)
        
        while to_process:
            parent = to_process.pop()
            if parent is None:
                print("Warning: Found None parent in dependency tree")
                continue
            
            if parent not in all_parents:
                all_parents.add(parent)
                to_process.update(self.get_parents(parent))
            
        return all_parents
    
    def get_all_children(self, drawable):
        """
        Get all children recursively (transitive closure)
        
        Args:
            drawable: The drawable to find all children for
            
        Returns:
            set: Set of all child drawables
        """
        if drawable is None:
            print("Warning: Trying to get children for None drawable")
            return set()
        
        all_children = set()
        to_process = self.get_children(drawable)
        
        while to_process:
            child = to_process.pop()
            if child is None:
                print("Warning: Found None child in dependency tree")
                continue
            
            if child not in all_children:
                all_children.add(child)
                to_process.update(self.get_children(child))
            
        return all_children
    
    def remove_drawable(self, drawable):
        """
        Remove a drawable from the dependency graph
        
        Args:
            drawable: The drawable to remove
        """
        # Remove from children's parents
        for child in self.get_children(drawable):
            if drawable in self._parents.get(child, set()):
                self._parents[child].remove(drawable)
                
        # Remove from parents' children
        for parent in self.get_parents(drawable):
            if drawable in self._children.get(parent, set()):
                self._children[parent].remove(drawable)
                
        # Remove drawable's entries
        if drawable in self._parents:
            del self._parents[drawable]
        if drawable in self._children:
            del self._children[drawable]
    
    def update_canvas_references(self, drawable, canvas):
        """
        Update canvas references for a drawable and its dependencies
        
        Args:
            drawable: The drawable to update
            canvas: The canvas reference to set
        """
        if drawable is None:
            print("Warning: Trying to update canvas references for None drawable")
            return
            
        print(f"Starting canvas update for {drawable}")
        
        # Track all visited objects to avoid cycles
        visited = set()
        
        # Use a queue for breadth-first traversal
        queue = [drawable]
        
        # Breadth-first traversal to update all connected objects
        while queue:
            current = queue.pop(0)
            
            # Skip if already visited or None
            if current in visited or current is None:
                continue
                
            visited.add(current)
            
            # Update the current object's canvas
            if hasattr(current, 'canvas'):
                current.canvas = canvas
                print(f"Updated {current}.canvas = {canvas}")
            
            # Add children (objects that depend on this one)
            children = self.get_children(current)
            for child in children:
                if child is not None and child not in visited:
                    queue.append(child)
                    
            # Add parents (objects this one depends on)
            parents = self.get_parents(current)
            for parent in parents:
                if parent is not None and parent not in visited:
                    queue.append(parent)
                    
            # Special handling for segments (they already have the points as parents,
            # but this ensures we handle the direct references too)
            if hasattr(current, 'get_class_name') and current.get_class_name() == 'Segment':
                if hasattr(current, 'point1') and current.point1 is not None:
                    if current.point1 not in visited:
                        queue.append(current.point1)
                        
                if hasattr(current, 'point2') and current.point2 is not None:
                    if current.point2 not in visited:
                        queue.append(current.point2)
    
    def analyze_drawable_for_dependencies(self, drawable):
        """
        Analyze a drawable to find and register its dependencies
        
        Args:
            drawable: The drawable to analyze
            
        Returns:
            list: List of identified dependencies
        """
        dependencies = []
        
        # Verify drawable has get_class_name method
        self._verify_get_class_name_method(drawable, "Drawable")
        
        # Get class name safely
        if not hasattr(drawable, 'get_class_name'):
            print(f"Cannot analyze dependencies for {drawable} without get_class_name method")
            return dependencies
            
        class_name = drawable.get_class_name()
        
        # Handle different drawable types
        if class_name == 'Point':
            # Points don't have dependencies
            pass
            
        elif class_name == 'Segment':
            if hasattr(drawable, 'point1'):
                dependencies.append(drawable.point1)
                self.register_dependency(drawable, drawable.point1)
            if hasattr(drawable, 'point2'):
                dependencies.append(drawable.point2)
                self.register_dependency(drawable, drawable.point2)
                
        elif class_name == 'Vector':
            if hasattr(drawable, 'segment'):
                dependencies.append(drawable.segment)
                self.register_dependency(drawable, drawable.segment)
                
        elif class_name == 'Triangle':
            # Check for individual segment attributes
            for i in range(1, 4):
                segment_attr = f'segment{i}'
                if hasattr(drawable, segment_attr):
                    segment = getattr(drawable, segment_attr)
                    dependencies.append(segment)
                    self.register_dependency(drawable, segment)
                    
        elif class_name == 'Rectangle':
            # Check for individual segment attributes
            for i in range(1, 5):
                segment_attr = f'segment{i}'
                if hasattr(drawable, segment_attr):
                    segment = getattr(drawable, segment_attr)
                    dependencies.append(segment)
                    self.register_dependency(drawable, segment)
                    
        elif class_name == 'Circle':
            if hasattr(drawable, 'center'):
                dependencies.append(drawable.center)
                self.register_dependency(drawable, drawable.center)
                
        elif class_name == 'Ellipse':
            if hasattr(drawable, 'center'):
                dependencies.append(drawable.center)
                self.register_dependency(drawable, drawable.center)
                
        elif class_name == 'Function':
            # Functions typically don't have drawable dependencies
            pass
            
        elif class_name == 'SegmentsBoundedColoredArea':
            if hasattr(drawable, 'segment1') and drawable.segment1:
                dependencies.append(drawable.segment1)
                self.register_dependency(drawable, drawable.segment1)
            if hasattr(drawable, 'segment2') and drawable.segment2:
                dependencies.append(drawable.segment2)
                self.register_dependency(drawable, drawable.segment2)
                
        elif class_name == 'FunctionSegmentBoundedColoredArea':
            if hasattr(drawable, 'func') and drawable.func and hasattr(drawable.func, 'get_class_name'):
                dependencies.append(drawable.func)
                self.register_dependency(drawable, drawable.func)
            if hasattr(drawable, 'segment'):
                dependencies.append(drawable.segment)
                self.register_dependency(drawable, drawable.segment)
                
        elif class_name == 'FunctionsBoundedColoredArea':
            if hasattr(drawable, 'func1') and drawable.func1 and hasattr(drawable.func1, 'get_class_name'):
                dependencies.append(drawable.func1)
                self.register_dependency(drawable, drawable.func1)
            if hasattr(drawable, 'func2') and drawable.func2 and hasattr(drawable.func2, 'get_class_name'):
                dependencies.append(drawable.func2)
                self.register_dependency(drawable, drawable.func2)
                
        elif class_name.endswith('ColoredArea'):
            # Generic case for other ColoredArea types
            if hasattr(drawable, 'function'):
                dependencies.append(drawable.function)
                self.register_dependency(drawable, drawable.function)
            if hasattr(drawable, 'segments'):
                for segment in drawable.segments:
                    dependencies.append(segment)
                    self.register_dependency(drawable, segment)
            
        return dependencies
    
    def _get_segment_parents(self, segment):
        """Finds parents by iterating all segments and checking their .children attribute."""
        parents = []
        # Access segments via the proxy
        if self.drawable_manager and self.drawable_manager.drawables:
            all_segments = self.drawable_manager.drawables.Segments
            for s in all_segments:
                if hasattr(s, 'children') and segment in s.children:
                    parents.append(s)
        return parents

    def _find_segment_children(self, segment):
        """Finds children geometrically by iterating through all segments."""
        sp1, sp2 = segment.point1.original_position, segment.point2.original_position
        children = []
        # Access segments via the proxy
        if self.drawable_manager and self.drawable_manager.drawables:
            all_segments = self.drawable_manager.drawables.Segments
            for s in all_segments:
                if s == segment:
                    continue
                if not hasattr(s, 'point1') or not hasattr(s, 'point2'): # Safety check
                    continue 
                p1, p2 = s.point1.original_position, s.point2.original_position
                # Check if s is geometrically within segment
                if MathUtils.is_point_on_segment(p1.x, p1.y, sp1.x, sp1.y, sp2.x, sp2.y) and \
                   MathUtils.is_point_on_segment(p2.x, p2.y, sp1.x, sp1.y, sp2.x, sp2.y):
                    children.append(s)
        return children

    def _add_segment_to_parents(self, segment_to_add, current_parent=None):
        """Recursively adds segment_to_add to the .children of its parents/ancestors 
           (found by checking .children attributes)."""
        if current_parent is None:
            # Find direct parents using the .children check
            parents = self._get_segment_parents(segment_to_add)
        else:
            # Find ancestors using the .children check
            parents = self._get_segment_parents(current_parent)
            
        for parent in parents:
            if hasattr(parent, 'children'):
                 parent.children.add(segment_to_add)
            else:
                 # Initialize children set if missing (though Segment init should handle this)
                 parent.children = {segment_to_add}
                 print(f"Warning: Initialized missing 'children' attribute for Parent {parent}.")
            # Recurse upwards
            self._add_segment_to_parents(segment_to_add, parent)

    def _delete_segment_parents(self, segment):
        """Finds parents via .children check and calls delete_segment via proxy."""
        print(f"Deleting segment {segment.name} parents (using .children logic)")
        parents = self._get_segment_parents(segment)
        for parent in list(parents): # Iterate over a copy
            if not hasattr(parent, 'point1') or not hasattr(parent, 'point2'): continue # Safety
            p1x = parent.point1.original_position.x
            p1y = parent.point1.original_position.y
            p2x = parent.point2.original_position.x
            p2y = parent.point2.original_position.y
            if self.drawable_manager:
                 # Call delete_segment via the proxy
                 self.drawable_manager.delete_segment(p1x, p1y, p2x, p2y, delete_children=True, delete_parents=True)
            else:
                 print("Warning: drawable_manager proxy not set in DrawableDependencyManager")

    def _delete_segment_children(self, segment):
        """Deletes children found in segment.children if they have no other parents (checked via .children)."""
        print(f"Deleting segment {segment.name} children (using .children logic)")
        if not hasattr(segment, 'children'):
             print(f"Warning: Segment {segment.name} does not have 'children' attribute.")
             return

        for child_segment in list(segment.children): # Iterate over a copy
            # Check parentage using the .children logic
            all_parents = self._get_segment_parents(child_segment)
            
            # Only delete the child if this segment is its only parent
            if len(all_parents) <= 1: 
                if not hasattr(child_segment, 'point1') or not hasattr(child_segment, 'point2'): continue # Safety
                p1x = child_segment.point1.original_position.x
                p1y = child_segment.point1.original_position.y
                p2x = child_segment.point2.original_position.x
                p2y = child_segment.point2.original_position.y
                if self.drawable_manager:
                     # Call delete_segment via the proxy
                     self.drawable_manager.delete_segment(p1x, p1y, p2x, p2y, delete_children=True, delete_parents=False)
                else:
                     print("Warning: drawable_manager proxy not set in DrawableDependencyManager")
            else:
                # If child has other parents, just remove the current segment 
                # from the list found by _get_segment_parents (which checks .children)
                # This is tricky - the original code just did segment.children.remove(child_segment)
                # Let's stick to the simplest equivalent: remove from current segment's children list.
                if child_segment in segment.children:
                     segment.children.remove(child_segment) 
                     print(f"Removed {child_segment.name} from {segment.name}.children as it has other parents.")

    def _remove_segment_from_parents(self, segment_to_remove):
        """Removes segment_to_remove from the .children attribute of its parents (found via .children check)."""
        parents = self._get_segment_parents(segment_to_remove)
        for parent in parents:
             if hasattr(parent, 'children') and segment_to_remove in parent.children:
                  parent.children.remove(segment_to_remove)
             # else: # Don't warn if already removed or parent has no children attr
             #      print(f"Warning: Could not remove {segment_to_remove} from children of {parent}")

    def resolve_dependency_order(self, drawables):
        """
        Determine the correct order to process drawables based on dependencies
        
        Args:
            drawables: List of drawables to process
            
        Returns:
            list: Ordered list of drawables (parents before children)
        """
        # Filter out None values
        filtered_drawables = [d for d in drawables if d is not None]
        
        # Simple topological sort
        result = []
        visited = set()
        
        def visit(drawable):
            if drawable in visited:
                return
                
            visited.add(drawable)
            
            # Visit all parents first
            for parent in self.get_parents(drawable):
                visit(parent)
                
            result.append(drawable)
            
        # Process all drawables
        for drawable in filtered_drawables:
            visit(drawable)
            
        return result 