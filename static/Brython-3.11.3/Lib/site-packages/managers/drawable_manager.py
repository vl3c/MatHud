from drawables.point import Point
from drawables.segment import Segment
from drawables.vector import Vector
from drawables.triangle import Triangle
from drawables.rectangle import Rectangle
from drawables.circle import Circle
from drawables.ellipse import Ellipse
from drawables.function import Function
from drawables.functions_bounded_colored_area import FunctionsBoundedColoredArea
from drawables.segments_bounded_colored_area import SegmentsBoundedColoredArea
from drawables.function_segment_bounded_colored_area import FunctionSegmentBoundedColoredArea
from name_generator.drawable import DrawableNameGenerator
from utils.math_utils import MathUtils
from utils.style_utils import StyleUtils
from expression_validator import ExpressionValidator
from managers.drawable_dependency_manager import DrawableDependencyManager
from managers.drawables_container import DrawablesContainer

class DrawableManager:
    """
    Manages drawable objects for a Canvas.
    
    This class is responsible for:
    - Creating drawable objects (points, segments, etc.)
    - Retrieving drawable objects by various criteria
    - Deleting drawable objects
    """
    
    def __init__(self, canvas):
        """
        Initialize the DrawableManager.
        
        Args:
            canvas: The Canvas object this manager is responsible for
        """
        self.canvas = canvas
        self.name_generator = DrawableNameGenerator(canvas)
        self.drawables = DrawablesContainer()
        self.dependency_manager = DrawableDependencyManager()
        
    # ------------------- General Drawable Methods -------------------
    
    def get_drawables(self):
        """Get all drawables as a flat list"""
        return self.drawables.get_all()
    
    # ------------------- Point Methods -------------------
    
    def get_point(self, x, y):
        """Get a point at the specified coordinates"""
        for point in self.drawables.Points:
            if MathUtils.point_matches_coordinates(point, x, y):
                return point
        return None
        
    def get_point_by_name(self, name):
        """Get a point by its name"""
        for point in self.drawables.Points:
            if point.name == name:
                return point
        return None
        
    def create_point(self, x, y, name="", extra_graphics=True):
        """
        Create a new point at the specified coordinates
        
        Args:
            x: x-coordinate
            y: y-coordinate
            name: Optional name for the point
            extra_graphics: Whether to create additional graphics (e.g. split segments)
            
        Returns:
            Point: The newly created point
        """
        # Archive before creation for undo functionality
        self.canvas.undo_redo_manager.archive()
        
        # Check if a point already exists at these coordinates
        existing_point = self.get_point(x, y)
        if existing_point:
            return existing_point
            
        # Generate a name
        name = self.name_generator.generate_point_name(name)
        
        # Create the new point
        new_point = Point(x=x, y=y, canvas=self.canvas, name=name)
        
        # Add to drawables
        self.drawables.add(new_point)
        
        # Handle extra graphics - splits segments and creates connections
        if extra_graphics:
            self.canvas._split_segments_with_point(x, y)
            self.canvas._create_drawables_from_new_connections()
        
        # Draw the point if draw_enabled is True
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_point
        
    def delete_point(self, x, y):
        """Delete a point at the specified coordinates"""
        point = self.get_point(x, y)
        if not point:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        # Delete dependencies first
        self.canvas._delete_point_dependencies(x, y)
        
        # Now remove the point itself
        self.drawables.remove(point)
            
        # Redraw the canvas
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    def delete_point_by_name(self, name):
        """Delete a point by its name"""
        point = self.get_point_by_name(name)
        if not point:
            return False
            
        return self.delete_point(point.original_position.x, point.original_position.y)
    
    # ------------------- Segment Methods -------------------
    
    def get_segment_by_coordinates(self, x1, y1, x2, y2):
        """Get a segment by its endpoint coordinates"""
        for segment in self.drawables.Segments:
            if MathUtils.segment_matches_coordinates(segment, x1, y1, x2, y2):
                return segment
        return None
        
    def get_segment_by_name(self, name):
        """Get a segment by its name"""
        for segment in self.drawables.Segments:
            if segment.name == name:
                return segment
        return None
        
    def get_segment_by_points(self, p1, p2):
        """Get a segment by its endpoint points"""
        return self.get_segment_by_coordinates(p1.original_position.x, p1.original_position.y, 
                                              p2.original_position.x, p2.original_position.y)
        
    def create_segment(self, x1, y1, x2, y2, name="", extra_graphics=True):
        """
        Create a new segment between the specified points
        
        Args:
            x1, y1: Coordinates of the first endpoint
            x2, y2: Coordinates of the second endpoint
            name: Optional name for the segment
            extra_graphics: Whether to create additional graphics
            
        Returns:
            Segment: The newly created segment
        """
        # Archive before creation
        self.canvas.undo_redo_manager.archive()
        
        # Check if the segment already exists
        existing_segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if existing_segment:
            return existing_segment
            
        # Handle point names from segment name, if provided
        point_names = ["", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 2)
            
        # Create or get the endpoints with proper names
        p1 = self.create_point(x1, y1, name=point_names[0], extra_graphics=False)
        p2 = self.create_point(x2, y2, name=point_names[1], extra_graphics=False)
            
        # Create the segment
        segment = Segment(p1, p2, self.canvas)
        
        # Add to drawables
        self.drawables.add(segment)
        
        # Register with dependency manager
        self.dependency_manager.analyze_drawable_for_dependencies(segment)
        
        # Handle extra graphics
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
        
        # Draw the segment
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return segment
        
    def delete_segment(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        """
        Delete a segment by its endpoint coordinates
        
        Args:
            x1, y1: Coordinates of the first endpoint
            x2, y2: Coordinates of the second endpoint
            delete_children: Whether to delete child objects
            delete_parents: Whether to delete parent objects
            
        Returns:
            bool: True if the segment was deleted, False otherwise
        """
        segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if not segment:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        # Handle dependencies
        self.canvas._delete_segment_dependencies(x1, y1, x2, y2, delete_children, delete_parents)
        
        # Remove the segment from its parents
        self.canvas._remove_segment_from_parents(segment)
        
        # Now remove the segment itself
        self.drawables.remove(segment)
        
        # Redraw
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    def delete_segment_by_name(self, name, delete_children=True, delete_parents=False):
        """Delete a segment by its name"""
        segment = self.get_segment_by_name(name)
        if not segment:
            return False
        
        self.canvas.undo_redo_manager.archive()

        x1 = segment.point1.original_position.x
        y1 = segment.point1.original_position.y
        x2 = segment.point2.original_position.x
        y2 = segment.point2.original_position.y
        
        return self.delete_segment(x1, y1, x2, y2, delete_children, delete_parents)
    
    # ------------------- Vector Methods -------------------
    
    def get_vector(self, x1, y1, x2, y2):
        """Get a vector by its origin and tip coordinates"""
        vectors = self.drawables.Vectors
        for vector in vectors:
            if (MathUtils.point_matches_coordinates(vector.origin, x1, y1) and 
                MathUtils.point_matches_coordinates(vector.tip, x2, y2)):
                return vector
        return None
        
    def create_vector(self, origin_x, origin_y, tip_x, tip_y, name="", extra_graphics=True):
        """Create a vector from origin to tip"""
        # Check if the vector already exists
        existing_vector = self.get_vector(origin_x, origin_y, tip_x, tip_y)
        if existing_vector:
            return existing_vector
            
        # Extract point names from vector name
        point_names = ["", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 2)
        
        # Create or get the origin and tip points
        origin = self.create_point(origin_x, origin_y, name=point_names[0], extra_graphics=False)
        tip = self.create_point(tip_x, tip_y, name=point_names[1], extra_graphics=False)
        
        # Create the new vector
        new_vector = Vector(origin, tip, canvas=self.canvas)
        
        # Add to drawables
        self.drawables.add(new_vector)
        
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_vector
        
    def delete_vector(self, origin_x, origin_y, tip_x, tip_y):
        """Delete a vector by its origin and tip coordinates"""
        # Find the vector that matches these coordinates
        vectors = self.drawables.Vectors
        for vector in vectors.copy():
            if (MathUtils.point_matches_coordinates(vector.origin, origin_x, origin_y) and
                MathUtils.point_matches_coordinates(vector.tip, tip_x, tip_y)):
                # Archive before deletion
                self.canvas.undo_redo_manager.archive()
                
                # Remove the vector's segment if it's not used by other objects
                if hasattr(vector, 'segment'):
                    segment = vector.segment
                    p1x = segment.point1.original_position.x
                    p1y = segment.point1.original_position.y
                    p2x = segment.point2.original_position.x
                    p2y = segment.point2.original_position.y
                    self.delete_segment(p1x, p1y, p2x, p2y)
                
                # Remove the vector
                self.drawables.remove(vector)
                
                # Redraw
                if self.canvas.draw_enabled:
                    self.canvas.draw()
                    
                return True
        return False
    
    # ------------------- Triangle Methods -------------------
    
    def get_triangle(self, x1, y1, x2, y2, x3, y3):
        """Get a triangle by its vertex coordinates"""
        triangles = self.drawables.Triangles
        for triangle in triangles:
            if MathUtils.triangle_matches_coordinates(triangle, x1, y1, x2, y2, x3, y3):
                return triangle
        return None
        
    def create_triangle(self, x1, y1, x2, y2, x3, y3, name="", extra_graphics=True):
        """Create a triangle from three points"""
        # Archive before creation
        self.canvas.undo_redo_manager.archive()
        
        # Check if the triangle already exists
        existing_triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if existing_triangle:
            return existing_triangle
            
        # Extract point names from triangle name
        point_names = ["", "", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 3)
            
        # Create points first with the correct names
        p1 = self.create_point(x1, y1, name=point_names[0], extra_graphics=False)
        p2 = self.create_point(x2, y2, name=point_names[1], extra_graphics=False)
        p3 = self.create_point(x3, y3, name=point_names[2], extra_graphics=False)
            
        # Create segments using the points
        s1 = self.create_segment(p1.original_position.x, p1.original_position.y, 
                                p2.original_position.x, p2.original_position.y, 
                                extra_graphics=False)
        s2 = self.create_segment(p2.original_position.x, p2.original_position.y, 
                                p3.original_position.x, p3.original_position.y, 
                                extra_graphics=False)
        s3 = self.create_segment(p3.original_position.x, p3.original_position.y, 
                                p1.original_position.x, p1.original_position.y, 
                                extra_graphics=False)
            
        # Create the triangle
        new_triangle = Triangle(s1, s2, s3, self.canvas)
        
        # Add to drawables
        self.drawables.add(new_triangle)
        
        # Register dependencies
        self.dependency_manager.analyze_drawable_for_dependencies(new_triangle)
        
        # Handle extra graphics if requested
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
        
        # Draw the triangle
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_triangle
        
    def delete_triangle(self, x1, y1, x2, y2, x3, y3):
        """Delete a triangle by its vertex coordinates"""
        triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if not triangle:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        # Remove from drawables
        self.drawables.remove(triangle)
        
        # Delete the segments using the vertex coordinates
        self.delete_segment(x1, y1, x2, y2)
        self.delete_segment(x2, y2, x3, y3)
        self.delete_segment(x3, y3, x1, y1)
        
        # Redraw
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # Methods for Function objects
    def get_function(self, name):
        """Get a function by its name"""
        functions = self.drawables.Functions
        for function in functions:
            if function.name == name:
                return function
        return None
        
    def draw_function(self, function_string, name, left_bound=None, right_bound=None):
        """Draw a function on the canvas"""
        # Archive before creation or modification
        self.canvas.undo_redo_manager.archive()
        
        # Check if the function already exists
        existing_function = self.get_function(name)
        if existing_function:
            # If it exists, update its expression
            try:
                existing_function.function_string = ExpressionValidator.fix_math_expression(function_string)
                existing_function.function = ExpressionValidator.parse_function_string(function_string, use_mathjs=False)
            except Exception as e:
                raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
            # Update the bounds
            existing_function.left_bound = left_bound
            existing_function.right_bound = right_bound
            
            if self.canvas.draw_enabled:
                self.canvas.draw()
            return existing_function
        else:
            # Generate a proper name if needed
            name = self.name_generator.generate_function_name(name)
                
            # Create the function
            new_function = Function(function_string, self.canvas, name=name, left_bound=left_bound, right_bound=right_bound)
            
            # Add to drawables
            self.drawables.add(new_function)
            
            # Draw the function
            if self.canvas.draw_enabled:
                self.canvas.draw()
                
            return new_function
        
    def delete_function(self, name):
        """Delete a function by its name"""
        function = self.get_function(name)
        if not function:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        # Remove the function
        self.drawables.remove(function)
            
        # Also delete any colored areas associated with this function
        self.delete_colored_areas_for_function(function)
        
        # Redraw the canvas
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Circle Methods -------------------
    
    def get_circle(self, center_x, center_y, radius):
        """Get a circle by its center coordinates and radius"""
        circles = self.drawables.Circles
        for circle in circles:
            if (circle.center.original_position.x == center_x and 
                circle.center.original_position.y == center_y and 
                circle.radius == radius):
                return circle
        return None
        
    def get_circle_by_name(self, name):
        """Get a circle by its name"""
        circles = self.drawables.Circles
        for circle in circles:
            if circle.name == name:
                return circle
        return None
        
    def create_circle(self, center_x, center_y, radius, name="", extra_graphics=True):
        """Create a circle with the specified center and radius"""
        # Archive before creation
        self.canvas.undo_redo_manager.archive()
        
        # Check if the circle already exists
        existing_circle = self.get_circle(center_x, center_y, radius)
        if existing_circle:
            return existing_circle
            
        # Extract point name from circle name
        point_names = self.name_generator.split_point_names(name, 1)
        
        # Create center point with the correct name
        center = self.create_point(center_x, center_y, point_names[0], extra_graphics=False)
            
        # Create the circle
        new_circle = Circle(center, radius, self.canvas)
        
        # Add to drawables
        self.drawables.add(new_circle)
        
        # Register dependencies
        self.dependency_manager.analyze_drawable_for_dependencies(new_circle)
        
        # Handle extra graphics if requested
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
        
        # Draw the circle
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_circle
        
    def delete_circle(self, name):
        """Delete a circle by its name"""
        circle = self.get_circle_by_name(name)
        if not circle:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        # Remove from drawables
        self.drawables.remove(circle)
        
        # Redraw
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Ellipse Methods -------------------
    
    def get_ellipse(self, center_x, center_y, radius_x, radius_y):
        """Get an ellipse by its center coordinates and radii"""
        ellipses = self.drawables.Ellipses
        for ellipse in ellipses:
            if (ellipse.center.original_position.x == center_x and 
                ellipse.center.original_position.y == center_y and 
                ellipse.radius_x == radius_x and 
                ellipse.radius_y == radius_y):
                return ellipse
        return None
        
    def get_ellipse_by_name(self, name):
        """Get an ellipse by its name"""
        ellipses = self.drawables.Ellipses
        for ellipse in ellipses:
            if ellipse.name == name:
                return ellipse
        return None
        
    def create_ellipse(self, center_x, center_y, radius_x, radius_y, rotation_angle=0, name="", extra_graphics=True):
        """Create an ellipse with the specified center, radii, and rotation angle"""
        # Archive before creation
        self.canvas.undo_redo_manager.archive()
        
        # Check if the ellipse already exists
        existing_ellipse = self.get_ellipse(center_x, center_y, radius_x, radius_y)
        if existing_ellipse:
            return existing_ellipse
            
        # Extract point name from ellipse name
        point_names = self.name_generator.split_point_names(name, 1)
        
        # Create center point with the correct name
        center = self.create_point(center_x, center_y, point_names[0], extra_graphics=False)
            
        # Create the ellipse
        new_ellipse = Ellipse(center, radius_x, radius_y, self.canvas, rotation_angle=rotation_angle)
        
        # Add to drawables
        self.drawables.add(new_ellipse)
        
        # Register dependencies
        self.dependency_manager.analyze_drawable_for_dependencies(new_ellipse)
        
        # Handle extra graphics if requested
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
        
        # Draw the ellipse
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_ellipse
        
    def delete_ellipse(self, name):
        """Delete an ellipse by its name"""
        ellipse = self.get_ellipse_by_name(name)
        if not ellipse:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        # Remove from drawables
        self.drawables.remove(ellipse)
        
        # Redraw
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Rectangle Methods -------------------
    
    def get_rectangle_by_diagonal_points(self, px, py, opposite_px, opposite_py):
        """Get a rectangle by two diagonal points"""
        rectangles = self.drawables.Rectangles
        
        # Calculate the coordinates of the other two corners based on the diagonal points
        corner1 = (px, py)
        corner2 = (opposite_px, py)
        corner3 = (opposite_px, opposite_py)
        corner4 = (px, opposite_py)
        
        # Iterate over all rectangles
        for rectangle in rectangles:
            segments = [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]
            rectangle_corners = [(segment.point1.original_position.x, segment.point1.original_position.y) for segment in segments]
            
            # Ensuring all corners are matched, considering rectangles could be defined in any direction
            if all(corner in rectangle_corners for corner in [corner1, corner2, corner3, corner4]):
                return rectangle
                
        return None
        
    def get_rectangle_by_name(self, name):
        """Get a rectangle by its name"""
        rectangles = self.drawables.Rectangles
        for rectangle in rectangles:
            if rectangle.name == name:
                return rectangle
        return None
        
    def create_rectangle(self, px, py, opposite_px, opposite_py, name="", extra_graphics=True):
        """Create a rectangle with the specified diagonal points"""
        # Archive before creation
        self.canvas.undo_redo_manager.archive()
        
        # Check if the rectangle already exists
        existing_rectangle = self.get_rectangle_by_diagonal_points(px, py, opposite_px, opposite_py)
        if existing_rectangle:
            return existing_rectangle
            
        # Extract point names from rectangle name
        point_names = ["", "", "", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 4)
        
        # Create points first with the correct names
        p1 = self.create_point(px, py, point_names[0], extra_graphics=False)
        p2 = self.create_point(opposite_px, py, point_names[1], extra_graphics=False)
        p3 = self.create_point(opposite_px, opposite_py, point_names[2], extra_graphics=False)
        p4 = self.create_point(px, opposite_py, point_names[3], extra_graphics=False)
        
        # Create segments using the points
        s1 = self.create_segment(p1.original_position.x, p1.original_position.y, 
                               p2.original_position.x, p2.original_position.y, 
                               extra_graphics=False)
        s2 = self.create_segment(p2.original_position.x, p2.original_position.y, 
                               p3.original_position.x, p3.original_position.y, 
                               extra_graphics=False)
        s3 = self.create_segment(p3.original_position.x, p3.original_position.y, 
                               p4.original_position.x, p4.original_position.y, 
                               extra_graphics=False)
        s4 = self.create_segment(p4.original_position.x, p4.original_position.y, 
                               p1.original_position.x, p1.original_position.y, 
                               extra_graphics=False)
        
        # Create the rectangle
        new_rectangle = Rectangle(s1, s2, s3, s4, self.canvas)
        
        # Add to drawables
        self.drawables.add(new_rectangle)
        
        # Register dependencies
        self.dependency_manager.analyze_drawable_for_dependencies(new_rectangle)
        
        # Handle extra graphics if requested
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
        
        # Draw the rectangle
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_rectangle
        
    def delete_rectangle(self, name):
        """Delete a rectangle by its name"""
        rectangle = self.get_rectangle_by_name(name)
        if not rectangle:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        # Remove from drawables
        self.drawables.remove(rectangle)
        
        # Delete all 4 segments
        self.delete_segment(rectangle.segment1.point1.original_position.x, rectangle.segment1.point1.original_position.y, 
                           rectangle.segment1.point2.original_position.x, rectangle.segment1.point2.original_position.y)
        self.delete_segment(rectangle.segment2.point1.original_position.x, rectangle.segment2.point1.original_position.y, 
                           rectangle.segment2.point2.original_position.x, rectangle.segment2.point2.original_position.y)
        self.delete_segment(rectangle.segment3.point1.original_position.x, rectangle.segment3.point1.original_position.y, 
                           rectangle.segment3.point2.original_position.x, rectangle.segment3.point2.original_position.y)
        self.delete_segment(rectangle.segment4.point1.original_position.x, rectangle.segment4.point1.original_position.y, 
                           rectangle.segment4.point2.original_position.x, rectangle.segment4.point2.original_position.y)
        
        # Redraw
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- ColoredArea Methods -------------------
    
    def create_colored_area(self, drawable1_name, drawable2_name=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3):
        """
        Creates a colored area between two functions, two segments, or a function and a segment.
        Automatically determines the type of colored area based on the inputs.
        
        Args:
            drawable1_name: Name of first function/segment (or None for x-axis)
            drawable2_name: Name of second function/segment (or None for x-axis)
            left_bound: Optional left bound for function areas
            right_bound: Optional right bound for function areas
            color: Color of the area (default: lightblue)
            opacity: Opacity of the area (default: 0.3)
            
        Returns:
            The created colored area object
            
        Raises:
            ValueError: If color or opacity values are invalid or if drawables not found
        """
        # Validate color and opacity before proceeding
        self.canvas._validate_color_and_opacity(color, opacity)
        
        # Archive for undo
        self.canvas.undo_redo_manager.archive()
        
        # Get the first drawable
        drawable1 = None
        if drawable1_name is not None and drawable1_name != "x_axis":
            drawable1 = self.get_segment_by_name(drawable1_name)
            if drawable1 is None:
                drawable1 = self.get_function(drawable1_name)
            if drawable1 is None:
                raise ValueError(f"Could not find drawable with name {drawable1_name}")
        
        # Get the second drawable if provided
        drawable2 = None
        if drawable2_name is not None and drawable2_name != "x_axis":
            drawable2 = self.get_segment_by_name(drawable2_name)
            if drawable2 is None:
                drawable2 = self.get_function(drawable2_name)
            if drawable2 is None:
                raise ValueError(f"Could not find drawable with name {drawable2_name}")
        
        if isinstance(drawable1, Segment):
            if drawable2 is not None and not isinstance(drawable2, Segment):
                if isinstance(drawable2, (Function, type(None))) or isinstance(drawable2, (int, float)):
                    # If drawable1 is a segment and drawable2 is a function/None/number, swap them
                    drawable1, drawable2 = drawable2, drawable1
                else:
                    raise ValueError("Invalid combination of arguments")

        if isinstance(drawable1, Segment) and (drawable2 is None or isinstance(drawable2, Segment)):
            # Segment-segment or segment-xaxis case
            if drawable2:  # Segment-segment case
                # Create points at overlap boundaries
                def get_y_at_x(segment, x):
                    # Linear interpolation to find y value at x using original coordinates
                    x1, y1 = segment.point1.original_position.x, segment.point1.original_position.y
                    x2, y2 = segment.point2.original_position.x, segment.point2.original_position.y
                    if x2 == x1:
                        return y1  # Vertical segment
                    t = (x - x1) / (x2 - x1)
                    return y1 + t * (y2 - y1)

                # Get x-ranges of both segments using original coordinates
                x1_min = min(drawable1.point1.original_position.x, drawable1.point2.original_position.x)
                x1_max = max(drawable1.point1.original_position.x, drawable1.point2.original_position.x)
                x2_min = min(drawable2.point1.original_position.x, drawable2.point2.original_position.x)
                x2_max = max(drawable2.point1.original_position.x, drawable2.point2.original_position.x)

                # Check if segment1 endpoints create points on segment2
                if x1_min >= x2_min and x1_min <= x2_max:
                    y = get_y_at_x(drawable2, x1_min)
                    self.create_point(x1_min, y)
                if x1_max >= x2_min and x1_max <= x2_max:
                    y = get_y_at_x(drawable2, x1_max)
                    self.create_point(x1_max, y)

                # Check if segment2 endpoints create points on segment1
                if x2_min >= x1_min and x2_min <= x1_max:
                    y = get_y_at_x(drawable1, x2_min)
                    self.create_point(x2_min, y)
                if x2_max >= x1_min and x2_max <= x1_max:
                    y = get_y_at_x(drawable1, x2_max)
                    self.create_point(x2_max, y)

            colored_area = SegmentsBoundedColoredArea(drawable1, drawable2, canvas=self.canvas, color=color, opacity=opacity)
        elif isinstance(drawable2, Segment):
            # Function-segment case (we know drawable1 is not a segment due to the swap above)
            colored_area = FunctionSegmentBoundedColoredArea(drawable1, drawable2, canvas=self.canvas, color=color, opacity=opacity)
        else:
            # Function-function case
            colored_area = FunctionsBoundedColoredArea(drawable1, drawable2, canvas=self.canvas, 
                                                     left_bound=left_bound, right_bound=right_bound,
                                                     color=color, opacity=opacity)

        # Add to drawables
        self.drawables.add(colored_area)
        
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return colored_area
        
    def delete_colored_area(self, name):
        """Delete a colored area by its name"""
        # Find the colored area in all categories
        colored_area = None
        for category_property in [self.drawables.FunctionsBoundedColoredAreas, 
                                 self.drawables.SegmentsBoundedColoredAreas,
                                 self.drawables.FunctionSegmentBoundedColoredAreas]:
            for area in category_property:
                if area.name == name:
                    colored_area = area
                    break
            if colored_area:
                break
                
        if not colored_area:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        # Remove the colored area
        self.drawables.remove(colored_area)
        
        # Redraw
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    def delete_colored_areas_for_function(self, func):
        """
        Deletes all colored areas associated with a function
        
        Args:
            func: The function whose colored areas should be deleted
            
        Returns:
            bool: True if any areas were deleted, False otherwise
        """
        # Check if function is a string (name) or object
        if isinstance(func, str):
            func = self.get_function(func)
            
        if not func:
            return False
            
        # First check if there are any areas to delete
        areas_to_delete = []
        
        # Check FunctionsBoundedColoredArea
        for area in self.drawables.FunctionsBoundedColoredAreas:
            if area.func1 == func or area.func2 == func:
                areas_to_delete.append(area)

        # Check FunctionSegmentBoundedColoredArea
        for area in self.drawables.FunctionSegmentBoundedColoredAreas:
            if area.func == func:
                areas_to_delete.append(area)
        
        if areas_to_delete:
            # Archive for undo
            self.canvas.undo_redo_manager.archive()
            
            # Now delete the areas
            for area in areas_to_delete:
                self.drawables.remove(area)
                
            if self.canvas.draw_enabled:
                self.canvas.draw()
                
            return True
            
        return False
                
    def delete_colored_areas_for_segment(self, segment):
        """
        Deletes all colored areas associated with a segment
        
        Args:
            segment: The segment whose colored areas should be deleted
            
        Returns:
            bool: True if any areas were deleted, False otherwise
        """
        # Check if segment is a string (name) or object
        if isinstance(segment, str):
            segment = self.get_segment_by_name(segment)
            
        if not segment:
            return False
            
        # First check if there are any areas to delete
        areas_to_delete = []
        
        # Check SegmentsBoundedColoredArea
        for area in self.drawables.SegmentsBoundedColoredAreas:
            if area.uses_segment(segment):
                areas_to_delete.append(area)
                
        # Check FunctionSegmentBoundedColoredArea
        for area in self.drawables.FunctionSegmentBoundedColoredAreas:
            if area.uses_segment(segment):
                areas_to_delete.append(area)
        
        if areas_to_delete:
            # Archive for undo
            self.canvas.undo_redo_manager.archive()
            
            # Now delete the areas
            for area in areas_to_delete:
                self.drawables.remove(area)
                
            if self.canvas.draw_enabled:
                self.canvas.draw()
                
            return True
            
        return False
        
    def get_colored_areas_for_drawable(self, drawable):
        """
        Gets all colored areas associated with a drawable (function or segment)
        
        Args:
            drawable: The function or segment to find colored areas for
            
        Returns:
            list: List of colored areas that use the drawable
        """
        areas = []
        
        if isinstance(drawable, Function):
            # Check FunctionsBoundedColoredArea
            for area in self.drawables.FunctionsBoundedColoredAreas:
                if area.func1 == drawable or area.func2 == drawable:
                    areas.append(area)

            # Check FunctionSegmentBoundedColoredArea
            for area in self.drawables.FunctionSegmentBoundedColoredAreas:
                if area.func == drawable:
                    areas.append(area)
                    
        elif isinstance(drawable, Segment):
            # Check SegmentsBoundedColoredArea
            for area in self.drawables.SegmentsBoundedColoredAreas:
                if area.uses_segment(drawable):
                    areas.append(area)

            # Check FunctionSegmentBoundedColoredArea
            for area in self.drawables.FunctionSegmentBoundedColoredAreas:
                if area.uses_segment(drawable):
                    areas.append(area)
                    
        return areas
        
    def update_colored_area_style(self, name, color=None, opacity=None):
        """
        Updates the color and/or opacity of a colored area
        
        Args:
            name: Name of the colored area to update
            color: New color (optional)
            opacity: New opacity (optional)
            
        Returns:
            bool: True if the area was updated, False otherwise
            
        Raises:
            ValueError: If the area doesn't exist or if color/opacity values are invalid
        """
        # First find the area
        area = None
        
        # Check in all colored area collections
        collections = [
            self.drawables.ColoredAreas,
            self.drawables.FunctionsBoundedColoredAreas,
            self.drawables.SegmentsBoundedColoredAreas,
            self.drawables.FunctionSegmentBoundedColoredAreas
        ]
        
        for collection in collections:
            for a in collection:
                if a.name == name:
                    area = a
                    break
            if area:
                break
                
        if not area:
            raise ValueError(f"Colored area '{name}' not found")
        
        # Archive before update
        self.canvas.undo_redo_manager.archive()
            
        # Validate color and opacity if provided
        if color is not None:
            if not StyleUtils.is_valid_css_color(color):
                raise ValueError(f"Invalid CSS color: {color}")
            area.color = color
            
        if opacity is not None:
            if not StyleUtils.validate_opacity(opacity):
                raise ValueError(f"Invalid opacity value: {opacity}. Must be between 0 and 1")
            area.opacity = opacity
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    # The transformation methods have been moved to TransformationsManager
    # def translate_object(self, name, x_offset, y_offset):
    #     ...
    # def rotate_object(self, name, angle):
    #     ... 