from drawables.point import Point
from drawables.segment import Segment
from drawables.vector import Vector
from drawables.triangle import Triangle
from drawables.rectangle import Rectangle
from drawables.circle import Circle
from drawables.ellipse import Ellipse
from drawables.function import Function
from drawables.functions_bounded_colored_area import FunctionsBoundedColoredArea
from drawables.segments_bounded_colored_area import SegmentsBoundedColoredArea
from drawables.function_segment_bounded_colored_area import FunctionSegmentBoundedColoredArea
from name_generator.drawable import DrawableNameGenerator
from utils.math_utils import MathUtils
from utils.style_utils import StyleUtils
from expression_validator import ExpressionValidator

class DrawableManager:
    """
    Manages drawable objects for a Canvas.
    
    This class is responsible for:
    - Creating drawable objects (points, segments, etc.)
    - Retrieving drawable objects by various criteria
    - Deleting drawable objects
    """
    
    def __init__(self, canvas):
        """
        Initialize the DrawableManager.
        
        Args:
            canvas: The Canvas object this manager is responsible for
        """
        self.canvas = canvas
        self.name_generator = DrawableNameGenerator(canvas)
        
    # ------------------- General Drawable Methods -------------------
    
    def get_drawables(self):
        """Get all drawables as a flat list"""
        all_drawables = []
        for drawable_type in self.canvas.drawables:
            all_drawables.extend(self.canvas.drawables[drawable_type])
        return all_drawables
    
    def get_drawables_by_class_name(self, class_name):
        """Get drawables of a specific class name"""
        return self.canvas.drawables.get(class_name, [])
    
    # ------------------- Point Methods -------------------
    
    def get_point(self, x, y):
        """Get a point at the specified coordinates"""
        points = self.canvas.drawables.get('Point', [])
        for point in points:
            if MathUtils.point_matches_coordinates(point, x, y):
                return point
        return None
        
    def get_point_by_name(self, name):
        """Get a point by its name"""
        points = self.canvas.drawables.get('Point', [])
        for point in points:
            if point.name == name:
                return point
        return None
        
    def create_point(self, x, y, name="", extra_graphics=True):
        """Create a point at the specified coordinates"""
        # Check if the point already exists
        existing_point = self.get_point(x, y)
        if existing_point:
            return existing_point
            
        # Generate a name if none is provided
        name = self.name_generator.generate_point_name(name)
            
        # Create the new point
        new_point = Point(x=x, y=y, canvas=self.canvas, name=name)
        
        # Add to drawables
        if 'Point' not in self.canvas.drawables:
            self.canvas.drawables['Point'] = []
        self.canvas.drawables['Point'].append(new_point)
        
        # Handle extra graphics - splits segments and creates connections
        if extra_graphics:
            self.canvas._split_segments_with_point(x, y)
            self.canvas._create_drawables_from_new_connections()
        
        # Draw the point if draw_enabled is True
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_point
        
    def delete_point(self, x, y):
        """Delete a point at the specified coordinates"""
        point = self.get_point(x, y)
        if not point:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        # Delete dependencies first
        self.canvas._delete_point_dependencies(x, y)
        
        # Now remove the point itself
        points = self.canvas.drawables.get('Point', [])
        if point in points:
            points.remove(point)
            
        # Redraw the canvas
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    def delete_point_by_name(self, name):
        """Delete a point by its name"""
        point = self.get_point_by_name(name)
        if not point:
            return False
            
        x, y = point.original_position.x, point.original_position.y
        return self.delete_point(x, y)
        
    def is_point_within_canvas_visible_area(self, x, y):
        """Check if a point is within the visible area of the canvas"""
        return (0 <= x <= self.canvas.width) and (0 <= y <= self.canvas.height)
    
    # ------------------- Segment Methods -------------------
    
    def get_segment_by_coordinates(self, x1, y1, x2, y2):
        """Get a segment by its endpoint coordinates"""
        segments = self.canvas.drawables.get('Segment', [])
        for segment in segments:
            if MathUtils.segment_matches_coordinates(segment, x1, y1, x2, y2):
                return segment
        return None
        
    def get_segment_by_name(self, name):
        """Get a segment by its name"""
        segments = self.canvas.drawables.get('Segment', [])
        for segment in segments:
            if segment.name == name:
                return segment
        return None
        
    def get_segment_by_points(self, p1, p2):
        """Get a segment by its endpoints"""
        return self.get_segment_by_coordinates(p1.original_position.x, p1.original_position.y, 
                                          p2.original_position.x, p2.original_position.y)
        
    def create_segment(self, x1, y1, x2, y2, name="", extra_graphics=True):
        """Create a segment between two points"""
        # Check if the segment already exists
        existing_segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if existing_segment:
            return existing_segment
            
        # Handle point names from segment name, if provided
        point_names = ["", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 2)
            
        # Create or get the endpoints with proper names
        p1 = self.create_point(x1, y1, name=point_names[0], extra_graphics=False)
        p2 = self.create_point(x2, y2, name=point_names[1], extra_graphics=False)
            
        # Create the new segment
        new_segment = Segment(p1, p2, canvas=self.canvas)
        
        # Add to drawables
        if 'Segment' not in self.canvas.drawables:
            self.canvas.drawables['Segment'] = []
        self.canvas.drawables['Segment'].append(new_segment)
        
        if extra_graphics and self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_segment
        
    def delete_segment(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        """Delete a segment by its endpoint coordinates"""
        segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if not segment:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        print(f"Deleting segment {segment.name}")
        
        # First delete any colored areas using this segment
        self.canvas.delete_colored_areas_for_segment(segment)
        
        # Delete dependencies
        self.canvas._delete_segment_dependencies(x1, y1, x2, y2, delete_children, delete_parents)
        
        # Remove the segment from its parents
        self.canvas._remove_segment_from_parents(segment)
        
        # Now remove the segment itself
        segments = self.canvas.drawables.get('Segment', [])
        if segment in segments:
            segments.remove(segment)
            
        # Redraw the canvas
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    def delete_segment_by_name(self, name, delete_children=True, delete_parents=False):
        """Delete a segment by its name"""
        segment = self.get_segment_by_name(name)
        if not segment:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        x1, y1 = segment.point1.original_position.x, segment.point1.original_position.y
        x2, y2 = segment.point2.original_position.x, segment.point2.original_position.y
        
        self.canvas._delete_segment_dependencies(x1, y1, x2, y2, delete_children, delete_parents)
        self.canvas._remove_segment_from_parents(segment)
        
        if 'Segment' in self.canvas.drawables:
            self.canvas.drawables['Segment'].remove(segment)
        
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    def any_segment_part_visible_in_canvas_area(self, x1, y1, x2, y2):
        """Check if any part of a segment is visible in the canvas area"""
        intersect_top = MathUtils.segments_intersect(x1, y1, x2, y2, 0, 0, self.canvas.width, 0)
        intersect_right = MathUtils.segments_intersect(x1, y1, x2, y2, self.canvas.width, 0, self.canvas.width, self.canvas.height)
        intersect_bottom = MathUtils.segments_intersect(x1, y1, x2, y2, self.canvas.width, self.canvas.height, 0, self.canvas.height)
        intersect_left = MathUtils.segments_intersect(x1, y1, x2, y2, 0, self.canvas.height, 0, 0)
        return intersect_top or intersect_right or intersect_bottom or intersect_left
    
    # ------------------- Vector Methods -------------------
    
    def get_vector(self, x1, y1, x2, y2):
        """Get a vector by its origin and tip coordinates"""
        vectors = self.canvas.drawables.get('Vector', [])
        for vector in vectors:
            if (MathUtils.point_matches_coordinates(vector.origin, x1, y1) and 
                MathUtils.point_matches_coordinates(vector.tip, x2, y2)):
                return vector
        return None
        
    def create_vector(self, origin_x, origin_y, tip_x, tip_y, name="", extra_graphics=True):
        """Create a vector from origin to tip"""
        # Check if the vector already exists
        existing_vector = self.get_vector(origin_x, origin_y, tip_x, tip_y)
        if existing_vector:
            return existing_vector
            
        # Extract point names from vector name
        point_names = ["", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 2)
        
        # Create or get the origin and tip points
        origin = self.create_point(origin_x, origin_y, name=point_names[0], extra_graphics=False)
        tip = self.create_point(tip_x, tip_y, name=point_names[1], extra_graphics=False)
        
        # Create the new vector
        new_vector = Vector(origin, tip, canvas=self.canvas)
        
        # Add to drawables
        if 'Vector' not in self.canvas.drawables:
            self.canvas.drawables['Vector'] = []
        self.canvas.drawables['Vector'].append(new_vector)
        
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_vector
        
    def delete_vector(self, origin_x, origin_y, tip_x, tip_y):
        """Delete a vector by its origin and tip coordinates"""
        vector = self.get_vector(origin_x, origin_y, tip_x, tip_y)
        if not vector:
            return False
            
        # Remove the vector
        vectors = self.canvas.drawables.get('Vector', [])
        if vector in vectors:
            vectors.remove(vector)
            
        # Redraw the canvas
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Triangle Methods -------------------
    
    def get_triangle(self, x1, y1, x2, y2, x3, y3):
        """Get a triangle by its vertex coordinates"""
        triangles = self.canvas.drawables.get('Triangle', [])
        for triangle in triangles.copy():
            if all(MathUtils.segment_matches_coordinates(segment, x1, y1, x2, y2) or
                   MathUtils.segment_matches_coordinates(segment, x1, y1, x3, y3) or
                   MathUtils.segment_matches_coordinates(segment, x2, y2, x3, y3) 
                   for segment in [triangle.segment1, triangle.segment2, triangle.segment3]):
                return triangle
        return None
        
    def create_triangle(self, x1, y1, x2, y2, x3, y3, name="", extra_graphics=True):
        """Create a triangle with the specified vertices"""
        # Check if the triangle already exists
        existing_triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if existing_triangle:
            return existing_triangle
            
        # Extract point names from triangle name
        point_names = ["", "", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 3)
        
        # Create points first with the correct names
        p1 = self.create_point(x1, y1, name=point_names[0], extra_graphics=False)
        p2 = self.create_point(x2, y2, name=point_names[1], extra_graphics=False)
        p3 = self.create_point(x3, y3, name=point_names[2], extra_graphics=False)
        
        # Create segments using the points
        s1 = self.create_segment(p1.original_position.x, p1.original_position.y, 
                               p2.original_position.x, p2.original_position.y, 
                               extra_graphics=False)
        s2 = self.create_segment(p2.original_position.x, p2.original_position.y, 
                               p3.original_position.x, p3.original_position.y, 
                               extra_graphics=False)
        s3 = self.create_segment(p3.original_position.x, p3.original_position.y, 
                               p1.original_position.x, p1.original_position.y, 
                               extra_graphics=False)
                               
        # Create the new triangle
        new_triangle = Triangle(s1, s2, s3, canvas=self.canvas)
        
        # Add to drawables
        if 'Triangle' not in self.canvas.drawables:
            self.canvas.drawables['Triangle'] = []
        self.canvas.drawables['Triangle'].append(new_triangle)
        
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_triangle
        
    def delete_triangle(self, x1, y1, x2, y2, x3, y3):     
        """Delete a triangle by its vertex coordinates"""
        triangle = self.get_triangle(x1, y1, x2, y2, x3, y3)
        if not triangle:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        if 'Triangle' in self.canvas.drawables and triangle in self.canvas.drawables['Triangle']:
            self.canvas.drawables['Triangle'].remove(triangle)
            
        self.delete_segment(x1, y1, x2, y2)
        self.delete_segment(x2, y2, x3, y3)
        self.delete_segment(x3, y3, x1, y1)
        
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # Methods for Function objects
    def get_function(self, name):
        """Get a function by its name"""
        functions = self.canvas.drawables.get('Function', [])
        for function in functions:
            if function.name == name:
                return function
        return None
        
    def draw_function(self, function_string, name, left_bound=None, right_bound=None):
        """Draw a function on the canvas"""
        # Check if a function with the given name already exists
        existing_function = self.get_function(name)
        if existing_function:
            # If it exists, update its expression
            try:
                existing_function.function_string = ExpressionValidator.fix_math_expression(function_string)
                existing_function.function = ExpressionValidator.parse_function_string(function_string, use_mathjs=False)
            except Exception as e:
                raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
            # Update the bounds
            existing_function.left_bound = left_bound
            existing_function.right_bound = right_bound
            
            if self.canvas.draw_enabled:
                self.canvas.draw()
            return existing_function
        else:
            name = self.name_generator.generate_function_name(name)
            function = Function(function_string, self.canvas, name=name, left_bound=left_bound, right_bound=right_bound)
            self.canvas.add_drawable(function)
            
            if self.canvas.draw_enabled:
                self.canvas.draw()
            return function
        
    def delete_function(self, name):
        """Delete a function by its name"""
        function = self.get_function(name)
        if not function:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        # Remove the function
        functions = self.canvas.drawables.get('Function', [])
        if function in functions:
            functions.remove(function)
            
        # Also delete any colored areas associated with this function
        self.canvas.delete_colored_areas_for_function(function)
        
        # Redraw the canvas
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Circle Methods -------------------
    
    def get_circle(self, center_x, center_y, radius):
        """Get a circle by its center coordinates and radius"""
        circles = self.canvas.drawables.get('Circle', [])
        for circle in circles:
            if circle.center.original_position.x == center_x and circle.center.original_position.y == center_y and circle.radius == radius:
                return circle
        return None
        
    def get_circle_by_name(self, name):
        """Get a circle by its name"""
        circles = self.canvas.drawables.get('Circle', [])
        for circle in circles:
            if circle.name == name:
                return circle
        return None
        
    def create_circle(self, center_x, center_y, radius, name="", extra_graphics=True):
        """Create a circle with the specified center and radius"""
        existing_circle = self.get_circle(center_x, center_y, radius)
        if existing_circle:
            return existing_circle
            
        # Extract point name from circle name
        point_names = self.name_generator.split_point_names(name, 1)
        
        # Create center point with the correct name
        center = self.create_point(center_x, center_y, point_names[0], extra_graphics=False)
        
        # Create the new circle
        new_circle = Circle(center, radius, canvas=self.canvas)
        
        # Add to drawables
        if 'Circle' not in self.canvas.drawables:
            self.canvas.drawables['Circle'] = []
        self.canvas.drawables['Circle'].append(new_circle)
        
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_circle
        
    def delete_circle(self, name):
        """Delete a circle by its name"""
        circle = self.get_circle_by_name(name)
        if not circle:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        # Remove the circle
        if 'Circle' in self.canvas.drawables:
            self.canvas.drawables['Circle'].remove(circle)
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Ellipse Methods -------------------
    
    def get_ellipse(self, center_x, center_y, radius_x, radius_y):
        """Get an ellipse by its center coordinates and radii"""
        ellipses = self.canvas.drawables.get('Ellipse', [])
        for ellipse in ellipses:
            if (ellipse.center.original_position.x == center_x and 
                ellipse.center.original_position.y == center_y and 
                ellipse.radius_x == radius_x and 
                ellipse.radius_y == radius_y):
                return ellipse
        return None
        
    def get_ellipse_by_name(self, name):
        """Get an ellipse by its name"""
        ellipses = self.canvas.drawables.get('Ellipse', [])
        for ellipse in ellipses:
            if ellipse.name == name:
                return ellipse
        return None
        
    def create_ellipse(self, center_x, center_y, radius_x, radius_y, rotation_angle=0, name="", extra_graphics=True):
        """Create an ellipse with the specified center, radii, and rotation"""
        existing_ellipse = self.get_ellipse(center_x, center_y, radius_x, radius_y)
        if existing_ellipse:
            return existing_ellipse
            
        # Extract point name from ellipse name
        point_names = self.name_generator.split_point_names(name, 1)
        
        # Create center point with the correct name
        center = self.create_point(center_x, center_y, point_names[0], extra_graphics=False)
        
        # Create the new ellipse
        new_ellipse = Ellipse(center, radius_x, radius_y, canvas=self.canvas, rotation_angle=rotation_angle)
        
        # Add to drawables
        if 'Ellipse' not in self.canvas.drawables:
            self.canvas.drawables['Ellipse'] = []
        self.canvas.drawables['Ellipse'].append(new_ellipse)
        
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_ellipse
        
    def delete_ellipse(self, name):
        """Delete an ellipse by its name"""
        ellipse = self.get_ellipse_by_name(name)
        if not ellipse:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        # Remove the ellipse
        if 'Ellipse' in self.canvas.drawables:
            self.canvas.drawables['Ellipse'].remove(ellipse)
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Rectangle Methods -------------------
    
    def get_rectangle_by_diagonal_points(self, px, py, opposite_px, opposite_py):
        """Get a rectangle by its diagonal points"""
        rectangles = self.canvas.drawables.get('Rectangle', [])
        
        # Calculate the coordinates of the other two corners based on the diagonal points
        corner1 = (px, py)
        corner2 = (opposite_px, py)
        corner3 = (opposite_px, opposite_py)
        corner4 = (px, opposite_py)
        
        # Iterate over all rectangles
        for rectangle in rectangles:
            segments = [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]
            rectangle_corners = [(segment.point1.original_position.x, segment.point1.original_position.y) for segment in segments]
            
            # Ensuring all corners are matched, considering rectangles could be defined in any direction
            if all(corner in rectangle_corners for corner in [corner1, corner2, corner3, corner4]):
                return rectangle
                
        return None
        
    def get_rectangle_by_name(self, name):
        """Get a rectangle by its name"""
        rectangles = self.canvas.drawables.get('Rectangle', [])
        for rectangle in rectangles:
            if rectangle.name == name:
                return rectangle
        return None
        
    def create_rectangle(self, px, py, opposite_px, opposite_py, name="", extra_graphics=True):
        """Create a rectangle with the specified diagonal points"""
        # Check if the rectangle already exists
        existing_rectangle = self.get_rectangle_by_diagonal_points(px, py, opposite_px, opposite_py)
        if existing_rectangle:
            return existing_rectangle
            
        # Extract point names from rectangle name
        point_names = ["", "", "", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 4)
        
        # Create points first with the correct names
        p1 = self.create_point(px, py, name=point_names[0], extra_graphics=False)
        p2 = self.create_point(opposite_px, py, name=point_names[1], extra_graphics=False)
        p3 = self.create_point(opposite_px, opposite_py, name=point_names[2], extra_graphics=False)
        p4 = self.create_point(px, opposite_py, name=point_names[3], extra_graphics=False)
        
        # Create segments using the points
        s1 = self.create_segment(p1.original_position.x, p1.original_position.y, 
                               p2.original_position.x, p2.original_position.y, 
                               extra_graphics=False)
        s2 = self.create_segment(p2.original_position.x, p2.original_position.y, 
                               p3.original_position.x, p3.original_position.y, 
                               extra_graphics=False)
        s3 = self.create_segment(p3.original_position.x, p3.original_position.y, 
                               p4.original_position.x, p4.original_position.y, 
                               extra_graphics=False)
        s4 = self.create_segment(p4.original_position.x, p4.original_position.y, 
                               p1.original_position.x, p1.original_position.y, 
                               extra_graphics=False)
                               
        # Create the rectangle with the segments
        new_rectangle = Rectangle(s1, s2, s3, s4, canvas=self.canvas)
        
        # Add to drawables
        if 'Rectangle' not in self.canvas.drawables:
            self.canvas.drawables['Rectangle'] = []
        self.canvas.drawables['Rectangle'].append(new_rectangle)
        
        if extra_graphics:
            self.canvas._create_drawables_from_new_connections()
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return new_rectangle
        
    def delete_rectangle(self, name):
        """Delete a rectangle by its name"""
        rectangle = self.get_rectangle_by_name(name)
        if not rectangle:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
            
        # Remove the rectangle
        if 'Rectangle' in self.canvas.drawables:
            self.canvas.drawables['Rectangle'].remove(rectangle)
            
        # Delete all 4 segments
        self.delete_segment(rectangle.segment1.point1.original_position.x, rectangle.segment1.point1.original_position.y, 
                           rectangle.segment1.point2.original_position.x, rectangle.segment1.point2.original_position.y)
        self.delete_segment(rectangle.segment2.point1.original_position.x, rectangle.segment2.point1.original_position.y, 
                           rectangle.segment2.point2.original_position.x, rectangle.segment2.point2.original_position.y)
        self.delete_segment(rectangle.segment3.point1.original_position.x, rectangle.segment3.point1.original_position.y, 
                           rectangle.segment3.point2.original_position.x, rectangle.segment3.point2.original_position.y)
        self.delete_segment(rectangle.segment4.point1.original_position.x, rectangle.segment4.point1.original_position.y, 
                           rectangle.segment4.point2.original_position.x, rectangle.segment4.point2.original_position.y)
        
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
    
    # ------------------- Colored Area Methods -------------------
    
    def create_colored_area(self, drawable1_name, drawable2_name=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3):
        """
        Creates a colored area between two functions, two segments, or a function and a segment.
        Automatically determines the type of colored area based on the inputs.
        
        Args:
            drawable1_name: Name of first function/segment (or None for x-axis)
            drawable2_name: Name of second function/segment (or None for x-axis)
            left_bound: Optional left bound for function areas
            right_bound: Optional right bound for function areas
            color: Color of the area (default: lightblue)
            opacity: Opacity of the area (default: 0.3)
            
        Returns:
            The created colored area object
            
        Raises:
            ValueError: If color or opacity values are invalid or if drawables not found
        """
        # Validate color and opacity before proceeding
        self.canvas._validate_color_and_opacity(color, opacity)
        
        # Archive for undo
        self.canvas.undo_redo_manager.archive()
        
        # Get the first drawable
        drawable1 = None
        if drawable1_name is not None and drawable1_name != "x_axis":
            drawable1 = self.get_segment_by_name(drawable1_name)
            if drawable1 is None:
                drawable1 = self.get_function(drawable1_name)
            if drawable1 is None:
                raise ValueError(f"Could not find drawable with name {drawable1_name}")
        
        # Get the second drawable if provided
        drawable2 = None
        if drawable2_name is not None and drawable2_name != "x_axis":
            drawable2 = self.get_segment_by_name(drawable2_name)
            if drawable2 is None:
                drawable2 = self.get_function(drawable2_name)
            if drawable2 is None:
                raise ValueError(f"Could not find drawable with name {drawable2_name}")
        
        if isinstance(drawable1, Segment):
            if drawable2 is not None and not isinstance(drawable2, Segment):
                if isinstance(drawable2, (Function, type(None))) or isinstance(drawable2, (int, float)):
                    # If drawable1 is a segment and drawable2 is a function/None/number, swap them
                    drawable1, drawable2 = drawable2, drawable1
                else:
                    raise ValueError("Invalid combination of arguments")

        if isinstance(drawable1, Segment) and (drawable2 is None or isinstance(drawable2, Segment)):
            # Segment-segment or segment-xaxis case
            if drawable2:  # Segment-segment case
                # Create points at overlap boundaries
                def get_y_at_x(segment, x):
                    # Linear interpolation to find y value at x using original coordinates
                    x1, y1 = segment.point1.original_position.x, segment.point1.original_position.y
                    x2, y2 = segment.point2.original_position.x, segment.point2.original_position.y
                    if x2 == x1:
                        return y1  # Vertical segment
                    t = (x - x1) / (x2 - x1)
                    return y1 + t * (y2 - y1)

                # Get x-ranges of both segments using original coordinates
                x1_min = min(drawable1.point1.original_position.x, drawable1.point2.original_position.x)
                x1_max = max(drawable1.point1.original_position.x, drawable1.point2.original_position.x)
                x2_min = min(drawable2.point1.original_position.x, drawable2.point2.original_position.x)
                x2_max = max(drawable2.point1.original_position.x, drawable2.point2.original_position.x)

                # Check if segment1 endpoints create points on segment2
                if x1_min >= x2_min and x1_min <= x2_max:
                    y = get_y_at_x(drawable2, x1_min)
                    self.create_point(x1_min, y)
                if x1_max >= x2_min and x1_max <= x2_max:
                    y = get_y_at_x(drawable2, x1_max)
                    self.create_point(x1_max, y)

                # Check if segment2 endpoints create points on segment1
                if x2_min >= x1_min and x2_min <= x1_max:
                    y = get_y_at_x(drawable1, x2_min)
                    self.create_point(x2_min, y)
                if x2_max >= x1_min and x2_max <= x1_max:
                    y = get_y_at_x(drawable1, x2_max)
                    self.create_point(x2_max, y)

            colored_area = SegmentsBoundedColoredArea(drawable1, drawable2, canvas=self.canvas, color=color, opacity=opacity)
        elif isinstance(drawable2, Segment):
            # Function-segment case (we know drawable1 is not a segment due to the swap above)
            colored_area = FunctionSegmentBoundedColoredArea(drawable1, drawable2, canvas=self.canvas, color=color, opacity=opacity)
        else:
            # Function-function case
            colored_area = FunctionsBoundedColoredArea(drawable1, drawable2, canvas=self.canvas, 
                                                     left_bound=left_bound, right_bound=right_bound,
                                                     color=color, opacity=opacity)

        # Add to drawables
        category = colored_area.get_class_name()
        if category not in self.canvas.drawables:
            self.canvas.drawables[category] = []
        self.canvas.drawables[category].append(colored_area)
        
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return colored_area
        
    def delete_colored_area(self, name):
        """
        Deletes a colored area with the given name
        
        Args:
            name: Name of the colored area to delete
            
        Returns:
            bool: True if the area was deleted, False otherwise
            
        Raises:
            ValueError: If the area doesn't exist
        """
        # First check if the area exists
        area_found = False
        for category in ['FunctionsBoundedColoredArea', 'SegmentsBoundedColoredArea', 'FunctionSegmentBoundedColoredArea']:
            colored_areas = self.canvas.drawables.get(category, [])
            for area in colored_areas:
                if area.name == name:
                    area_found = True
                    break
            if area_found:
                break
                
        if not area_found:
            raise ValueError(f"Colored area '{name}' not found")
            
        # Archive for undo
        self.canvas.undo_redo_manager.archive()
        
        # Now delete the area
        for category in ['FunctionsBoundedColoredArea', 'SegmentsBoundedColoredArea', 'FunctionSegmentBoundedColoredArea']:
            colored_areas = self.canvas.drawables.get(category, [])
            for area in colored_areas:
                if area.name == name:
                    self.canvas.drawables[category].remove(area)
                    
                    if self.canvas.draw_enabled:
                        self.canvas.draw()
                        
                    return True
                    
        return False
        
    def delete_colored_areas_for_function(self, func):
        """
        Deletes all colored areas associated with a function
        
        Args:
            func: The function whose colored areas should be deleted
            
        Returns:
            bool: True if any areas were deleted, False otherwise
        """
        # First check if there are any areas to delete
        areas_to_delete = []
        
        # Check FunctionsBoundedColoredArea
        colored_areas = self.canvas.drawables.get('FunctionsBoundedColoredArea', [])
        for area in colored_areas:
            if area.func1 == func or area.func2 == func:
                areas_to_delete.append((area, 'FunctionsBoundedColoredArea'))

        # Check FunctionSegmentBoundedColoredArea
        colored_areas = self.canvas.drawables.get('FunctionSegmentBoundedColoredArea', [])
        for area in colored_areas:
            if area.func == func:
                areas_to_delete.append((area, 'FunctionSegmentBoundedColoredArea'))
        
        if areas_to_delete:
            # Archive for undo
            self.canvas.undo_redo_manager.archive()
            
            # Now delete the areas
            for area, category in areas_to_delete:
                self.canvas.drawables[category].remove(area)
                
            if self.canvas.draw_enabled:
                self.canvas.draw()
                
            return True
            
        return False
        
    def delete_colored_areas_for_segment(self, segment):
        """
        Deletes all colored areas associated with a segment
        
        Args:
            segment: The segment whose colored areas should be deleted
            
        Returns:
            bool: True if any areas were deleted, False otherwise
        """
        # First check if there are any areas to delete
        areas_to_delete = []
        
        # Check SegmentsBoundedColoredArea
        colored_areas = self.canvas.drawables.get('SegmentsBoundedColoredArea', [])
        for area in colored_areas:
            if area.uses_segment(segment):
                areas_to_delete.append((area, 'SegmentsBoundedColoredArea'))

        # Check FunctionSegmentBoundedColoredArea
        colored_areas = self.canvas.drawables.get('FunctionSegmentBoundedColoredArea', [])
        for area in colored_areas:
            if area.uses_segment(segment):
                areas_to_delete.append((area, 'FunctionSegmentBoundedColoredArea'))

        if areas_to_delete:
            # Archive for undo
            self.canvas.undo_redo_manager.archive()
            
            # Now delete the areas
            for area, category in areas_to_delete:
                self.canvas.drawables[category].remove(area)
                
            if self.canvas.draw_enabled:
                self.canvas.draw()
                
            return True
            
        return False
        
    def get_colored_areas_for_drawable(self, drawable):
        """
        Gets all colored areas associated with a drawable (function or segment)
        
        Args:
            drawable: The function or segment to find colored areas for
            
        Returns:
            list: List of colored areas that use the drawable
        """
        areas = []
        
        if isinstance(drawable, Function):
            # Check FunctionsBoundedColoredArea
            colored_areas = self.canvas.drawables.get('FunctionsBoundedColoredArea', [])
            for area in colored_areas:
                if area.func1 == drawable or area.func2 == drawable:
                    areas.append(area)

            # Check FunctionSegmentBoundedColoredArea
            colored_areas = self.canvas.drawables.get('FunctionSegmentBoundedColoredArea', [])
            for area in colored_areas:
                if area.func == drawable:
                    areas.append(area)
                    
        elif isinstance(drawable, Segment):
            # Check SegmentsBoundedColoredArea
            colored_areas = self.canvas.drawables.get('SegmentsBoundedColoredArea', [])
            for area in colored_areas:
                if area.uses_segment(drawable):
                    areas.append(area)

            # Check FunctionSegmentBoundedColoredArea
            colored_areas = self.canvas.drawables.get('FunctionSegmentBoundedColoredArea', [])
            for area in colored_areas:
                if area.uses_segment(drawable):
                    areas.append(area)
                    
        return areas
        
    def update_colored_area_style(self, name, color=None, opacity=None):
        """
        Updates the color and/or opacity of a colored area
        
        Args:
            name: Name of the colored area to update
            color: New color (optional)
            opacity: New opacity (optional)
            
        Returns:
            bool: True if the area was updated, False otherwise
            
        Raises:
            ValueError: If the area doesn't exist or if color/opacity values are invalid
        """
        # First find the area
        area = None
        for category in ['FunctionsBoundedColoredArea', 'SegmentsBoundedColoredArea', 'FunctionSegmentBoundedColoredArea']:
            colored_areas = self.canvas.drawables.get(category, [])
            for a in colored_areas:
                if a.name == name:
                    area = a
                    break
            if area:
                break
                
        if not area:
            raise ValueError(f"Colored area '{name}' not found")
            
        # Validate color and opacity if provided
        if color is not None:
            if not StyleUtils.is_valid_css_color(color):
                raise ValueError(f"Invalid CSS color: {color}")
            area.color = color
            
        if opacity is not None:
            if not StyleUtils.validate_opacity(opacity):
                raise ValueError(f"Invalid opacity value: {opacity}. Must be between 0 and 1")
            area.opacity = opacity
            
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    # The transformation methods have been moved to TransformationsManager
    # def translate_object(self, name, x_offset, y_offset):
    #     ...
    # def rotate_object(self, name, angle):
    #     ... 