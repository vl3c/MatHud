from drawables.segment import Segment
from utils.math_utils import MathUtils

class SegmentManager:
    """
    Manages segment drawables for a Canvas.
    
    This class is responsible for:
    - Creating segment objects
    - Retrieving segment objects by various criteria
    - Deleting segment objects
    """
    
    def __init__(self, canvas, drawables_container, name_generator, dependency_manager, point_manager, drawable_manager_proxy):
        """
        Initialize the SegmentManager.
        
        Args:
            canvas: The Canvas object this manager is responsible for
            drawables_container: The container for storing drawables
            name_generator: Generator for drawable names
            dependency_manager: Manager for drawable dependencies
            point_manager: Manager for point drawables
            drawable_manager_proxy: Proxy to the main DrawableManager
        """
        self.canvas = canvas
        self.drawables = drawables_container
        self.name_generator = name_generator
        self.dependency_manager = dependency_manager
        self.point_manager = point_manager
        self.drawable_manager = drawable_manager_proxy
        
    def get_segment_by_coordinates(self, x1, y1, x2, y2):
        """Get a segment by its endpoint coordinates"""
        for segment in self.drawables.Segments:
            if MathUtils.segment_matches_coordinates(segment, x1, y1, x2, y2):
                return segment
        return None
        
    def get_segment_by_name(self, name):
        """Get a segment by its name"""
        for segment in self.drawables.Segments:
            if segment.name == name:
                return segment
        return None
        
    def get_segment_by_points(self, p1, p2):
        """Get a segment by its endpoint points"""
        return self.get_segment_by_coordinates(p1.original_position.x, p1.original_position.y, 
                                              p2.original_position.x, p2.original_position.y)
        
    def create_segment(self, x1, y1, x2, y2, name="", extra_graphics=True):
        """
        Create a new segment between the specified points
        
        Args:
            x1, y1: Coordinates of the first endpoint
            x2, y2: Coordinates of the second endpoint
            name: Optional name for the segment
            extra_graphics: Whether to create additional graphics
            
        Returns:
            Segment: The newly created segment
        """
        # Archive before creation
        self.canvas.undo_redo_manager.archive()
        
        # Check if the segment already exists
        existing_segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if existing_segment:
            return existing_segment
            
        # Handle point names from segment name, if provided
        point_names = ["", ""]
        if name:
            point_names = self.name_generator.split_point_names(name, 2)
            
        # Create or get the endpoints with proper names
        p1 = self.point_manager.create_point(x1, y1, name=point_names[0], extra_graphics=False)
        p2 = self.point_manager.create_point(x2, y2, name=point_names[1], extra_graphics=False)
            
        # Create the segment
        segment = Segment(p1, p2, self.canvas)
        
        # Add to drawables
        self.drawables.add(segment)
        
        # Register with dependency manager
        self.dependency_manager.analyze_drawable_for_dependencies(segment)
        
        # Handle extra graphics
        if extra_graphics:
            # Call the method on DrawableManager via the proxy
            self.drawable_manager.create_drawables_from_new_connections()
        
        # Draw the segment
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return segment
        
    def delete_segment(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        """
        Delete a segment by its endpoint coordinates
        
        Args:
            x1, y1: Coordinates of the first endpoint
            x2, y2: Coordinates of the second endpoint
            delete_children: Whether to delete child objects
            delete_parents: Whether to delete parent objects
            
        Returns:
            bool: True if the segment was deleted, False otherwise
        """
        segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if not segment:
            return False
            
        # Archive before deletion
        self.canvas.undo_redo_manager.archive()
        
        # Handle dependencies by calling the internal method
        self._delete_segment_dependencies(x1, y1, x2, y2, delete_children, delete_parents)
        
        # Now remove the segment itself
        removed = self.drawables.remove(segment)
        
        # Clean up dependency entries for this segment
        if removed:
            self.dependency_manager.remove_drawable(segment)
        
        # Redraw
        if self.canvas.draw_enabled:
            self.canvas.draw()
            
        return True
        
    def delete_segment_by_name(self, name, delete_children=True, delete_parents=False):
        """Delete a segment by its name"""
        segment = self.get_segment_by_name(name)
        if not segment:
            return False
        
        x1 = segment.point1.original_position.x
        y1 = segment.point1.original_position.y
        x2 = segment.point2.original_position.x
        y2 = segment.point2.original_position.y
        
        result = self.delete_segment(x1, y1, x2, y2, delete_children, delete_parents)
        return result

    def _delete_segment_dependencies(self, x1, y1, x2, y2, delete_children=True, delete_parents=False):
        segment = self.get_segment_by_coordinates(x1, y1, x2, y2)
        if not segment:
            return
        
        # Handle recursive deletion of children if requested
        if delete_children:
            children = self.dependency_manager.get_all_children(segment)
            print(f"Handling deletion of {len(children)} children for segment {segment.name}")
            for child in list(children): # Iterate over a copy
                if hasattr(child, 'point1') and hasattr(child, 'point2'):
                    # Recursively call delete_segment for the child
                    # Ensure we don't try to delete parents of the child in this recursive call
                    self.delete_segment(child.point1.original_position.x, child.point1.original_position.y,
                                          child.point2.original_position.x, child.point2.original_position.y,
                                          delete_children=True, delete_parents=False)
                else:
                    print(f"Warning: Child {child} of {segment.name} is not a segment, cannot recursively delete.")
            
        # Handle recursive deletion of parents if requested
        if delete_parents:
            parents_to_delete = self.dependency_manager.get_all_parents(segment) # Use get_all_parents here
            print(f"Handling deletion of {len(parents_to_delete)} parents for segment {segment.name}")
            for parent in list(parents_to_delete):
                if hasattr(parent, 'point1') and hasattr(parent, 'point2'):
                    # Recursively delete the parent segment and its children.
                    # Further parent deletion for 'segment' (the original one) is handled by the iteration over 'parents_to_delete'.
                    self.delete_segment(parent.point1.original_position.x, parent.point1.original_position.y,
                                          parent.point2.original_position.x, parent.point2.original_position.y,
                                          delete_children=True, delete_parents=False)
                else:
                    print(f"Warning: Parent {parent} of {segment.name} is not a segment, cannot recursively delete.")
                    
        # Delete the segment's vectors using the proxy
        self.drawable_manager.delete_vector(x1, y1, x2, y2)
        self.drawable_manager.delete_vector(x2, y2, x1, y1)
                    
        # Delete the rectangles that contain the segment
        rectangles = self.drawables.Rectangles
        for rectangle in rectangles.copy():
            if any(MathUtils.segment_matches_coordinates(s, x1, y1, x2, y2) for s in [rectangle.segment1, rectangle.segment2, rectangle.segment3, rectangle.segment4]):
                self.drawables.remove(rectangle) # Direct removal from container
              
        # Delete the triangles that contain the segment
        triangles = self.drawables.Triangles
        for triangle in triangles.copy():
            if any(MathUtils.segment_matches_coordinates(s, x1, y1, x2, y2) for s in [triangle.segment1, triangle.segment2, triangle.segment3]):
                self.drawables.remove(triangle) # Direct removal from container 

    def _split_segments_with_point(self, x, y):
        segments = self.drawables.Segments
        for segment in segments.copy():
            sp1, sp2 = segment.point1.original_position, segment.point2.original_position
            # If the new point is either of the segment's endpoints, we don't need to create new segments
            if (x, y) == (sp1.x, sp1.y) or (x, y) == (sp2.x, sp2.y):
                continue
            if MathUtils.is_point_on_segment(x, y, sp1.x, sp1.y, sp2.x, sp2.y):
                # Create new segments
                segment1 = self.create_segment(x, y, sp1.x, sp1.y, extra_graphics=False)
                segment2 = self.create_segment(x, y, sp2.x, sp2.y, extra_graphics=False)
                
                # Register the new segments as children of the original segment that was split
                if segment1:
                    # The original segment that was split is a direct parent of the new segment
                    self.dependency_manager.register_dependency(child=segment1, parent=segment)
                    # Propagate dependency to SEGMENT ancestors of the original segment
                    for ancestor in self.dependency_manager.get_all_parents(segment):
                        if hasattr(ancestor, 'get_class_name') and ancestor.get_class_name() == 'Segment':
                            self.dependency_manager.register_dependency(child=segment1, parent=ancestor)
                if segment2:
                    # The original segment that was split is a direct parent of the new segment
                    self.dependency_manager.register_dependency(child=segment2, parent=segment)
                    # Propagate dependency to SEGMENT ancestors of the original segment
                    for ancestor in self.dependency_manager.get_all_parents(segment):
                        if hasattr(ancestor, 'get_class_name') and ancestor.get_class_name() == 'Segment':
                            self.dependency_manager.register_dependency(child=segment2, parent=ancestor)