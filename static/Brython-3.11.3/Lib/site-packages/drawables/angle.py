from constants import default_color
from drawables.drawable import Drawable
import utils.math_utils as math_utils
from copy import deepcopy
import math

class Angle(Drawable):
    def __init__(self, segment1, segment2, canvas, color=default_color):
        """
        Initializes an Angle object from two segments.

        Args:
            segment1: The first Segment object.
            segment2: The second Segment object.
            canvas: The main canvas object.
            color (str, optional): Color for the angle representation.
        """
        if not self._segments_form_angle(segment1, segment2):
            raise ValueError("The segments do not form a valid angle (must share exactly one vertex and have distinct arms).")

        self.segment1 = segment1
        self.segment2 = segment2
        
        self.vertex_point = self._get_common_vertex(segment1, segment2)

        if not self.vertex_point: 
             raise ValueError("Segments do not share a common vertex (internal error after validation).")

        self.arm1_point = segment1.point1 if segment1.point1 != self.vertex_point else segment1.point2
        self.arm2_point = segment2.point1 if segment2.point1 != self.vertex_point else segment2.point2

        name = canvas.drawable_manager.name_generator.generate_angle_name_from_segments(
            segment1.name, segment2.name
        )
        
        super().__init__(name=name, color=color, canvas=canvas) 
        
        self.angle_degrees = None 
        self.arc_radius_ratio = 0.2 
        
        self._initialize()

    def _get_common_vertex(self, s1, s2):
        """Identifies and returns the common vertex point object between two segments."""
        if s1.point1 == s2.point1 or s1.point1 == s2.point2:
            return s1.point1
        if s1.point2 == s2.point1 or s1.point2 == s2.point2:
            return s1.point2
        return None

    def _segments_form_angle(self, s1, s2):
        """
        Validates if two segments can form an angle.
        They must share exactly one common point (vertex) and form distinct, non-degenerate arms.
        """
        if not s1 or not s2: return False # Segments must exist
        if not hasattr(s1, 'point1') or not hasattr(s1, 'point2') or \
           not hasattr(s2, 'point1') or not hasattr(s2, 'point2'):
            return False # Segments must have point attributes

        common_vertex_point_obj = self._get_common_vertex(s1, s2) # This returns a Point object or None
        if common_vertex_point_obj is None:
            return False # Segments do not share exactly one common vertex

        # Identify the Point objects for the arms
        arm1_point_obj = s1.point1 if s1.point1 != common_vertex_point_obj else s1.point2
        arm2_point_obj = s2.point1 if s2.point1 != common_vertex_point_obj else s2.point2
        
        return math_utils.MathUtils.are_points_valid_for_angle_geometry(
            (common_vertex_point_obj.x, common_vertex_point_obj.y),
            (arm1_point_obj.x, arm1_point_obj.y),
            (arm2_point_obj.x, arm2_point_obj.y)
        )

    def _initialize(self):
        """Calculates and stores the angle value using math_utils."""
        if not (self.vertex_point and self.arm1_point and self.arm2_point):
            self.angle_degrees = None
            return

        vertex_coords = (self.vertex_point.x, self.vertex_point.y)
        arm1_coords = (self.arm1_point.x, self.arm1_point.y)
        arm2_coords = (self.arm2_point.x, self.arm2_point.y)

        self.angle_degrees = math_utils.MathUtils.calculate_angle_degrees(
            vertex_coords, arm1_coords, arm2_coords
        )

    @property
    def canvas(self): 
        return self._canvas

    @canvas.setter
    def canvas(self, value):
        self._canvas = value
        if hasattr(self.segment1, 'canvas'): self.segment1.canvas = value
        if hasattr(self.segment2, 'canvas'): self.segment2.canvas = value

    def get_class_name(self):
        return 'Angle'

    def _get_drawing_references(self):
        """Returns coordinates of vertex, arm1 point, and arm2 point, or None if any are missing."""
        if not (self.vertex_point and self.arm1_point and self.arm2_point):
            return None
        return (
            self.vertex_point.x, self.vertex_point.y,
            self.arm1_point.x, self.arm1_point.y,
            self.arm2_point.x, self.arm2_point.y
        )

    def _calculate_arc_parameters(self, vx, vy, p1x, p1y, p2x, p2y):
        """Calculates all necessary parameters for drawing the SVG arc."""
        
        len_s1 = math.hypot(p1x - vx, p1y - vy) # Use math.hypot directly
        len_s2 = math.hypot(p2x - vx, p2y - vy) # Use math.hypot directly
        
        if len_s1 == 0 or len_s2 == 0: 
            return None

        arc_radius = min(len_s1, len_s2) * self.arc_radius_ratio
        if arc_radius < 1: arc_radius = 5 

        angle_v_p1_rad = math.atan2(p1y - vy, p1x - vx)
        angle_v_p2_rad = math.atan2(p2y - vy, p2x - vx)

        arc_start_x = vx + arc_radius * math.cos(angle_v_p1_rad)
        arc_start_y = vy + arc_radius * math.sin(angle_v_p1_rad)
        arc_end_x = vx + arc_radius * math.cos(angle_v_p2_rad)
        arc_end_y = vy + arc_radius * math.sin(angle_v_p2_rad)
        
        large_arc_flag = '1' if self.angle_degrees > 180 else '0'
        sweep_flag = '1' # Based on self.angle_degrees being CCW from arm1 to arm2

        return {
            "arc_radius": arc_radius,
            "angle_v_p1_rad": angle_v_p1_rad, # Needed for text positioning
            "path_d": f"M {arc_start_x} {arc_start_y} A {arc_radius} {arc_radius} 0 {large_arc_flag} {sweep_flag} {arc_end_x} {arc_end_y}"
        }

    def _create_arc_svg_element(self, path_d):
        """Creates the SVG path element for the arc."""
        attrs = {
            'd': path_d, 'stroke': self.color, 'stroke-width': '1.5', 'fill': 'none', 'class': 'angle-arc'
        }
        return self.create_svg_element('path', **attrs)

    def _create_text_svg_elements(self, vx, vy, arc_radius, angle_v_p1_rad):
        """Creates SVG text elements for the angle value and label."""
        text_elements = [] # This will collect the returned SVG elements, though they are also added to DOM.
        display_angle_rad = math.radians(self.angle_degrees) 
        text_angle_rad = angle_v_p1_rad + display_angle_rad / 2.0

        # Angle value text
        if self.angle_degrees is not None: 
            text_radius_factor = 0.6 
            text_x = vx + (arc_radius * text_radius_factor) * math.cos(text_angle_rad)
            text_y = vy + (arc_radius * text_radius_factor) * math.sin(text_angle_rad)
            angle_display_text = f"{self.angle_degrees:.1f}Â°"
            
            text_attrs = {
                'x': text_x, 'y': text_y, 'fill': self.color, 'font-size': '9',
                'text-anchor': 'middle', 'dominant-baseline': 'middle',
                'text_content': angle_display_text # Drawable.create_svg_element will handle this
            }
            text_elements.append(self.create_svg_element('text', **text_attrs))
        return text_elements

    def draw(self):
        """
        Generates and returns SVG elements for the angle arc and label.
        The elements are directly added to the SVG canvas by create_svg_element.
        """
        if self.angle_degrees is None: 
            return 

        coords = self._get_drawing_references()
        if not coords:
            return 
        vx, vy, p1x, p1y, p2x, p2y = coords

        arc_params = self._calculate_arc_parameters(vx, vy, p1x, p1y, p2x, p2y)
        if not arc_params:
            return 

        self._create_arc_svg_element(arc_params["path_d"])
        self._create_text_svg_elements(
            vx, vy, 
            arc_params["arc_radius"], 
            arc_params["angle_v_p1_rad"]
        )

    def get_state(self):
        """
        Returns a serializable dictionary of the angle's state.
        """
        return {
            "name": self.name, 
            "type": "angle",   
            "args": {
                "segment1_name": self.segment1.name,
                "segment2_name": self.segment2.name,
                "color": self.color 
            }
        }

    @classmethod 
    def from_state(cls, state_data, canvas):
        """
        Creates an Angle instance from a state dictionary.
        """
        args = state_data["args"]
        segment1 = canvas.drawable_manager.get_segment_by_name(args["segment1_name"])
        segment2 = canvas.drawable_manager.get_segment_by_name(args["segment2_name"])

        if not segment1 or not segment2:
            print(f"Error loading angle '{state_data.get('name')}': Could not find segments '{args['segment1_name']}' or '{args['segment2_name']}'.")
            return None 

        return cls(
            segment1=segment1, segment2=segment2, canvas=canvas,
            color=args.get("color", default_color)
        )

    def __deepcopy__(self, memo):
        if id(self) in memo: return memo[id(self)]
        
        new_angle = Angle(
            segment1=deepcopy(self.segment1, memo),
            segment2=deepcopy(self.segment2, memo),
            canvas=self.canvas, 
            color=self.color
        )
        memo[id(self)] = new_angle
        return new_angle

    def update_points_based_on_segments(self):
        """
        Re-evaluates vertex and arm points if segments might have changed.
        Then re-calculates the angle. Returns True if valid, False otherwise.
        """
        if not self._segments_form_angle(self.segment1, self.segment2):
            self.angle_degrees = None
            self.vertex_point = None
            self.arm1_point = None
            self.arm2_point = None
            return False

        self.vertex_point = self._get_common_vertex(self.segment1, self.segment2)
        self.arm1_point = self.segment1.point1 if self.segment1.point1 != self.vertex_point else self.segment1.point2
        self.arm2_point = self.segment2.point1 if self.segment2.point1 != self.vertex_point else self.segment2.point2
        
        self._initialize()
        return True 

    def pan(self):
        """Handles panning of the angle. Relies on underlying points being panned by the canvas."""
        # The angle's visual position is determined by its points.
        # If points are panned correctly, the angle will be redrawn correctly.
        pass

    def zoom(self):
        """Handles zooming of the angle. Relies on underlying points being zoomed by the canvas."""
        # Similar to pan, zooming is primarily handled by the points.
        pass

    def reset(self):
        """Resets the angle to its initial state based on its segments."""
        # The Drawable base class reset calls _initialize.
        # update_points_based_on_segments also calls _initialize and ensures points are current.
        self.update_points_based_on_segments() 