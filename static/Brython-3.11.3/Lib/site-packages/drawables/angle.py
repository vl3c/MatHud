from constants import point_label_font_size, \
    DEFAULT_ANGLE_COLOR, DEFAULT_ANGLE_ARC_SCREEN_RADIUS, DEFAULT_ANGLE_TEXT_ARC_RADIUS_FACTOR
from drawables.drawable import Drawable
import utils.math_utils as math_utils
from copy import deepcopy
import math

class Angle(Drawable):
    def __init__(self, segment1, segment2, canvas, color=DEFAULT_ANGLE_COLOR, is_reflex: bool = False):
        """
        Initializes an Angle object from two segments.

        Args:
            segment1: The first Segment object.
            segment2: The second Segment object.
            canvas: The main canvas object.
            color (str, optional): Color for the angle representation.
            is_reflex (bool, optional): False for inner/small angle, True for outer/reflex angle. Defaults to False.
        """
        if not self._segments_form_angle(segment1, segment2):
            raise ValueError("The segments do not form a valid angle (must share exactly one vertex and have distinct arms).")

        self.segment1 = segment1
        self.segment2 = segment2
        self.is_reflex = is_reflex
        
        self.vertex_point, self.arm1_point, self.arm2_point = self._extract_defining_points(self.segment1, self.segment2)

        # Name generation might need adjustment later if manager needs to distinguish reflex/non-reflex for same segments
        name_suffix = "_reflex" if self.is_reflex else ""
        base_name = canvas.drawable_manager.name_generator.generate_angle_name_from_segments(
            segment1.name, segment2.name
        )
        name = f"{base_name}{name_suffix}"
        
        super().__init__(name=name, color=color, canvas=canvas) 
        
        self.raw_angle_degrees = None # To store the fundamental CCW angle (0-360)
        self.angle_degrees = None     # To store the display angle (small or reflex)
        self.drawn_arc_radius = DEFAULT_ANGLE_ARC_SCREEN_RADIUS
        
        self._initialize()

    def _get_common_vertex(self, s1, s2):
        """Identifies and returns the common vertex point object between two segments."""
        if s1.point1 == s2.point1 or s1.point1 == s2.point2:
            return s1.point1
        if s1.point2 == s2.point1 or s1.point2 == s2.point2:
            return s1.point2
        return None

    def _segments_form_angle(self, s1, s2):
        """
        Validates if two segments can form an angle.
        They must share exactly one common point (vertex) and form distinct, non-degenerate arms.
        """
        if not s1 or not s2: return False # Segments must exist
        if not hasattr(s1, 'point1') or not hasattr(s1, 'point2') or \
           not hasattr(s2, 'point1') or not hasattr(s2, 'point2'):
            return False # Segments must have point attributes

        common_vertex_point_obj = self._get_common_vertex(s1, s2) # This returns a Point object or None
        if common_vertex_point_obj is None:
            return False # Segments do not share exactly one common vertex

        # Identify the Point objects for the arms
        arm1_point_obj = s1.point1 if s1.point1 != common_vertex_point_obj else s1.point2
        arm2_point_obj = s2.point1 if s2.point1 != common_vertex_point_obj else s2.point2
        
        return math_utils.MathUtils.are_points_valid_for_angle_geometry(
            (common_vertex_point_obj.x, common_vertex_point_obj.y),
            (arm1_point_obj.x, arm1_point_obj.y),
            (arm2_point_obj.x, arm2_point_obj.y)
        )

    def _extract_defining_points(self, s1, s2):
        """Extracts vertex, arm1, and arm2 points. Assumes segments form a valid angle."""
        vertex_p = self._get_common_vertex(s1, s2)
        # _segments_form_angle should have already ensured vertex_p is not None
        arm1_p = s1.point1 if s1.point1 != vertex_p else s1.point2
        arm2_p = s2.point1 if s2.point1 != vertex_p else s2.point2
        return vertex_p, arm1_p, arm2_p

    def _initialize(self):
        """Calculates angle degrees and ensures drawn_arc_radius is set to default."""
        if not (self.vertex_point and self.arm1_point and self.arm2_point):
            self.angle_degrees = None
            return

        # Use screen coordinates of points for angle calculation as points are dynamic
        vertex_coords = (self.vertex_point.x, self.vertex_point.y) 
        arm1_coords = (self.arm1_point.x, self.arm1_point.y)
        arm2_coords = (self.arm2_point.x, self.arm2_point.y)

        self.angle_degrees = math_utils.MathUtils.calculate_angle_degrees(
            vertex_coords, arm1_coords, arm2_coords
        )
        
        self.drawn_arc_radius = DEFAULT_ANGLE_ARC_SCREEN_RADIUS # Ensure fixed screen radius is set from constants

    @property
    def canvas(self): 
        return self._canvas

    @canvas.setter
    def canvas(self, value):
        self._canvas = value
        if hasattr(self.segment1, 'canvas'): self.segment1.canvas = value
        if hasattr(self.segment2, 'canvas'): self.segment2.canvas = value

    def get_class_name(self):
        return 'Angle'

    def _get_drawing_references(self):
        """Returns screen coordinates of vertex, arm1 point, and arm2 point, or None if any are missing."""
        if not (self.vertex_point and self.arm1_point and self.arm2_point):
            return None
        return (
            self.vertex_point.x, self.vertex_point.y, # These are screen coordinates from Point.x, Point.y
            self.arm1_point.x, self.arm1_point.y,
            self.arm2_point.x, self.arm2_point.y
        )

    def _calculate_arc_parameters(self, vx, vy, p1x, p1y, p2x, p2y):
        """
        Calculates SVG path parameters for the arc using screen coordinates for positioning
        and a fixed self.drawn_arc_radius for size.
        vx, vy, p1x, p1y, p2x, p2y are screen coordinates.
        """
        
        if (p1x == vx and p1y == vy) or (p2x == vx and p2y == vy):
            return None # Degenerate case for arm angle calculation

        current_arc_radius = self.drawn_arc_radius # This is now a fixed screen radius
        if current_arc_radius <= 0: 
             return None

        angle_v_p1_rad = math.atan2(p1y - vy, p1x - vx)
        angle_v_p2_rad = math.atan2(p2y - vy, p2x - vx)

        arc_start_x = vx + current_arc_radius * math.cos(angle_v_p1_rad)
        arc_start_y = vy + current_arc_radius * math.sin(angle_v_p1_rad)
        arc_end_x = vx + current_arc_radius * math.cos(angle_v_p2_rad)
        arc_end_y = vy + current_arc_radius * math.sin(angle_v_p2_rad)
        
        large_arc_flag = '1' if self.angle_degrees > 180 else '0'
        sweep_flag = '1' # Based on self.angle_degrees being CCW from arm1 to arm2

        return {
            "arc_radius_on_screen": current_arc_radius, # Pass this to text positioning
            "angle_v_p1_rad": angle_v_p1_rad, 
            "path_d": f"M {arc_start_x} {arc_start_y} A {current_arc_radius} {current_arc_radius} 0 {large_arc_flag} {sweep_flag} {arc_end_x} {arc_end_y}"
        }

    def _create_arc_svg_element(self, path_d):
        """Creates the SVG path element for the arc."""
        attrs = {
            'd': path_d, 'stroke': self.color, 'stroke-width': '1', 'fill': 'none', 'class': 'angle-arc'
        }
        return self.create_svg_element('path', **attrs)

    def _create_text_svg_elements(self, vx, vy, arc_radius_on_screen, angle_v_p1_rad):
        """Creates SVG text elements for the angle value."""
        text_elements = [] 
        display_angle_rad = math.radians(self.angle_degrees) 
        text_angle_rad = angle_v_p1_rad + display_angle_rad / 2.0

        # Angle value text
        if self.angle_degrees is not None: 
            # Use DEFAULT_ANGLE_TEXT_ARC_RADIUS_FACTOR for positioning text relative to the arc radius
            text_x = vx + (arc_radius_on_screen * DEFAULT_ANGLE_TEXT_ARC_RADIUS_FACTOR) * math.cos(text_angle_rad)
            text_y = vy + (arc_radius_on_screen * DEFAULT_ANGLE_TEXT_ARC_RADIUS_FACTOR) * math.sin(text_angle_rad)
            angle_display_text = f"{self.angle_degrees:.1f}Â°"
            
            text_attrs = {
                'x': text_x, 'y': text_y, 'fill': self.color, 'font-size': str(point_label_font_size),
                'text-anchor': 'middle', 'dominant-baseline': 'middle',
                'text_content': angle_display_text
            }
            text_elements.append(self.create_svg_element('text', **text_attrs))
        return text_elements

    def draw(self):
        """
        Generates and returns SVG elements for the angle arc and label.
        The elements are directly added to the SVG canvas by create_svg_element.
        """
        if self.angle_degrees is None: 
            return 

        coords = self._get_drawing_references()
        if not coords:
            return 
        vx, vy, p1x, p1y, p2x, p2y = coords

        arc_params = self._calculate_arc_parameters(vx, vy, p1x, p1y, p2x, p2y)
        if not arc_params:
            return 

        self._create_arc_svg_element(arc_params["path_d"])
        self._create_text_svg_elements(
            vx, vy, 
            arc_params["arc_radius_on_screen"], # Use the radius returned by _calculate_arc_parameters
            arc_params["angle_v_p1_rad"]
        )

    def get_state(self):
        """
        Returns a serializable dictionary of the angle's state.
        """
        return {
            "name": self.name, 
            "type": "angle",   
            "args": {
                "segment1_name": self.segment1.name,
                "segment2_name": self.segment2.name,
                "color": self.color,
                "is_reflex": self.is_reflex
            }
        }

    @classmethod 
    def from_state(cls, state_data, canvas):
        """
        Creates an Angle instance from a state dictionary.
        """
        args = state_data["args"]
        segment1 = canvas.drawable_manager.get_segment_by_name(args["segment1_name"])
        segment2 = canvas.drawable_manager.get_segment_by_name(args["segment2_name"])

        if not segment1 or not segment2:
            print(f"Error loading angle '{state_data.get('name')}': Could not find segments '{args['segment1_name']}' or '{args['segment2_name']}'.")
            return None 

        return cls(
            segment1=segment1, segment2=segment2, canvas=canvas,
            color=args.get("color", DEFAULT_ANGLE_COLOR),
            is_reflex=args.get("is_reflex", False)
        )

    def __deepcopy__(self, memo):
        if id(self) in memo: return memo[id(self)]
        
        new_angle = Angle(
            segment1=deepcopy(self.segment1, memo),
            segment2=deepcopy(self.segment2, memo),
            canvas=self.canvas, 
            color=self.color,
            is_reflex=self.is_reflex
        )
        memo[id(self)] = new_angle
        return new_angle

    def update_points_based_on_segments(self):
        """
        Re-evaluates vertex and arm points if segments might have changed.
        Then re-calculates the angle. Returns True if valid, False otherwise.
        """
        if not self._segments_form_angle(self.segment1, self.segment2):
            self.angle_degrees = None
            self.vertex_point = None
            self.arm1_point = None
            self.arm2_point = None
            return False

        # Re-extract defining points as segments might have changed their internal point references
        self.vertex_point, self.arm1_point, self.arm2_point = self._extract_defining_points(self.segment1, self.segment2)
        
        self._initialize() # This recalculates angle_degrees and ensures drawn_arc_radius is set
        return True 

    def pan(self):
        """Handles panning of the angle. Relies on underlying points being panned by the canvas."""
        # The angle's visual position is determined by its points.
        # If points are panned correctly, the angle will be redrawn correctly.
        pass

    def zoom(self):
        """Zooming does not change the screen size of the arc. Points are zoomed by the canvas."""
        pass # Arc radius is fixed on screen. Points are handled by their own zoom methods.

    def reset(self):
        """Resets the angle to its initial state based on its segments."""
        # The Drawable base class reset calls _initialize.
        # update_points_based_on_segments also calls _initialize and ensures points are current.
        self.update_points_based_on_segments() 