"""
MatHud Segments Bounded Colored Area

Represents a colored area bounded by line segments with support for segment-to-segment
and segment-to-axis area visualization.

Key Features:
    - Two-segment boundary definition with overlap detection
    - Support for segment vs. x-axis coloring (single segment case)
    - Automatic overlap region calculation for segment pairs
    - Linear interpolation for y-value calculation at any x-coordinate
    - Geometric validation and boundary enforcement

Geometric Capabilities:
    - Segment overlap detection and region calculation
    - Linear interpolation along segment boundaries
    - Coordinate space management for proper rendering
    - Boundary condition validation for geometric constraints
    - Segment intersection and containment testing

Advanced Features:
    - Intelligent name generation based on segment names
    - Segment matching utilities for dependency tracking
    - State serialization for persistence and undo/redo
    - Performance optimized path generation for linear boundaries
    - Robust geometric calculations with edge case handling

Segment Types Supported:
    - Line segments: Full linear interpolation between endpoints
    - X-axis boundaries: Automatic axis boundary generation (segment2=None)
    - Vertical segments: Special handling for vertical line segments

Boundary Management:
    - Automatic overlap detection between segment pairs
    - X-range calculation for segment boundaries
    - Geometric intersection analysis
    - Proper path ordering for closed area generation

Path Generation:
    - Linear interpolation for smooth segment boundaries
    - Forward and reverse path construction for closed areas
    - Overlap region calculation for valid area generation
    - Performance optimization for linear geometry

Dependencies:
    - drawables.colored_area: Base class for area visualization
    - drawables.segment: Segment objects for boundary definitions
    - copy: Deep copying capabilities for state management
"""

from drawables.colored_area import ColoredArea
from drawables.segment import Segment
import copy

class SegmentsBoundedColoredArea(ColoredArea):
    """
    Creates a colored area bounded by line segments with geometric overlap detection.
    
    This class creates a visual representation of the area between two line segments
    or between a segment and the x-axis, with customizable color and opacity.
    Handles geometric calculations for linear boundaries including overlap detection,
    interpolation, and proper path generation for visualization.
    
    The area is calculated by finding the overlap region between two segments
    and generating SVG paths using linear interpolation for smooth boundaries.
    Special handling is provided for segment-to-axis cases and vertical segments.
    
    Attributes:
        segment1 (Segment): The first bounding segment
        segment2 (Segment or None): The second bounding segment (None means x-axis)
        
    Segment Type Handling:
        - Line segments: Linear interpolation between endpoints
        - X-axis boundaries: Automatic projection to coordinate axis (segment2=None)
        - Vertical segments: Special case handling for vertical lines
        
    Geometric Features:
        - Overlap detection and region calculation
        - Linear interpolation for y-values at any x-coordinate
        - Boundary validation and geometric constraint enforcement
        - Path ordering for proper closed area generation
        
    Performance Features:
        - Optimized linear interpolation algorithms
        - Efficient overlap region calculation
        - Memory-efficient path generation
        - Fast geometric boundary detection
    """

    def __init__(self, segment1, segment2=None, canvas=None, color="lightblue", opacity=0.3):
        """
        Creates a colored area bounded by a segment and either another segment or the x-axis.
        
        Performs geometric analysis to determine overlap regions and generates
        appropriate boundaries for area visualization.
        
        Parameters:
        -----------
        segment1 : Segment
            The first bounding segment. Must be a valid Segment object.
        segment2 : Segment or None, optional
            The second bounding segment. If None, the area will be bounded 
            by segment1 and the x-axis. Default is None.
        canvas : Canvas, optional
            The canvas to draw on for coordinate system access.
        color : str, optional
            The fill color of the area. Default is "lightblue".
        opacity : float, optional
            The opacity of the fill (0.0 to 1.0). Default is 0.3.
            
        Notes:
        ------
        - When segment2 is None, creates area between segment1 and x-axis
        - When both segments provided, creates area in their overlap region
        - Automatically handles cases with no overlap (no area drawn)
        - Uses linear interpolation for smooth boundary calculation
        """
        name = self._generate_name(segment1, segment2)
        super().__init__(name=name, canvas=canvas, color=color, opacity=opacity)
        self.segment1 = segment1
        self.segment2 = segment2

    def _generate_name(self, segment1, segment2):
        """
        Generate a descriptive name for the colored area based on segment names.
        
        Creates a meaningful identifier that describes the relationship between
        the bounding segments for debugging and state management purposes.
        
        Parameters:
        -----------
        segment1 : Segment
            The first bounding segment.
        segment2 : Segment or None
            The second bounding segment (None indicates x-axis).
            
        Returns:
        --------
        str
            A descriptive name in the format "area_between_{name1}_and_{name2}".
        """
        s1_name = segment1.name if segment1 else 'x_axis'
        s2_name = segment2.name if segment2 else 'x_axis'
        return f"area_between_{s1_name}_and_{s2_name}"

    def get_class_name(self):
        """
        Get the class name for serialization and type identification purposes.
        
        Returns:
        --------
        str
            The name of this class: 'SegmentsBoundedColoredArea'.
        """
        return 'SegmentsBoundedColoredArea'

    def draw(self):
        """
        Draw the colored area between the segments on the canvas.
        
        Performs geometric analysis to determine the appropriate area to color:
        - For single segment (segment2=None): Creates area between segment and x-axis
        - For two segments: Creates area in the overlap region between segments
        
        Uses linear interpolation to calculate intermediate points and generates
        SVG paths for smooth area visualization. Automatically handles edge cases
        such as no overlap regions and vertical segments.
        
        Geometric Process:
        1. Determine overlap region (for two segments) or x-axis projection (single segment)
        2. Calculate boundary points using linear interpolation
        3. Generate forward and reverse paths for closed area
        4. Create SVG path using base class method
        
        Edge Cases Handled:
        - No overlap between segments (no area drawn)
        - Vertical segments (special interpolation)
        - Segments above/below x-axis (proper orientation)
        """
        if not self.segment2:
            # Handle segment-xaxis case as before
            points = [(self.segment1.point1.x, self.segment1.point1.y),
                     (self.segment1.point2.x, self.segment1.point2.y)]

            if self.segment1.point1.y > 0 and self.segment1.point2.y > 0:
                # Both points above x-axis, color below
                reverse_points = [(self.segment1.point2.x, self.canvas.cartesian2axis.origin.y),
                                (self.segment1.point1.x, self.canvas.cartesian2axis.origin.y)]
            else:
                # Both points below x-axis or crossing x-axis, color above
                reverse_points = [(self.segment1.point2.x, self.canvas.cartesian2axis.origin.y),
                                (self.segment1.point1.x, self.canvas.cartesian2axis.origin.y)]
        else:
            # Handle segment-segment case with vertical bounds
            # Get x-ranges of both segments
            x1_min = min(self.segment1.point1.x, self.segment1.point2.x)
            x1_max = max(self.segment1.point1.x, self.segment1.point2.x)
            x2_min = min(self.segment2.point1.x, self.segment2.point2.x)
            x2_max = max(self.segment2.point1.x, self.segment2.point2.x)

            # Find overlap range
            overlap_min = max(x1_min, x2_min)
            overlap_max = min(x1_max, x2_max)

            if overlap_max <= overlap_min:
                # No overlap, don't draw anything
                return

            def get_y_at_x(segment, x):
                # Linear interpolation to find y value at x
                x1, y1 = segment.point1.x, segment.point1.y
                x2, y2 = segment.point2.x, segment.point2.y
                if x2 == x1:
                    return y1  # Vertical segment
                t = (x - x1) / (x2 - x1)
                return y1 + t * (y2 - y1)

            # Create path points for the overlapping region
            y1_start = get_y_at_x(self.segment1, overlap_min)
            y1_end = get_y_at_x(self.segment1, overlap_max)
            y2_start = get_y_at_x(self.segment2, overlap_min)
            y2_end = get_y_at_x(self.segment2, overlap_max)

            # Forward path along segment1
            points = [(overlap_min, y1_start),
                     (overlap_max, y1_end)]

            # Reverse path along segment2
            reverse_points = [(overlap_max, y2_end),
                            (overlap_min, y2_start)]

        # Create SVG path using base class method
        self._create_svg_path(points, reverse_points)

    def uses_segment(self, segment):
        """
        Check if this colored area uses a specific segment for dependency tracking.
        
        Determines whether the provided segment matches either of the boundary
        segments used by this colored area. Used for dependency management
        and cleanup operations when segments are modified or deleted.
        
        Parameters:
        -----------
        segment : Segment
            The segment to check for usage.
            
        Returns:
        --------
        bool
            True if the segment is used as a boundary, False otherwise.
            
        Notes:
        ------
        Uses coordinate-based matching to determine segment equality,
        comparing both endpoints of each segment for exact matches.
        """
        def segments_match(s1, s2):
            return (s1.point1.x == s2.point1.x and 
                   s1.point1.y == s2.point1.y and
                   s1.point2.x == s2.point2.x and
                   s1.point2.y == s2.point2.y)

        return segments_match(self.segment1, segment) or (self.segment2 and segments_match(self.segment2, segment))

    def get_state(self):
        """
        Get the state of this object for serialization and persistence.
        
        Combines base class state with segments bounded area specific properties
        for complete state preservation during save/load and undo/redo operations.
        
        Returns:
        --------
        dict
            A dictionary containing the complete state of this object including:
            - Base colored area properties (name, color, opacity)
            - Segment boundary names for reconstruction
            - X-axis indicator for single segment cases
            
        Notes:
        ------
        Stores segment names rather than segment objects for serialization.
        X-axis boundary is indicated by "x_axis" string value.
        """
        state = super().get_state()
        state["args"].update({
            "segment1": self.segment1.name,
            "segment2": self.segment2.name if self.segment2 else "x_axis"
        })
        return state

    def __deepcopy__(self, memo):
        """
        Create a deep copy of this object for undo/redo functionality.
        
        Implements proper deep copying while maintaining segment references
        and canvas coordination. Ensures all object relationships are
        preserved during copy operations.
        
        Parameters:
        -----------
        memo : dict
            Dictionary of already copied objects to handle circular references.
            
        Returns:
        --------
        SegmentsBoundedColoredArea
            A deep copy of this object with proper segment and canvas references.
            
        Notes:
        ------
        - Segment objects are referenced, not copied (managed by segment lifecycle)
        - Canvas reference is preserved without copying
        - All styling properties are properly copied
        """
        if id(self) in memo:
            return memo[id(self)]
            
        # Create new instance using __init__
        new_area = SegmentsBoundedColoredArea(
            segment1=self.segment1,  # Segments will be properly deep copied by their own __deepcopy__
            segment2=self.segment2,
            canvas=self.canvas,  # Canvas reference is not deep copied
            color=self.color,
            opacity=self.opacity
        )
        memo[id(self)] = new_area
        return new_area 