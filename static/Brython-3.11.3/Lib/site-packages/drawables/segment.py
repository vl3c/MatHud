from constants import default_color
from copy import deepcopy
from drawables.drawable import Drawable
from drawables.position import Position
from math_util import MathUtil
import math


class Segment(Drawable):
    def __init__(self, p1, p2, canvas, color=default_color):
        self.point1 = p1
        self.point2 = p2
        self.line_formula = self._calculate_line_algebraic_formula()
        name = self.point1.name + self.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()
        self.children = set()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Segment'

    def _calculate_line_algebraic_formula(self):
        p1 = self.point1
        p2 = self.point2
        line_formula = MathUtil.get_line_formula(p1.original_position.x, p1.original_position.y, p2.original_position.x, p2.original_position.y)
        return line_formula

    def _any_segment_part_visible_in_canvas_area(self):
        p1 = self.point1
        p2 = self.point2
        return self.canvas.is_point_within_canvas_visible_area(p1.x, p1.y) or \
            self.canvas.is_point_within_canvas_visible_area(p2.x, p2.y) or \
            self.canvas.any_segment_part_visible_in_canvas_area(p1.x, p1.y, p2.x, p2.y)

    def is_visible(self):
        hidden_by_children = True if self.children else False
        return not hidden_by_children and self._any_segment_part_visible_in_canvas_area()

    def draw(self):
        if self.is_visible():
            x1, y1 = self.point1.x, self.point1.y
            x2, y2 = self.point2.x, self.point2.y
            self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
        # self.point1.zoom()
        # self.point2.zoom()
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        # self._translate(self.canvas.offset)
        
    def get_state(self):
        points_names = sorted([self.point1.name, self.point2.name])
        state = {"name": self.name, "args": {"p1": points_names[0], "p2": points_names[1], "line_formula": self.line_formula}}
        return state

    def __deepcopy__(self, memo):
        # Check if the segment has already been deep copied
        if id(self) in memo:
            return memo[id(self)]

        # Deepcopy points that define the segment
        new_p1 = deepcopy(self.point1, memo)
        new_p2 = deepcopy(self.point2, memo)
        # Create a new Segment instance with the copied points
        new_segment = Segment(new_p1, new_p2, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_segment

        # Handle children
        new_segment.children = set()
        for child in self.children:
            # Check if the child segment has already been deep copied
            if id(child) in memo:
                new_segment.children.add(memo[id(child)])
            else:
                # If not already deep copied, deep copy and store in memo
                copied_child = deepcopy(child, memo)
                memo[id(child)] = copied_child
                new_segment.children.add(copied_child)

        return new_segment

    def translate(self, x_offset, y_offset):
        self.point1.original_position.x += x_offset
        self.point1.original_position.y += y_offset
        self.point2.original_position.x += x_offset
        self.point2.original_position.y += y_offset
        self._initialize()

    def _get_midpoint(self):
        """Calculate the midpoint of the segment"""
        x = (self.point1.original_position.x + self.point2.original_position.x) / 2
        y = (self.point1.original_position.y + self.point2.original_position.y) / 2
        return (x, y)

    def _rotate_point_around_center(self, point, center_x, center_y, angle_rad):
        """Rotate a single point around a center by given angle in radians"""
        dx = point.original_position.x - center_x
        dy = point.original_position.y - center_y
        
        point.original_position.x = center_x + (dx * math.cos(angle_rad) - dy * math.sin(angle_rad))
        point.original_position.y = center_y + (dx * math.sin(angle_rad) + dy * math.cos(angle_rad))

    def rotate(self, angle):
        """Rotate the segment around its midpoint by the given angle in degrees"""
        # Get midpoint
        center_x, center_y = self._get_midpoint()
        
        # Convert angle to radians
        angle_rad = math.radians(angle)
        
        # Rotate both endpoints
        self._rotate_point_around_center(self.point1, center_x, center_y, angle_rad)
        self._rotate_point_around_center(self.point2, center_x, center_y, angle_rad)
        
        # Update line formula and initialize
        self.line_formula = self._calculate_line_algebraic_formula()
        self._initialize()
        
        # Return tuple (should_proceed, message) to match interface
        return True, None 