from drawable import Drawable
from config import default_color
from point import Position
import math

class Cartesian2Axis(Drawable):
    def __init__(self, canvas, color=default_color):
        self.name = "cartesian-2axis-system"
        self.width = canvas.width
        self.height = canvas.height
        self.origin = Position(canvas.center.x, canvas.center.y)  # initial placement on canvas
        self.default_tick_spacing = 100
        self.current_tick_spacing = 100  # Track the previous tick spacing to determine zoom level
        self.max_ticks = 10
        self.tick_size = 3
        self.tick_color = color
        self.tick_label_color = "grey"
        self.tick_label_font_size = 8
        self.grid_color = "lightgrey"
        super().__init__(name=self.name, color=color, canvas=canvas)

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def _initialize(self):
        pass   # Cartesian2Axis is not initialized
    
    def reset(self):
        self.origin.x = self.canvas.center.x
        self.origin.y = self.canvas.center.y
        self.current_tick_spacing = self.default_tick_spacing

    def get_class_name(self):
        return 'Cartesian2Axis'
    
    def get_visible_left_bound(self):
        # Calculate the visible left bound based on the origin and scale factor
        return -self.origin.x / self.canvas.scale_factor

    def get_visible_right_bound(self):
        # Calculate the visible right bound based on the origin, width of the canvas, and scale factor
        return (self.width - self.origin.x) / self.canvas.scale_factor

    def get_visible_top_bound(self):
        # Calculate the visible top bound based on the origin and scale factor
        return self.origin.y / self.canvas.scale_factor

    def get_visible_bottom_bound(self):
        # Calculate the visible bottom bound based on the origin, height of the canvas, and scale factor
        return (self.origin.y - self.height) / self.canvas.scale_factor

    def get_relative_width(self):
        return self.width / self.canvas.scale_factor
    
    def get_relative_height(self):
        return self.height / self.canvas.scale_factor

    def draw(self):
        # Draw axes
        self.create_svg_element('line', x1=str(0), y1=str(self.origin.y), x2=str(self.width), y2=str(self.origin.y), stroke=self.color)
        self.create_svg_element('line', x1=str(self.origin.x), y1=str(0), x2=str(self.origin.x), y2=str(self.height), stroke=self.color)
        # Add spaced ticks on the axes
        display_tick_spacing = self.current_tick_spacing * self.canvas.scale_factor
        # Draw ticks on axes
        self._draw_ticks(display_tick_spacing)
        # Draw grid
        self._draw_grid(display_tick_spacing / 2)

    def _draw_ticks(self, step):
        def draw_ticks(axis, step, direction):
            tick_mark = self.origin.x if axis == 'x' else self.origin.y
            boundary = self.width if axis == 'x' else self.height
            tick_size = self.tick_size
            go = lambda: (direction == 1 and tick_mark < boundary) or (direction == -1 and tick_mark > 0)
            while go():
                if axis == 'x':
                    self.create_svg_element('line', x1=str(tick_mark), y1=str(self.origin.y - tick_size), x2=str(tick_mark), y2=str(self.origin.y + tick_size), stroke=self.color)
                    tick_label_text = str(round((tick_mark - self.origin.x) / self.canvas.scale_factor, 2))
                    self.create_svg_element('text', x=str(tick_mark + 2), y=str(self.origin.y + tick_size + self.tick_label_font_size), fill=self.tick_label_color, text_content=tick_label_text, text_font_size=self.tick_label_font_size)
                else:
                    self.create_svg_element('line', x1=str(self.origin.x - tick_size), y1=str(tick_mark), x2=str(self.origin.x + tick_size), y2=str(tick_mark), stroke=self.color)
                    tick_label_text = str(round((self.origin.y - tick_mark) / self.canvas.scale_factor, 2))
                    self.create_svg_element('text', x=str(self.origin.x + tick_size), y=str(tick_mark - tick_size), fill=self.tick_label_color, text_content=tick_label_text, text_font_size=self.tick_label_font_size)
                tick_mark += step * direction
        for axis in ['x', 'y']:
            for direction in [-1, 1]:
                draw_ticks(axis, step, direction)

    def _draw_grid(self, step):
        def draw_grid_lines(axis, step, direction):
            grid_mark = self.origin.x if axis == 'x' else self.origin.y
            boundary = self.width if axis == 'x' else self.height
            go = lambda: (direction == 1 and grid_mark < boundary) or (direction == -1 and grid_mark > 0)

            while go():
                start_point = Position(0, grid_mark) if axis == 'y' else Position(grid_mark, 0)
                end_point = Position(self.width, grid_mark) if axis == 'y' else Position(grid_mark, self.height)
                self.create_svg_element('line', x1=str(start_point.x), y1=str(start_point.y), x2=str(end_point.x), y2=str(end_point.y), stroke=self.grid_color)
                grid_mark += step * direction
        for axis in ['x', 'y']:
            for direction in [-1, 1]:
                draw_grid_lines(axis, step, direction)

    def _translate(self, offset):
        self.origin._translate(offset)
   
    def _calculate_tick_spacing(self):
        relative_width = self.get_relative_width()  # Width of the visible cartesian system in units
        max_ticks = self.max_ticks  # 10
        ideal_tick_spacing = relative_width / max_ticks  # Ideal width of a tick spacing
        # Find the order of magnitude of the ideal_tick_spacing
        magnitude = 10 ** math.floor(math.log10(ideal_tick_spacing))
        possible_spacings = [magnitude * i for i in [1, 2.5, 5, 10]]      
        # Find the closest spacing to ideal_tick_spacing that is larger or equal to it
        for spacing in possible_spacings:
            if spacing >= ideal_tick_spacing:
                return spacing
        # If none of the spacings fit (very unlikely), fallback to the smallest spacing
        return possible_spacings[0]

    def zoom(self):
        # Calculate the new display tick spacing based on the current zoom level and scale factor
        proposed_tick_spacing = self._calculate_tick_spacing()

        # Determine whether to zoom in or out based on zoom_direction
        zoom_in = self.canvas.zoom_direction == -1
        if zoom_in:
            # Zooming in: Decrease the tick spacing if it's less than twice the current tick spacing
            if proposed_tick_spacing < self.current_tick_spacing / 0.5:
                self.current_tick_spacing = proposed_tick_spacing
        else:
            # Zooming out: Increase the tick spacing if it's greater than half the current tick spacing
            if proposed_tick_spacing > self.current_tick_spacing * 0.5:
                self.current_tick_spacing = proposed_tick_spacing

        self.origin.zoom()

    def pan(self):
        self._translate(self.canvas.offset)

    def get_state(self):
        pass  # not needed for this class