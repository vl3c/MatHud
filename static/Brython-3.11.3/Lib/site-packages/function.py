from constants import default_color, default_point_size, point_label_font_size
from drawable import Drawable
from position import Position
from expression_validator import ExpressionValidator
import math


class Function(Drawable):
    def __init__(self, function_string, canvas, name, step=default_point_size, color=default_color, left_bound=None, right_bound=None, vertical_asymptotes=None, horizontal_asymptotes=None):
        self.step = step
        self.left_bound = left_bound
        self.right_bound = right_bound
        try:
            self.function_string = ExpressionValidator.fix_math_expression(function_string)
            self.function = ExpressionValidator.parse_function_string(function_string)
            # Set asymptotes if provided, otherwise calculate them
            if vertical_asymptotes is not None:
                self.vertical_asymptotes = vertical_asymptotes
            if horizontal_asymptotes is not None:
                self.horizontal_asymptotes = horizontal_asymptotes
            if vertical_asymptotes is None and horizontal_asymptotes is None:
                self._calculate_asymptotes()
        except Exception as e:
            raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
        self._cached_points = None
        self._cache_valid = False
        self._last_scale = None
        self._last_bounds = None
        super().__init__(name=name, color=color, canvas=canvas)

    def _initialize(self):
        self._cached_points = None
        self._cache_valid = False
        self._last_scale = None
        self._last_bounds = None

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Function'

    def _scaled_to_original(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        original_x = (x - origin.x) / scale_factor
        original_y = (y - origin.y) / -scale_factor
        return Position(original_x, original_y)
    
    def _original_to_scaled(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        scaled_x = origin.x + x * scale_factor
        scaled_y = origin.y - y * scale_factor
        return Position(scaled_x, scaled_y)

    def _should_regenerate_points(self):
        current_scale = self.canvas.scale_factor
        current_bounds = (
            self.canvas.cartesian2axis.get_visible_left_bound(),
            self.canvas.cartesian2axis.get_visible_right_bound(),
            self.canvas.cartesian2axis.get_visible_top_bound(),
            self.canvas.cartesian2axis.get_visible_bottom_bound()
        )
        
        # First draw or bounds changed (panning)
        if (self._cached_points is None or 
            not self._cache_valid or 
            self._last_bounds != current_bounds):
            self._last_scale = current_scale
            self._last_bounds = current_bounds
            return True

        # Check if zoom change is significant enough
        if self._last_scale is not None:
            zoom_ratio = current_scale / self._last_scale
            # Only regenerate if zoom changed by more than 20% in either direction
            if zoom_ratio < 0.8 or zoom_ratio > 1.2:
                self._last_scale = current_scale
                self._last_bounds = current_bounds
                return True

        return False

    def _generate_values(self):
        visible_left = self.canvas.cartesian2axis.get_visible_left_bound()
        visible_right = self.canvas.cartesian2axis.get_visible_right_bound()
        
        # Clamp the bounds to visible area
        left_bound = max(visible_left, self.left_bound) if self.left_bound is not None else visible_left
        right_bound = min(visible_right, self.right_bound) if self.right_bound is not None else visible_right
        
        top_bound = self.canvas.cartesian2axis.get_visible_top_bound()
        bottom_bound = self.canvas.cartesian2axis.get_visible_bottom_bound()
        
        f = self.function
        points = []

        def evaluate_point(x, points, step):
            try:
                y = f(x)
                scaled_point = self._original_to_scaled(x, y)
                
                # If this is the first point, always include it
                if not points:
                    return scaled_point
                    
                # Get previous y value (use original, not scaled)
                prev_y = f(x - 2 * step)
                
                # Include points within bounds
                if bottom_bound <= y <= top_bound:
                    return scaled_point
                # Include the point if we just crossed a bound
                elif (prev_y <= top_bound and y > top_bound) or \
                    (prev_y >= bottom_bound and y < bottom_bound):
                    return scaled_point
                
                return None
            except (ZeroDivisionError, ValueError):
                return None

        def calculate_step_size():
            import re
            # Base step size depends on the visible range
            range_width = right_bound - left_bound
            base_step = range_width / 200  # Base 200 points across visible range
            
            # For trigonometric functions
            if 'sin' in self.function_string or 'cos' in self.function_string:
                # Extract frequency multiplier
                matches = re.findall(r'(?:sin|cos)\((\d+(?:\.\d+)?)\*?x\)', self.function_string)
                freq_multiplier = float(matches[0]) if matches else 1
                # Calculate period
                period = 2 * math.pi / freq_multiplier
                # Calculate how many periods are visible in the current range
                visible_periods = range_width / period
                
                if visible_periods <= 1:
                    # When zoomed into one period or less, use base_step for detail
                    return base_step
                else:
                    # Start with 200 points distributed across all visible periods
                    points_per_period = 400 / visible_periods
                    # Cap points per period to 200
                    points_per_period = min(200, points_per_period)
                    period_step = period / points_per_period
                    return period_step
                
            # For rapidly changing functions, adjust step size based on function type
            if any(pattern in self.function_string for pattern in ['x**2', 'x^2']):
                # Quadratic functions grow faster at the edges
                return base_step * 2  # Much smaller step size for quadratics
            
            return base_step

        step = calculate_step_size()
        x = left_bound
        last_point = None
        
        while x <= right_bound:
            point = evaluate_point(x, points, step)
            if point:
                # Add point if visibly different at current resolution
                pixel_diff = 0.5  # Reduced minimum pixel difference
                if not last_point or \
                   abs(point.x - last_point.x) > pixel_diff or \
                   abs(point.y - last_point.y) > pixel_diff:
                    points.append(point)
                    last_point = point
            x += step

        return points

    def draw(self):
        if self._should_regenerate_points():
            self._cached_points = self._generate_values()
            self._cache_valid = True
        
        points = self._cached_points
        if not points or len(points) < 2:
            return

        # Construct SVG path data with proper line connections
        path_d = "M" + " L".join(f"{p.x},{p.y}" for p in points)
        
        # Create SVG path element for the function
        self.create_svg_element('path', d=path_d, stroke=self.color, fill="none")
        
        # Draw function name label at first point
        label_offset_x = (1 + len(self.name)) * point_label_font_size / 2
        label_x = points[0].x - label_offset_x
        label_y = points[0].y
        self.create_svg_element('text', x=str(label_x), y=str(label_y), 
                              fill=self.color, text_content=self.name, 
                              text_font_size=point_label_font_size)

    def zoom(self):
        self._cache_valid = False
    
    def pan(self):
        self._cache_valid = False

    def get_state(self):
        function_string = self.function_string
        state = {
            "name": self.name, 
            "args": {
                "function_string": function_string,
                "left_bound": self.left_bound, 
                "right_bound": self.right_bound
            }
        }
        
        # Only include asymptotes lists that have values
        if hasattr(self, 'vertical_asymptotes') and self.vertical_asymptotes:
            state["args"]["vertical_asymptotes"] = self.vertical_asymptotes
        if hasattr(self, 'horizontal_asymptotes') and self.horizontal_asymptotes:
            state["args"]["horizontal_asymptotes"] = self.horizontal_asymptotes
            
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        new_function = Function(
            function_string=self.function_string,
            canvas=self.canvas,
            name=self.name,
            step=self.step,
            color=self.color,
            left_bound=self.left_bound,
            right_bound=self.right_bound,
            vertical_asymptotes=self.vertical_asymptotes.copy() if hasattr(self, 'vertical_asymptotes') else None,
            horizontal_asymptotes=self.horizontal_asymptotes.copy() if hasattr(self, 'horizontal_asymptotes') else None
        )
        new_function._cached_points = None
        new_function._cache_valid = False
        new_function._last_scale = None
        new_function._last_bounds = None
        memo[id(self)] = new_function
        return new_function

    def translate(self, x_offset, y_offset):
        if x_offset == 0 and y_offset == 0:
            return

        # Translate bounds if they exist
        if self.left_bound is not None:
            self.left_bound += x_offset
        if self.right_bound is not None:
            self.right_bound += x_offset

        try:
            # First handle horizontal translation by replacing x with (x - x_offset)
            if x_offset != 0:
                import re
                # Use all allowed functions from ExpressionValidator
                protected_funcs = sorted(ExpressionValidator.ALLOWED_FUNCTIONS, key=len, reverse=True)
                
                # Create a regex pattern that matches standalone x while protecting function names
                func_pattern = '|'.join(map(re.escape, protected_funcs))
                # Use word boundaries to match standalone 'x'
                pattern = rf'\b(x)\b|({func_pattern})'
                
                def replace_match(match):
                    if match.group(1):  # If it's a standalone 'x'
                        return f'(x - {x_offset})'
                    elif match.group(2):  # If it's a function name
                        return match.group(2)  # Return the function name unchanged
                    return match.group(0)
                    
                new_function_string = re.sub(pattern, replace_match, self.function_string)
            else:
                new_function_string = self.function_string

            # Then handle vertical translation by adding y_offset
            if y_offset != 0:
                new_function_string = f"({new_function_string}) + {y_offset}"

            # Update function string and parse new function
            self.function_string = ExpressionValidator.fix_math_expression(new_function_string)
            self.function = ExpressionValidator.parse_function_string(new_function_string)
            
            # Reset caches to force regeneration
            self._initialize()
            
        except Exception as e:
            print(f"Warning: Could not translate function: {str(e)}")
            # If translation fails, revert bounds
            if self.left_bound is not None:
                self.left_bound -= x_offset
            if self.right_bound is not None:
                self.right_bound -= x_offset

    def rotate(self, angle):
        pass 

    def _calculate_asymptotes(self):
        """Calculate vertical and horizontal asymptotes of the function"""
        from math_util import MathUtil
        
        # Calculate asymptotes using MathUtil
        self.vertical_asymptotes, self.horizontal_asymptotes = MathUtil.calculate_asymptotes(
            self.function_string,
            self.left_bound,
            self.right_bound
        )

    def has_asymptote_between_x(self, x1, x2):
        """Check if there is an asymptote between x1 and x2"""
        return any(x1 <= x <= x2 for x in self.vertical_asymptotes) 