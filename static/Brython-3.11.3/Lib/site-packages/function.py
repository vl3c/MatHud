from constants import default_color, default_point_size, point_label_font_size
from drawable import Drawable
from position import Position
from expression_validator import ExpressionValidator
import math


class Function(Drawable):
    def __init__(self, function_string, canvas, name, step=default_point_size, color=default_color, left_bound=None, right_bound=None, vertical_asymptotes=None, horizontal_asymptotes=None, point_discontinuities=None):
        self.step = step
        self.left_bound = left_bound
        self.right_bound = right_bound
        try:
            self.function_string = ExpressionValidator.fix_math_expression(function_string)
            self.function = ExpressionValidator.parse_function_string(function_string)
            # Set asymptotes and discontinuities if provided, otherwise calculate them
            if vertical_asymptotes is not None:
                self.vertical_asymptotes = vertical_asymptotes
            if horizontal_asymptotes is not None:
                self.horizontal_asymptotes = horizontal_asymptotes
            if point_discontinuities is not None:
                self.point_discontinuities = point_discontinuities
            if vertical_asymptotes is None and horizontal_asymptotes is None and point_discontinuities is None:
                self._calculate_asymptotes_and_discontinuities()
        except Exception as e:
            raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
        self._cached_paths = None
        self._cache_valid = False
        self._last_scale = None
        self._last_bounds = None
        super().__init__(name=name, color=color, canvas=canvas)

    def _initialize(self):
        self._cached_paths = None
        self._cache_valid = False
        self._last_scale = None
        self._last_bounds = None

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Function'

    def _scaled_to_original(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        original_x = (x - origin.x) / scale_factor
        original_y = (y - origin.y) / -scale_factor
        return Position(original_x, original_y)
    
    def _original_to_scaled(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        scaled_x = origin.x + x * scale_factor
        scaled_y = origin.y - y * scale_factor
        return Position(scaled_x, scaled_y)

    def _should_regenerate_paths(self):
        current_scale = self.canvas.scale_factor
        current_bounds = (
            self.canvas.cartesian2axis.get_visible_left_bound(),
            self.canvas.cartesian2axis.get_visible_right_bound(),
            self.canvas.cartesian2axis.get_visible_top_bound(),
            self.canvas.cartesian2axis.get_visible_bottom_bound()
        )
        
        # First draw or bounds changed (panning)
        if (self._cached_paths is None or 
            not self._cache_valid or 
            self._last_bounds != current_bounds):
            self._last_scale = current_scale
            self._last_bounds = current_bounds
            return True

        # Check if zoom change is significant enough
        if self._last_scale is not None:
            zoom_ratio = current_scale / self._last_scale
            # Only regenerate if zoom changed by more than 20% in either direction
            if zoom_ratio < 0.8 or zoom_ratio > 1.2:
                self._last_scale = current_scale
                self._last_bounds = current_bounds
                return True

        return False

    def _evaluate_point(self, x):
        '''Evaluate the function at x and return the scaled point and non-scaled y value'''
        try:
            y = self.function(x)
            scaled_point = self._original_to_scaled(x, y)
            return scaled_point, y
        except (ZeroDivisionError, ValueError):
            return None, None

    def _crossed_top_bound_upward(self, prev_scaled_y, scaled_y):
        top_bound = 0
        return prev_scaled_y >= top_bound and scaled_y < top_bound
    
    def _crossed_top_bound_downward(self, prev_scaled_y, scaled_y):
        top_bound = 0
        return prev_scaled_y <= top_bound and scaled_y > top_bound

    def _crossed_bottom_bound_downward(self, prev_scaled_y, scaled_y):
        bottom_bound = self.canvas.cartesian2axis.height
        return prev_scaled_y <= bottom_bound and scaled_y > bottom_bound
    
    def _crossed_bottom_bound_upward(self, prev_scaled_y, scaled_y):
        bottom_bound = self.canvas.cartesian2axis.height
        return prev_scaled_y >= bottom_bound and scaled_y < bottom_bound

    def _is_out_of_vertical_bounds(self, scaled_y):
        """Check if the scaled y coordinate is outside the canvas bounds"""
        # scaled y grows downwards
        top_bound = 0
        bottom_bound = self.canvas.cartesian2axis.height
        return scaled_y >= bottom_bound or scaled_y <= top_bound

    def _clamp_y_to_bound(self, unscaled_y):
        """Return a Position object at the vertical bound based on unscaled y value"""
        if unscaled_y > 0:
            return 0  # 0 is the top bound
        elif unscaled_y < 0:
            return self.canvas.cartesian2axis.height  # bottom bound
        else:
            return self.canvas.cartesian2axis.origin.y

    def _generate_paths(self):
        '''Generate paths for the function as a list of lists, each inner list is a continuous path of scaled points'''
        visible_left = self.canvas.cartesian2axis.get_visible_left_bound()
        visible_right = self.canvas.cartesian2axis.get_visible_right_bound()
        
        # Clamp the bounds to visible area
        left_bound = max(visible_left, self.left_bound) if self.left_bound is not None else visible_left
        right_bound = min(visible_right, self.right_bound) if self.right_bound is not None else visible_right
                
        paths = []  # List of lists, each inner list is a continuous path
        current_path = []  # Track current continuous path
        expect_asymptote_behind = False  # Flag to track if we just passed an asymptote

        def calculate_step_size():
            import re
            # Base step size depends on the visible range
            range_width = right_bound - left_bound
            base_step = range_width / 200  # Base 200 points across visible range
            
            # For trigonometric functions
            if 'sin' in self.function_string or 'cos' in self.function_string:
                # Extract frequency multiplier
                matches = re.findall(r'(?:sin|cos)\((\d+(?:\.\d+)?)\*?x\)', self.function_string)
                freq_multiplier = float(matches[0]) if matches else 1
                # Calculate period
                period = 2 * math.pi / freq_multiplier
                # Calculate how many periods are visible in the current range
                visible_periods = range_width / period
                
                if visible_periods <= 1:
                    # When zoomed into one period or less, use base_step for detail
                    return base_step
                else:
                    # Start with 200 points distributed across all visible periods
                    points_per_period = 400 / visible_periods
                    # Cap points per period to 200
                    points_per_period = min(200, points_per_period)
                    period_step = period / points_per_period
                    return period_step
                
            # For rapidly changing functions, adjust step size based on function type
            if any(pattern in self.function_string for pattern in ['x**2', 'x^2']):
                # Quadratic functions grow faster at the edges
                return base_step * 2  # Much smaller step size for quadratics
            
            return base_step

        step = calculate_step_size()

        x = left_bound
        while x <= right_bound + step:
            if x in self.point_discontinuities:
                x += step
                continue
            
            scaled_point, y = self._evaluate_point(x)

            if not scaled_point:
                x += step
                continue

            asymptote_x = self.get_vertical_asymptote_between_x(x, x + step)
            has_vertical_asymptote_in_front = asymptote_x is not None
            has_vertical_asymptote_behind = expect_asymptote_behind  # Use the flag instead of checking

            if has_vertical_asymptote_in_front:
                expect_asymptote_behind = True  # Set flag when we detect asymptote in front
                new_scaled_point, new_y = self._evaluate_point(asymptote_x - min(1e-3, step/10))  # Use tiny absolute epsilon
                if new_scaled_point:  # Only update if we get a valid point
                    scaled_point, y = new_scaled_point, new_y

            # Check if top or bottom screen visibility bound is crossed
            if has_vertical_asymptote_behind:
                # If we just passed an asymptote, evaluate at a point just after it
                asymptote_x = self.get_vertical_asymptote_between_x(x - step, x)
                if asymptote_x is not None:
                    neighbor_prev_scaled_point, _ = self._evaluate_point(asymptote_x + min(1e-3, step/10))  # Use tiny absolute epsilon
                expect_asymptote_behind = False
            else:
                neighbor_prev_scaled_point, _ = self._evaluate_point(x - step)

            if not neighbor_prev_scaled_point:
                x += step
                continue

            if x > left_bound:
                crosses_top_bound_upward = self._crossed_top_bound_upward(neighbor_prev_scaled_point.y, scaled_point.y)
                crosses_top_bound_downward = self._crossed_top_bound_downward(neighbor_prev_scaled_point.y, scaled_point.y)
                crosses_bottom_bound_downward = self._crossed_bottom_bound_downward(neighbor_prev_scaled_point.y, scaled_point.y)
                crosses_bottom_bound_upward = self._crossed_bottom_bound_upward(neighbor_prev_scaled_point.y, scaled_point.y)
                
                crossed_bound_onto_screen = crosses_top_bound_downward or crosses_bottom_bound_upward
                crossed_bound_off_screen = crosses_top_bound_upward or crosses_bottom_bound_downward

                if crossed_bound_onto_screen:
                    current_path.append(neighbor_prev_scaled_point) # Add previous off screen point
                    current_path.append(scaled_point)
                    x += step
                    continue

                if crossed_bound_off_screen:
                    current_path.append(scaled_point) # Add current off screen point and end path
                    paths.append(current_path)
                    current_path = []
                    x += step
                    continue

            if x > right_bound:
                break

            # Check if point is off screen and should be skipped after checking for asymptotes and bounds crossings
            if self._is_out_of_vertical_bounds(scaled_point.y):
                x += step
                continue

            # Usual case: add point if visibly different
            is_first_point = not current_path or not any(current_path)
            if is_first_point:
                current_path = [scaled_point]
                x += step
                continue

            pixel_diff = 1  # Minimum pixel difference
            visible_x_diff = abs(scaled_point.x - current_path[-1].x) > pixel_diff
            visible_y_diff = abs(scaled_point.y - current_path[-1].y) > pixel_diff
            visible_diff = visible_x_diff or visible_y_diff

            if visible_diff:
                current_path.append(scaled_point)

            x += step

        # Add any remaining path
        if current_path:
            paths.append(current_path)

        return paths

    def draw(self):
        if self._should_regenerate_paths():
            self._cached_paths = self._generate_paths()
            self._cache_valid = True
        
        paths = self._cached_paths
        if not paths or not any(len(path) >= 2 for path in paths):
            return

        # print("### Paths: ", [(path[0].x, path[-1].x) for path in paths])

        # Create separate SVG path element for each path
        for path in paths:
            if len(path) >= 2:  # Only draw paths with at least 2 points
                path_d = "M" + " L".join(f"{p.x},{p.y}" for p in path)
                self.create_svg_element('path', d=path_d, stroke=self.color, fill="none")
        
        # Draw function name label at first point of first path
        first_path = next((path for path in paths if path), [])
        if first_path:
            label_offset_x = (1 + len(self.name)) * point_label_font_size / 2
            label_x = first_path[0].x - label_offset_x
            label_y = max(first_path[0].y, point_label_font_size)
            self.create_svg_element('text', x=str(label_x), y=str(label_y), 
                                  fill=self.color, text_content=self.name, 
                                  text_font_size=point_label_font_size)

    def zoom(self):
        self._cache_valid = False
    
    def pan(self):
        self._cache_valid = False

    def get_state(self):
        function_string = self.function_string
        state = {
            "name": self.name, 
            "args": {
                "function_string": function_string,
                "left_bound": self.left_bound, 
                "right_bound": self.right_bound
            }
        }
        
        # Only include asymptotes and discontinuities lists that have values
        if hasattr(self, 'vertical_asymptotes') and self.vertical_asymptotes:
            state["args"]["vertical_asymptotes"] = self.vertical_asymptotes
        if hasattr(self, 'horizontal_asymptotes') and self.horizontal_asymptotes:
            state["args"]["horizontal_asymptotes"] = self.horizontal_asymptotes
        if hasattr(self, 'point_discontinuities') and self.point_discontinuities:
            state["args"]["point_discontinuities"] = self.point_discontinuities
            
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        new_function = Function(
            function_string=self.function_string,
            canvas=self.canvas,
            name=self.name,
            step=self.step,
            color=self.color,
            left_bound=self.left_bound,
            right_bound=self.right_bound,
            vertical_asymptotes=self.vertical_asymptotes.copy() if hasattr(self, 'vertical_asymptotes') else None,
            horizontal_asymptotes=self.horizontal_asymptotes.copy() if hasattr(self, 'horizontal_asymptotes') else None,
            point_discontinuities=self.point_discontinuities.copy() if hasattr(self, 'point_discontinuities') else None
        )
        new_function._cached_paths = None
        new_function._cache_valid = False
        new_function._last_scale = None
        new_function._last_bounds = None
        memo[id(self)] = new_function
        return new_function

    def translate(self, x_offset, y_offset):
        if x_offset == 0 and y_offset == 0:
            return

        # Translate bounds if they exist
        if self.left_bound is not None:
            self.left_bound += x_offset
        if self.right_bound is not None:
            self.right_bound += x_offset

        try:
            # First handle horizontal translation by replacing x with (x - x_offset)
            if x_offset != 0:
                import re
                # Use all allowed functions from ExpressionValidator
                protected_funcs = sorted(ExpressionValidator.ALLOWED_FUNCTIONS, key=len, reverse=True)
                
                # Create a regex pattern that matches standalone x while protecting function names
                func_pattern = '|'.join(map(re.escape, protected_funcs))
                # Use word boundaries to match standalone 'x'
                pattern = rf'\b(x)\b|({func_pattern})'
                
                def replace_match(match):
                    if match.group(1):  # If it's a standalone 'x'
                        return f'(x - {x_offset})'
                    elif match.group(2):  # If it's a function name
                        return match.group(2)  # Return the function name unchanged
                    return match.group(0)
                    
                new_function_string = re.sub(pattern, replace_match, self.function_string)
            else:
                new_function_string = self.function_string

            # Then handle vertical translation by adding y_offset
            if y_offset != 0:
                new_function_string = f"({new_function_string}) + {y_offset}"

            # Update function string and parse new function
            self.function_string = ExpressionValidator.fix_math_expression(new_function_string)
            self.function = ExpressionValidator.parse_function_string(new_function_string)
            
            # Reset caches to force regeneration
            self._initialize()
            
        except Exception as e:
            print(f"Warning: Could not translate function: {str(e)}")
            # If translation fails, revert bounds
            if self.left_bound is not None:
                self.left_bound -= x_offset
            if self.right_bound is not None:
                self.right_bound -= x_offset

    def rotate(self, angle):
        pass 

    def _calculate_asymptotes_and_discontinuities(self):
        """Calculate vertical and horizontal asymptotes and point discontinuities of the function"""
        from math_util import MathUtil
        
        # Calculate asymptotes and discontinuities using MathUtil
        self.vertical_asymptotes, self.horizontal_asymptotes, self.point_discontinuities = MathUtil.calculate_asymptotes_and_discontinuities(
            self.function_string,
            self.left_bound,
            self.right_bound
        )

    def has_point_discontinuity_between_x(self, x1, x2):
        """Check if there is a point discontinuity between x1 and x2"""
        return (hasattr(self, 'point_discontinuities') and any(x1 < x < x2 for x in self.point_discontinuities))
    
    def has_vertical_asymptote_between_x(self, x1, x2):
        """Check if there is a vertical asymptote between x1 and x2"""
        return (hasattr(self, 'vertical_asymptotes') and any(x1 <= x < x2 for x in self.vertical_asymptotes))

    def get_vertical_asymptote_between_x(self, x1, x2):
        """Get the x value of a vertical asymptote between x1 and x2, if any exists"""
        if hasattr(self, 'vertical_asymptotes'):
            for x in self.vertical_asymptotes:
                if x1 <= x < x2:
                    return x
        return None
