from constants import default_color
from copy import deepcopy
from drawable import Drawable
from math_util import MathUtil


class Ellipse(Drawable):
    def __init__(self, center_point, radius_x, radius_y, canvas, rotation_angle=0, color=default_color):
        self.center = center_point
        self.radius_x = radius_x
        self.radius_y = radius_y
        self.rotation_angle = rotation_angle  # Initialize with provided angle
        self.ellipse_formula = self._calculate_ellipse_algebraic_formula()
        name = f"{self.center.name}({str(self.radius_x)}, {str(self.radius_y)})"
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Ellipse'

    def draw(self):
        rx = self.drawn_radius_x
        ry = self.drawn_radius_y
        x, y = self.center.x, self.center.y
        
        # Create transform attribute for rotation
        transform = f"rotate({-self.rotation_angle} {x} {y})" if self.rotation_angle != 0 else None
        
        # Add transform to SVG element if rotation exists
        if transform:
            self.create_svg_element('ellipse', 
                                  cx=str(x), cy=str(y), 
                                  rx=str(rx), ry=str(ry), 
                                  fill="none", stroke=self.color,
                                  transform=transform)
        else:
            self.create_svg_element('ellipse', 
                                  cx=str(x), cy=str(y), 
                                  rx=str(rx), ry=str(ry), 
                                  fill="none", stroke=self.color)

    def _initialize(self):
        scale_factor = self.canvas.scale_factor
        self.drawn_radius_x = self.radius_x * scale_factor
        self.drawn_radius_y = self.radius_y * scale_factor
        self.center._initialize()

    def _calculate_ellipse_algebraic_formula(self):
        x = self.center.original_position.x
        y = self.center.original_position.y
        return MathUtil.get_ellipse_formula(x, y, self.radius_x, self.radius_y, self.rotation_angle)

    def zoom(self):
        scale_factor = self.canvas.scale_factor
        self.drawn_radius_x = self.radius_x * scale_factor
        self.drawn_radius_y = self.radius_y * scale_factor
        # Zooming is done by the canvas for the center point
    
    def pan(self):
        pass   # Panning is done by the canvas for the center point        
        
    def get_state(self):
        """Return the state of the ellipse including rotation"""
        state = {
            "name": self.name, 
            "args": {
                "center": self.center.name, 
                "radius_x": self.radius_x, 
                "radius_y": self.radius_y, 
                "rotation_angle": self.rotation_angle,
                "ellipse_formula": self.ellipse_formula
            }
        }
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        # Deep copy the center point
        new_center = deepcopy(self.center, memo)
        # Create a new Ellipse instance with the copied center point and other properties
        new_ellipse = Ellipse(new_center, self.radius_x, self.radius_y, 
                             canvas=self.canvas, color=self.color, 
                             rotation_angle=self.rotation_angle)
        memo[id(self)] = new_ellipse
        return new_ellipse

    def translate(self, x_offset, y_offset):
        self.center.original_position.x += x_offset
        self.center.original_position.y += y_offset
        self._initialize()

    def rotate(self, angle):
        """Rotate the ellipse around its center by the given angle in degrees"""
        # Update rotation angle (keep it between 0 and 360 degrees)
        self.rotation_angle = (self.rotation_angle + angle) % 360
        
        # Update ellipse formula if needed
        self.ellipse_formula = self._calculate_ellipse_algebraic_formula()
        self._initialize()
        
        # Return tuple (should_proceed, message) to match interface
        return True, None 