from browser import document, ajax
import json
from utils.math_utils import MathUtils

class WorkspaceManager:
    """Manages workspace operations including saving, loading, listing and deleting workspaces.
    
    This class handles all workspace-related operations and their associated error handling.
    It works with the canvas to save and restore workspace states, including all geometric
    objects and computations.
    
    Args:
        canvas: The canvas instance to manage workspaces for.
    """
    
    def __init__(self, canvas):
        self.canvas = canvas

    def save_workspace(self, name=None):
        """Save the current workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    return f'Workspace "{name if name else "current"}" saved successfully.'
                return f'Error saving workspace: {response.get("message")}'
            except Exception as e:
                return f'Error saving workspace: {str(e)}'

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error saving workspace: {e.text}')
        
        data = {
            'state': self.canvas.get_canvas_state(),
            'name': name
        }
        
        req.open('POST', '/save_workspace', False)  # Set to synchronous
        req.set_header('Content-Type', 'application/json')
        req.send(json.dumps(data))
        return on_complete(req)

    def _create_points(self, state):
        """Create points from workspace state."""
        if "Points" not in state:
            return
        for item_state in state["Points"]:
            self.canvas.create_point(
                item_state["args"]["position"]["x"], 
                item_state["args"]["position"]["y"],
                name=item_state.get("name", "")
            )

    def _create_segments(self, state):
        """Create segments from workspace state."""
        if "Segments" not in state:
            return
        for item_state in state["Segments"]:
            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
            if p1 and p2:
                self.canvas.create_segment(
                    p1.original_position.x,
                    p1.original_position.y,
                    p2.original_position.x,
                    p2.original_position.y,
                    name=item_state.get("name", "")
                )

    def _create_vectors(self, state):
        """Create vectors from workspace state."""
        if "Vectors" not in state:
            return
        for item_state in state["Vectors"]:
            origin_point_name = item_state["args"].get("origin")
            tip_point_name = item_state["args"].get("tip")

            if not origin_point_name or not tip_point_name:
                print(f"Warning: Vector '{item_state.get('name', 'Unnamed')}' is missing origin or tip point name in its state. Skipping.")
                continue

            origin_point = self.canvas.get_point_by_name(origin_point_name)
            tip_point = self.canvas.get_point_by_name(tip_point_name)

            if not origin_point or not tip_point:
                print(f"Warning: Could not find origin ('{origin_point_name}') or tip ('{tip_point_name}') point for vector '{item_state.get('name', 'Unnamed')}' in the canvas. Skipping.")
                continue
            
            self.canvas.create_vector(
                origin_point.original_position.x,
                origin_point.original_position.y, 
                tip_point.original_position.x,
                tip_point.original_position.y,
                name=item_state.get("name", "")
            )

    def _create_triangles(self, state):
        """Create triangles from workspace state."""
        if "Triangles" not in state:
            return
        for item_state in state["Triangles"]:
            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
            p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
            if p1 and p2 and p3:
                self.canvas.create_triangle(
                    p1.original_position.x,
                    p1.original_position.y,
                    p2.original_position.x,
                    p2.original_position.y,
                    p3.original_position.x,
                    p3.original_position.y,
                    name=item_state.get("name", "")
                )

    def _create_rectangles(self, state):
        """Create rectangles from workspace state."""
        if "Rectangles" not in state:
            return
        
        for item_state in state["Rectangles"]:
            rect_name = item_state.get("name", "UnnamedRectangle")
            
            arg_point_names = [
                item_state["args"].get("p1"),
                item_state["args"].get("p2"),
                item_state["args"].get("p3"),
                item_state["args"].get("p4")
            ]

            if not all(arg_point_names):
                print(f"Warning: Rectangle '{rect_name}' is missing one or more point names (p1, p2, p3, p4) in its state. Skipping.")
                continue

            points = [self.canvas.get_point_by_name(name) for name in arg_point_names]

            if not all(points):
                missing_names = [arg_point_names[i] for i, p in enumerate(points) if not p]
                print(f"Warning: Could not find one or more points ({', '.join(missing_names)}) for rectangle '{rect_name}' in the canvas. Skipping.")
                continue
            
            p_diag1, p_diag2 = MathUtils.find_diagonal_points(points, rect_name)
            
            if not p_diag1 or not p_diag2:
                print(f"Warning: Could not determine diagonal points for rectangle '{rect_name}'. Skipping.")
                continue
            
            try:
                # Instead of using canvas.create_rectangle (which creates new segments),
                # find the existing segments that form this rectangle and create it directly
                rect_segments = self._find_rectangle_segments(points)
                
                if not rect_segments:
                    # Fall back to standard creation if segments not found
                    created_rect = self.canvas.create_rectangle(
                        p_diag1.original_position.x,
                        p_diag1.original_position.y,
                        p_diag2.original_position.x,
                        p_diag2.original_position.y,
                        name=item_state.get("name", "")
                    )
                else:
                    # Create rectangle directly using existing segments
                    from drawables.rectangle import Rectangle
                    created_rect = Rectangle(
                        rect_segments[0], rect_segments[1], rect_segments[2], rect_segments[3], 
                        self.canvas
                    )
                    # Set the name if provided
                    if item_state.get("name"):
                        created_rect.name = item_state.get("name")
                    
                    # Add to drawables
                    self.canvas.drawable_manager.drawables.add(created_rect)
                    
                    # Register dependencies
                    self.canvas.drawable_manager.dependency_manager.analyze_drawable_for_dependencies(created_rect)
                
            except ValueError as e:
                if "The segments do not form a rectangle" in str(e):
                    print(f"Warning: Skipping rectangle '{rect_name}' - segments do not form a valid rectangle topology. This may be due to inconsistent workspace data.")
                    continue
                else:
                    # Re-raise if it's a different ValueError
                    raise
            except Exception as e:
                raise

    def _find_rectangle_segments(self, points):
        """Find existing segments that form a rectangle from the given points.
        Returns a list of 4 segments in the correct order, or None if not found."""
        if len(points) != 4:
            return None
            
        # Find all segments that connect pairs of these points
        connecting_segments = []
        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                p1, p2 = points[i], points[j]
                # Look for segment connecting these two points (regardless of direction)
                segment = self.canvas.get_segment_by_points(p1, p2)
                if not segment:
                    # Try the other direction
                    segment = self.canvas.get_segment_by_points(p2, p1)
                if segment:
                    connecting_segments.append(segment)
        
        # For a rectangle, we need exactly 4 segments
        if len(connecting_segments) != 4:
            return None
            
        # Try to arrange segments in proper rectangle order
        # A rectangle needs segments that form a closed loop
        return self._arrange_segments_in_rectangle_order(connecting_segments)
    
    def _arrange_segments_in_rectangle_order(self, segments):
        """Arrange segments in proper rectangle order (each segment's end connects to next segment's start)."""
        if len(segments) != 4:
            return None
        
        # Try different starting segments and arrangements
        for start_seg in segments:
            remaining = segments.copy()
            remaining.remove(start_seg)
            
            # Try both directions for the starting segment
            for start_direction in [True, False]:  # True = normal direction, False = reversed
                ordered = [start_seg]
                if start_direction:
                    current_end_point = start_seg.point2
                else:
                    current_end_point = start_seg.point1  
                
                remaining_copy = remaining.copy()
                
                # Try to build a path
                while remaining_copy and len(ordered) < 4:
                    found_next = False
                    for seg in remaining_copy:
                        if seg.point1 == current_end_point:
                            ordered.append(seg)
                            current_end_point = seg.point2
                            remaining_copy.remove(seg)
                            found_next = True
                            break
                        elif seg.point2 == current_end_point:
                            # We conceptually reverse this segment for path building
                            ordered.append(seg)
                            current_end_point = seg.point1
                            remaining_copy.remove(seg) 
                            found_next = True
                            break
                    
                    if not found_next:
                        break
                
                # Check if we have a closed rectangle (4 segments, last connects back to first)
                if len(ordered) == 4:
                    # Check if the path closes properly
                    if start_direction:
                        start_point = start_seg.point1
                    else:
                        start_point = start_seg.point2
                    
                    closes_properly = (current_end_point == start_point)
                    
                    if closes_properly:
                        return ordered
        
        return None

    def _create_circles(self, state):
        """Create circles from workspace state."""
        if "Circles" not in state:
            return
        for item_state in state["Circles"]:
            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
            if center_point:
                self.canvas.create_circle(
                    center_point.original_position.x,
                    center_point.original_position.y,
                    item_state["args"]["radius"],
                    name=item_state.get("name", "")
                )

    def _create_ellipses(self, state):
        """Create ellipses from workspace state."""
        if "Ellipses" not in state:
            return
        for item_state in state["Ellipses"]:
            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
            if center_point:
                self.canvas.create_ellipse(
                    center_point.original_position.x,
                    center_point.original_position.y,
                    item_state["args"]["radius_x"],
                    item_state["args"]["radius_y"],
                    rotation_angle=item_state["args"].get("rotation_angle", 0),
                    name=item_state.get("name", "")
                )

    def _create_functions(self, state):
        """Create functions from workspace state."""
        if "Functions" not in state:
            return
        for item_state in state["Functions"]:
            self.canvas.draw_function(
                item_state["args"]["function_string"],
                name=item_state.get("name", ""),
                left_bound=item_state["args"].get("left_bound"),
                right_bound=item_state["args"].get("right_bound")
            )

    def _create_colored_areas(self, state):
        """Create colored areas from workspace state."""
        # Handle different types of colored areas
        colored_area_types = [
            "FunctionsBoundedColoredAreas",
            "SegmentsBoundedColoredAreas", 
            "FunctionSegmentBoundedColoredAreas",
            "ColoredAreas"
        ]
        
        for area_type in colored_area_types:
            if area_type not in state:
                continue
                
            for item_state in state[area_type]:
                try:
                    # Extract parameters based on area type
                    if area_type == "FunctionsBoundedColoredAreas":
                        # Functions bounded colored areas use func1/func2
                        drawable1_name = item_state["args"]["func1"]
                        drawable2_name = item_state["args"].get("func2")
                    else:
                        # Other types might use different field names
                        drawable1_name = item_state["args"].get("drawable1_name") or item_state["args"].get("segment1") or item_state["args"].get("func1")
                        drawable2_name = item_state["args"].get("drawable2_name") or item_state["args"].get("segment2") or item_state["args"].get("func2")
                    
                    # Common parameters
                    left_bound = item_state["args"].get("left_bound")
                    right_bound = item_state["args"].get("right_bound")
                    color = item_state["args"].get("color", "lightblue")
                    opacity = item_state["args"].get("opacity", 0.3)
                    name = item_state.get("name", "")
                    
                    # Create the colored area
                    created_area = self.canvas.create_colored_area(
                        drawable1_name=drawable1_name,
                        drawable2_name=drawable2_name,
                        left_bound=left_bound,
                        right_bound=right_bound,
                        color=color,
                        opacity=opacity
                    )
                    
                    # Set the name if specified and area was created successfully
                    if created_area and name:
                        created_area.name = name
                        
                except Exception as e:
                    print(f"Warning: Could not restore colored area '{item_state.get('name', 'Unnamed')}': {e}")
                    continue

    def _create_angles(self, state):
        """Create angles from workspace state."""
        if "Angles" not in state:
            return
        
        # Use the angle manager's load_angles method
        if hasattr(self.canvas, 'drawable_manager') and \
           hasattr(self.canvas.drawable_manager, 'angle_manager') and \
           self.canvas.drawable_manager.angle_manager:
            try:
                self.canvas.drawable_manager.angle_manager.load_angles(state["Angles"])
            except Exception as e:
                print(f"Warning: Could not restore angles: {e}")
        else:
            print("Warning: Angle manager not available for loading angles")

    def _restore_computations(self, state):
        """Restore computations from workspace state."""
        if "computations" not in state:
            return
        for comp in state["computations"]:
            # Skip workspace management functions
            if comp["expression"].startswith("list_workspaces") or \
               comp["expression"].startswith("save_workspace") or \
               comp["expression"].startswith("load_workspace"):
                continue
            self.canvas.add_computation(comp["expression"], comp["result"])

    def _restore_workspace_state(self, state):
        """Restore the complete workspace state in the correct order."""
        self.canvas.clear()
        
        # Create objects in the correct dependency order
        self._create_points(state)
        self._create_segments(state)
        self._create_vectors(state)
        self._create_triangles(state)
        self._create_rectangles(state)
        self._create_circles(state)
        self._create_ellipses(state)
        self._create_functions(state)
        # Create colored areas after functions since they may depend on functions
        self._create_colored_areas(state)
        # Create angles after segments since they depend on segments  
        self._create_angles(state)
        self._restore_computations(state)

    def load_workspace(self, name=None):
        """Load a workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    state = response.get('data', {}).get('state')
                    if not state:
                        return f'Error loading workspace: No state data found in response'
                    
                    self._restore_workspace_state(state)
                    return f'Workspace "{name if name else "current"}" loaded successfully.'
                else:
                    return f'Error loading workspace: {response.get("message")}'
            except Exception as e:
                return f'Error loading workspace: {str(e)}'

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error loading workspace: {e.text}')
        
        url = f'/load_workspace?name={name}' if name else '/load_workspace'
        req.open('GET', url, False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def list_workspaces(self):
        """List all saved workspaces."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    workspaces = response.get('data', [])
                    return ', '.join(workspaces) if workspaces else 'None'
                return f'Error listing workspaces: {response.get("message")}'
            except Exception as e:
                return f'Error listing workspaces: {str(e)}'
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error listing workspaces: {e.text}')
        
        req.open('GET', '/list_workspaces', False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def delete_workspace(self, name):
        """Delete a workspace."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    return f'Workspace "{name}" deleted successfully.'
                return f'Error deleting workspace: {response.get("message")}'
            except Exception as e:
                return f'Error deleting workspace: {str(e)}'
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error deleting workspace: {e.text}')
        
        url = f'/delete_workspace?name={name}'
        req.open('GET', url, False)  # Set to synchronous
        req.send()
        return on_complete(req) 