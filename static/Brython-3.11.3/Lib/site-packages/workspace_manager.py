from browser import document, ajax
import json
from utils.math_utils import MathUtils

class WorkspaceManager:
    """Manages workspace operations including saving, loading, listing and deleting workspaces.
    
    This class handles all workspace-related operations and their associated error handling.
    It works with the canvas to save and restore workspace states, including all geometric
    objects and computations.
    
    Args:
        canvas: The canvas instance to manage workspaces for.
    """
    
    def __init__(self, canvas):
        self.canvas = canvas

    def save_workspace(self, name=None):
        """Save the current workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    return f'Workspace "{name if name else "current"}" saved successfully.'
                return f'Error saving workspace: {response.get("message")}'
            except Exception as e:
                return f'Error saving workspace: {str(e)}'

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error saving workspace: {e.text}')
        
        data = {
            'state': self.canvas.get_canvas_state(),
            'name': name
        }
        
        req.open('POST', '/save_workspace', False)  # Set to synchronous
        req.set_header('Content-Type', 'application/json')
        req.send(json.dumps(data))
        return on_complete(req)

    def _create_points(self, state):
        """Create points from workspace state."""
        if "Points" not in state:
            return
        for item_state in state["Points"]:
            self.canvas.create_point(
                item_state["args"]["position"]["x"], 
                item_state["args"]["position"]["y"],
                name=item_state.get("name", "")
            )

    def _create_segments(self, state):
        """Create segments from workspace state."""
        if "Segments" not in state:
            return
        for item_state in state["Segments"]:
            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
            if p1 and p2:
                self.canvas.create_segment(
                    p1.original_position.x,
                    p1.original_position.y,
                    p2.original_position.x,
                    p2.original_position.y,
                    name=item_state.get("name", "")
                )

    def _create_vectors(self, state):
        """Create vectors from workspace state."""
        if "Vectors" not in state:
            return
        for item_state in state["Vectors"]:
            origin_point_name = item_state["args"].get("origin")
            tip_point_name = item_state["args"].get("tip")

            if not origin_point_name or not tip_point_name:
                print(f"Warning: Vector '{item_state.get('name', 'Unnamed')}' is missing origin or tip point name in its state. Skipping.")
                continue

            origin_point = self.canvas.get_point_by_name(origin_point_name)
            tip_point = self.canvas.get_point_by_name(tip_point_name)

            if not origin_point or not tip_point:
                print(f"Warning: Could not find origin ('{origin_point_name}') or tip ('{tip_point_name}') point for vector '{item_state.get('name', 'Unnamed')}' in the canvas. Skipping.")
                continue
            
            self.canvas.create_vector(
                origin_point.original_position.x,
                origin_point.original_position.y, 
                tip_point.original_position.x,
                tip_point.original_position.y,
                name=item_state.get("name", "")
            )

    def _create_triangles(self, state):
        """Create triangles from workspace state."""
        if "Triangles" not in state:
            return
        for item_state in state["Triangles"]:
            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
            p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
            if p1 and p2 and p3:
                self.canvas.create_triangle(
                    p1.original_position.x,
                    p1.original_position.y,
                    p2.original_position.x,
                    p2.original_position.y,
                    p3.original_position.x,
                    p3.original_position.y,
                    name=item_state.get("name", "")
                )

    def _create_rectangles(self, state):
        """Create rectangles from workspace state."""
        if "Rectangles" not in state:
            return
        for item_state in state["Rectangles"]:
            rect_name = item_state.get("name", "UnnamedRectangle")
            arg_point_names = [
                item_state["args"].get("p1"),
                item_state["args"].get("p2"),
                item_state["args"].get("p3"),
                item_state["args"].get("p4")
            ]

            if not all(arg_point_names):
                print(f"Warning: Rectangle '{rect_name}' is missing one or more point names (p1, p2, p3, p4) in its state. Skipping.")
                continue

            points = [self.canvas.get_point_by_name(name) for name in arg_point_names]

            if not all(points):
                missing_names = [arg_point_names[i] for i, p in enumerate(points) if not p]
                print(f"Warning: Could not find one or more points ({', '.join(missing_names)}) for rectangle '{rect_name}' in the canvas. Skipping.")
                continue
            
            p_diag1, p_diag2 = MathUtils.find_diagonal_points(points, rect_name)
            
            if not p_diag1 or not p_diag2:
                # Warning already printed by _find_diagonal_points
                print(f"Warning: Could not determine diagonal points for rectangle '{rect_name}'. Skipping.")
                continue
            
            try:
                self.canvas.create_rectangle(
                    p_diag1.original_position.x,
                    p_diag1.original_position.y,
                    p_diag2.original_position.x,
                    p_diag2.original_position.y,
                    name=item_state.get("name", "")
                )
            except ValueError as e:
                if "The segments do not form a rectangle" in str(e):
                    print(f"Warning: Skipping rectangle '{rect_name}' - segments do not form a valid rectangle topology. This may be due to inconsistent workspace data.")
                    continue
                else:
                    # Re-raise if it's a different ValueError
                    raise

    def _create_circles(self, state):
        """Create circles from workspace state."""
        if "Circles" not in state:
            return
        for item_state in state["Circles"]:
            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
            if center_point:
                self.canvas.create_circle(
                    center_point.original_position.x,
                    center_point.original_position.y,
                    item_state["args"]["radius"],
                    name=item_state.get("name", "")
                )

    def _create_ellipses(self, state):
        """Create ellipses from workspace state."""
        if "Ellipses" not in state:
            return
        for item_state in state["Ellipses"]:
            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
            if center_point:
                self.canvas.create_ellipse(
                    center_point.original_position.x,
                    center_point.original_position.y,
                    item_state["args"]["radius_x"],
                    item_state["args"]["radius_y"],
                    rotation_angle=item_state["args"].get("rotation_angle", 0),
                    name=item_state.get("name", "")
                )

    def _create_functions(self, state):
        """Create functions from workspace state."""
        if "Functions" not in state:
            return
        for item_state in state["Functions"]:
            self.canvas.draw_function(
                item_state["args"]["function_string"],
                name=item_state.get("name", ""),
                left_bound=item_state["args"].get("left_bound"),
                right_bound=item_state["args"].get("right_bound")
            )

    def _restore_computations(self, state):
        """Restore computations from workspace state."""
        if "computations" not in state:
            return
        for comp in state["computations"]:
            # Skip workspace management functions
            if comp["expression"].startswith("list_workspaces") or \
               comp["expression"].startswith("save_workspace") or \
               comp["expression"].startswith("load_workspace"):
                continue
            self.canvas.add_computation(comp["expression"], comp["result"])

    def _restore_workspace_state(self, state):
        """Restore the complete workspace state in the correct order."""
        self.canvas.clear()
        
        # Create objects in the correct dependency order
        self._create_points(state)
        self._create_segments(state)
        self._create_vectors(state)
        self._create_triangles(state)
        self._create_rectangles(state)
        self._create_circles(state)
        self._create_ellipses(state)
        self._create_functions(state)
        self._restore_computations(state)

    def load_workspace(self, name=None):
        """Load a workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    state = response.get('data', {}).get('state')
                    if not state:
                        return f'Error loading workspace: No state data found in response'
                    
                    self._restore_workspace_state(state)
                    return f'Workspace "{name if name else "current"}" loaded successfully.'
                else:
                    return f'Error loading workspace: {response.get("message")}'
            except Exception as e:
                return f'Error loading workspace: {str(e)}'

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error loading workspace: {e.text}')
        
        url = f'/load_workspace?name={name}' if name else '/load_workspace'
        req.open('GET', url, False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def list_workspaces(self):
        """List all saved workspaces."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    workspaces = response.get('data', [])
                    return ', '.join(workspaces) if workspaces else 'None'
                return f'Error listing workspaces: {response.get("message")}'
            except Exception as e:
                return f'Error listing workspaces: {str(e)}'
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error listing workspaces: {e.text}')
        
        req.open('GET', '/list_workspaces', False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def delete_workspace(self, name):
        """Delete a workspace."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    return f'Workspace "{name}" deleted successfully.'
                return f'Error deleting workspace: {response.get("message")}'
            except Exception as e:
                return f'Error deleting workspace: {str(e)}'
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error deleting workspace: {e.text}')
        
        url = f'/delete_workspace?name={name}'
        req.open('GET', url, False)  # Set to synchronous
        req.send()
        return on_complete(req) 