from browser import document, ajax
import json

class WorkspaceManager:
    """Manages workspace operations including saving, loading, listing and deleting workspaces.
    
    This class handles all workspace-related operations and their associated error handling.
    It works with the canvas to save and restore workspace states, including all geometric
    objects and computations.
    
    Args:
        canvas: The canvas instance to manage workspaces for.
    """
    
    def __init__(self, canvas):
        self.canvas = canvas

    def save_workspace(self, name=None):
        """Save the current workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    return f'Workspace "{name if name else "current"}" saved successfully.'
                return f'Error saving workspace: {response.get("message")}'
            except Exception as e:
                return f'Error saving workspace: {str(e)}'

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error saving workspace: {e.text}')
        
        data = {
            'state': self.canvas.get_canvas_state(),
            'name': name
        }
        
        req.open('POST', '/save_workspace', False)  # Set to synchronous
        req.set_header('Content-Type', 'application/json')
        req.send(json.dumps(data))
        return on_complete(req)

    def load_workspace(self, name=None):
        """Load a workspace state."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    state = response.get('data', {}).get('state')
                    if not state:
                        return f'Error loading workspace: No state data found in response'
                        
                    self.canvas.clear()
                    
                    # First, process all points
                    if "Points" in state:
                        for item_state in state["Points"]:
                            self.canvas.create_point(
                                item_state["args"]["position"]["x"], 
                                item_state["args"]["position"]["y"],
                                name=item_state.get("name", "")
                            )
                    
                    # Then process segments
                    if "Segments" in state:
                        for item_state in state["Segments"]:
                            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
                            if p1 and p2:
                                self.canvas.create_segment(
                                    p1.original_position.x,
                                    p1.original_position.y,
                                    p2.original_position.x,
                                    p2.original_position.y,
                                    name=item_state.get("name", "")
                                )

                    # Process vectors
                    if "Vectors" in state:
                        for item_state in state["Vectors"]:
                            self.canvas.create_vector(
                                item_state["args"]["origin_x"],
                                item_state["args"]["origin_y"], 
                                item_state["args"]["tip_x"],
                                item_state["args"]["tip_y"],
                                name=item_state.get("name", "")
                            )

                    # Process triangles
                    if "Triangles" in state:
                        for item_state in state["Triangles"]:
                            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                            p2 = self.canvas.get_point_by_name(item_state["args"]["p2"])
                            p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
                            if p1 and p2 and p3:
                                self.canvas.create_triangle(
                                    p1.original_position.x,
                                    p1.original_position.y,
                                    p2.original_position.x,
                                    p2.original_position.y,
                                    p3.original_position.x,
                                    p3.original_position.y,
                                    name=item_state.get("name", "")
                                )

                    # Process rectangles
                    if "Rectangles" in state:
                        for item_state in state["Rectangles"]:
                            p1 = self.canvas.get_point_by_name(item_state["args"]["p1"])
                            p3 = self.canvas.get_point_by_name(item_state["args"]["p3"])
                            if p1 and p3:
                                self.canvas.create_rectangle(
                                    p1.original_position.x,
                                    p1.original_position.y,
                                    p3.original_position.x,
                                    p3.original_position.y,
                                    name=item_state.get("name", "")
                                )

                    # Process circles
                    if "Circles" in state:
                        for item_state in state["Circles"]:
                            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
                            if center_point:
                                self.canvas.create_circle(
                                    center_point.original_position.x,
                                    center_point.original_position.y,
                                    item_state["args"]["radius"],
                                    name=item_state.get("name", "")
                                )

                    # Process ellipses
                    if "Ellipses" in state:
                        for item_state in state["Ellipses"]:
                            center_point = self.canvas.get_point_by_name(item_state["args"]["center"])
                            if center_point:
                                self.canvas.create_ellipse(
                                    center_point.original_position.x,
                                    center_point.original_position.y,
                                    item_state["args"]["radius_x"],
                                    item_state["args"]["radius_y"],
                                    rotation_angle=item_state["args"].get("rotation_angle", 0),
                                    name=item_state.get("name", "")
                                )

                    # Process functions
                    if "Functions" in state:
                        for item_state in state["Functions"]:
                            self.canvas.draw_function(
                                item_state["args"]["function_string"],
                                name=item_state.get("name", ""),
                                left_bound=item_state["args"].get("left_bound"),
                                right_bound=item_state["args"].get("right_bound")
                            )

                    # Process computations last
                    if "computations" in state:
                        for comp in state["computations"]:
                            # Skip workspace management functions
                            if comp["expression"].startswith("list_workspaces") or \
                               comp["expression"].startswith("save_workspace") or \
                               comp["expression"].startswith("load_workspace"):
                                continue
                            self.canvas.add_computation(comp["expression"], comp["result"])
                    
                    return f'Workspace "{name if name else "current"}" loaded successfully.'
                else:
                    return f'Error loading workspace: {response.get("message")}'
            except Exception as e:
                return f'Error loading workspace: {str(e)}'

        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error loading workspace: {e.text}')
        
        url = f'/load_workspace?name={name}' if name else '/load_workspace'
        req.open('GET', url, False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def list_workspaces(self):
        """List all saved workspaces."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    workspaces = response.get('data', [])
                    return ', '.join(workspaces) if workspaces else 'None'
                return f'Error listing workspaces: {response.get("message")}'
            except Exception as e:
                return f'Error listing workspaces: {str(e)}'
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error listing workspaces: {e.text}')
        
        req.open('GET', '/list_workspaces', False)  # Set to synchronous
        req.send()
        return on_complete(req)

    def delete_workspace(self, name):
        """Delete a workspace."""
        def on_complete(req):
            try:
                response = json.loads(req.text)
                if response.get('status') == 'success':
                    return f'Workspace "{name}" deleted successfully.'
                return f'Error deleting workspace: {response.get("message")}'
            except Exception as e:
                return f'Error deleting workspace: {str(e)}'
                
        req = ajax.Ajax()
        req.bind('complete', on_complete)
        req.bind('error', lambda e: f'Error deleting workspace: {e.text}')
        
        url = f'/delete_workspace?name={name}'
        req.open('GET', url, False)  # Set to synchronous
        req.send()
        return on_complete(req) 