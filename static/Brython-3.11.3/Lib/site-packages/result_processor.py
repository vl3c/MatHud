from constants import successful_call_message

class ResultProcessor:
    """Handles the processing of function calls and their results."""
    
    @staticmethod
    def get_results(calls, available_functions, undoable_functions, canvas):
        """
        Process function calls and collect their results.
        
        Args:
            calls: List of function call dictionaries
            available_functions: Dictionary mapping function names to implementations
            undoable_functions: Tuple of function names that are undoable
            canvas: Canvas instance for archiving state and adding computations
            
        Returns:
            Dictionary mapping function call strings to their results
        """
        if not isinstance(calls, list):
            raise ValueError("Invalid input for calls.")
        if not isinstance(available_functions, dict):
            raise ValueError("Invalid input for available_functions.")
        if not isinstance(undoable_functions, tuple):
            raise ValueError("Invalid input for undoable_functions.")
        
        results = {}  # Use a dictionary for results
        unformattable_functions = undoable_functions + ('undo', 'redo')
        non_computation_functions = unformattable_functions + ('run_tests', 'list_workspaces', 'save_workspace', 'load_workspace', 'delete_workspace')
        
        # Archive once at the start and then suspend archiving while calling undoable functions
        contains_undoable_function = any(call.get('function_name', '') in undoable_functions for call in calls)
        if contains_undoable_function:
            canvas.archive()
            
        # Extract function name and arguments from the tool_call
        for call in calls:
            try:
                function_name = call.get('function_name', '')
                if function_name not in available_functions:
                    error_msg = f"Error: function {function_name} not found."
                    print(error_msg)  # DEBUG
                    results[function_name] = error_msg
                    continue
                    
                args = call.get('arguments', {})
                result = available_functions[function_name](**args)
                print(f"Called function {function_name} with args {args}. Result: {result}")   # DEBUG
                # Format the key uniformly for all functions
                formatted_args = ', '.join(f"{k}:{v}" for k, v in args.items() if k != 'canvas')
                key = f"{function_name}({formatted_args})"
                
                # Determine the value based on function type and execution success
                if function_name in unformattable_functions:
                    result = successful_call_message
                elif function_name == 'evaluate_expression' and 'expression' in args:
                    ResultProcessor._handle_expression_evaluation(args, result, function_name, non_computation_functions, canvas, results)
                    continue
                        
                # Save computation to canvas state if it's not a non-computation function
                elif (not isinstance(result, str) or not result.startswith("Error:")) and \
                     function_name not in non_computation_functions:
                    canvas.add_computation(
                        expression=key,
                        result=result
                    )
                    
                print(f"Appending result for {key}: {result}")  # DEBUG
                results[key] = result
                        
            except Exception as e:
                error_message = f"Error calling function {function_name}: {e}"
                print(error_message)  # DEBUG
                # Ensure key is a string and defined before using it
                if 'key' not in locals() or key is None:
                    key = function_name
                # Store the error message as the value with the uniform key format
                results[key] = f"Error: {str(e)}"
        
        return results
    
    @staticmethod
    def _handle_expression_evaluation(args, result, function_name, non_computation_functions, canvas, results):
        """
        Handle the special case of expression evaluation results.
        
        Args:
            args: Arguments dictionary for the function call
            result: Result of the function call
            function_name: Name of the function that was called
            non_computation_functions: List of functions that shouldn't be added to computations
            canvas: Canvas instance for adding computations
            results: Dictionary to update with the result
        """
        expression = args.get('expression').replace(' ', '')
        if 'variables' in args:
            variables_dict = args.get('variables', {})
            if not isinstance(variables_dict, dict):
                variables_dict = {}
            variables = ', '.join(f"{k}:{v}" for k, v in variables_dict.items())
            key = f"{expression} for {variables}"
        else:
            key = expression
            
        # Save computation to canvas state if it's not a non-computation function
        if (not isinstance(result, str) or not result.startswith("Error:")) and \
           function_name not in non_computation_functions:
            canvas.add_computation(
                expression=expression,
                result=result
            )
        
        print(f"Appending result for {key}: {result}")  # DEBUG
        results[key] = result 