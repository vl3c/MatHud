from colored_area import ColoredArea
from function import Function
import copy

class FunctionsBoundedColoredArea(ColoredArea):
    def __init__(self, func1, func2=None, canvas=None, left_bound=None, right_bound=None, color="lightblue", opacity=0.3):
        """
        Creates a colored area bounded by two functions.
        func1 and func2 can be:
        - Function objects
        - None (interpreted as y=0, the x-axis)
        - A number (interpreted as y=constant)
        """
        name = self._generate_name(func1, func2)
        super().__init__(name=name, canvas=canvas, color=color, opacity=opacity)
        self.func1 = func1
        self.func2 = func2
        self.left_bound = left_bound
        self.right_bound = right_bound

    def _generate_name(self, func1, func2):
        """Generate a descriptive name for the colored area"""
        f1_name = func1.name if hasattr(func1, 'name') else 'x_axis' if func1 is None else f'y_{func1}'
        f2_name = func2.name if hasattr(func2, 'name') else 'x_axis' if func2 is None else f'y_{func2}'
        return f"area_between_{f1_name}_and_{f2_name}"

    def get_class_name(self):
        return 'FunctionsBoundedColoredArea'

    def _get_function_y_at_x(self, func, x):
        """Get y value for a given x, handling different function types"""
        if func is None:  # x-axis
            # Convert y=0 to canvas coordinates
            return self.canvas.cartesian2axis.origin.y - 0 * self.canvas.scale_factor
        if isinstance(func, (int, float)):  # constant function
            # Convert constant y value to canvas coordinates
            return self.canvas.cartesian2axis.origin.y - float(func) * self.canvas.scale_factor
        if isinstance(func, Function):
            try:
                # Convert from canvas coordinates to original coordinates
                orig_x = (x - self.canvas.cartesian2axis.origin.x) / self.canvas.scale_factor
                y = func.function(orig_x)
                # Convert y back to canvas coordinates
                return self.canvas.cartesian2axis.origin.y - y * self.canvas.scale_factor
            except (ValueError, ZeroDivisionError):
                return None
        return None

    def _get_bounds(self):
        """Calculate the left and right bounds for the colored area"""
        # Start with cartesian system bounds
        bounds = [
            self.canvas.cartesian2axis.get_visible_left_bound(),
            self.canvas.cartesian2axis.get_visible_right_bound()
        ]

        # If func1 is a Function with defined bounds, use them
        if isinstance(self.func1, Function) and self.func1.left_bound is not None and self.func1.right_bound is not None:
            bounds[0] = max(bounds[0], self.func1.left_bound)
            bounds[1] = min(bounds[1], self.func1.right_bound)

        # If func2 is a Function with defined bounds, use them
        if isinstance(self.func2, Function) and self.func2.left_bound is not None and self.func2.right_bound is not None:
            bounds[0] = max(bounds[0], self.func2.left_bound)
            bounds[1] = min(bounds[1], self.func2.right_bound)

        # Apply user-specified bounds if provided
        if self.left_bound is not None:
            bounds[0] = max(bounds[0], self.left_bound)
        if self.right_bound is not None:
            bounds[1] = min(bounds[1], self.right_bound)

        return bounds[0], bounds[1]

    def draw(self):
        left_bound, right_bound = self._get_bounds()
        
        # Sample points for both functions
        num_points = 100
        dx = (right_bound - left_bound) / (num_points - 1)
        
        # Generate forward path (along func1)
        points = []
        current_path = []  # Track current continuous path
        for i in range(num_points):
            # Convert x to canvas coordinates
            x_orig = left_bound + i * dx
            x = self.canvas.cartesian2axis.origin.x + x_orig * self.canvas.scale_factor
            y = self._get_function_y_at_x(self.func1, x)
            
            # Check if we're approaching an asymptote
            if isinstance(self.func1, Function) and self.func1.has_asymptote_between(x_orig - dx, x_orig + dx):
                # Add current path to points and start a new one
                if current_path:
                    points.extend(current_path)
                    current_path = []
            elif y is not None:
                current_path.append((x, y))

        # Add any remaining path
        if current_path:
            points.extend(current_path)

        # Generate reverse path (along func2)
        reverse_points = []
        current_path = []  # Track current continuous path
        for i in range(num_points - 1, -1, -1):
            # Convert x to canvas coordinates
            x_orig = left_bound + i * dx
            x = self.canvas.cartesian2axis.origin.x + x_orig * self.canvas.scale_factor
            y = self._get_function_y_at_x(self.func2, x)
            
            # Check if we're approaching an asymptote
            if isinstance(self.func2, Function) and self.func2.has_asymptote_between(x_orig - dx, x_orig + dx):
                # Add current path to points and start a new one
                if current_path:
                    reverse_points.extend(current_path)
                    current_path = []
            elif y is not None:
                current_path.append((x, y))

        # Add any remaining path
        if current_path:
            reverse_points.extend(current_path)
        
        # Only create path if we have valid points
        if points and reverse_points:
            self._create_svg_path(points, reverse_points)

    def get_state(self):
        state = super().get_state()
        state["args"].update({
            "func1": self.func1.name if hasattr(self.func1, 'name') else str(self.func1),
            "func2": self.func2.name if hasattr(self.func2, 'name') else str(self.func2),
            "left_bound": self.left_bound,
            "right_bound": self.right_bound
        })
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
            
        # Create new instance using __init__
        new_area = FunctionsBoundedColoredArea(
            func1=self.func1,  # Functions will be properly deep copied by their own __deepcopy__
            func2=self.func2,
            canvas=self.canvas,  # Canvas reference is not deep copied
            left_bound=self.left_bound,
            right_bound=self.right_bound,
            color=self.color,
            opacity=self.opacity
        )
        memo[id(self)] = new_area
        return new_area 