# Mathematical classes and functions
import math
from browser import window, document, svg

# Default values
point_size = 2
default_color = "black"


class Canvas:
    def __init__(self):
        self.drawables = []
        self.scale_factor = 1  # Default scale factor is 1 (no scaling)
        self.zoom_point = Point(0, 0)  # Default zoom point is at origin
        self.last_known_zoom_point = Point(0, 0)  # Default last known zoom point is at origin

    def add_drawable(self, drawable):
        self.drawables.append(drawable)
        drawable.canvas = self  # Set the drawable's canvas reference

    def set_zoom_point(self, point):
        self.zoom_point = point

    def set_scale_factor(self, scale_factor):
        self.scale_factor = scale_factor

    def draw(self):
        svg_container = document["math-svg"]
        svg_container.clear()
        for drawable in self.drawables:
            drawable.draw()  # Draw each drawable

    def clear(self):
        for drawable in self.drawables:
            drawable.canvas = None  # Clear the drawable's canvas reference
        self.drawables = []  # Clear the list of drawables


class Drawable:
    def __init__(self, color=default_color, canvas=None):
        self.color = color
        self.canvas = canvas

    def draw(self):
        raise NotImplementedError("Subclasses must implement draw method")

    def create_svg_element(self, element_name, **attributes):
        svg_element = getattr(svg, element_name)(**attributes)
        document["math-svg"] <= svg_element
        return svg_element


class Point(Drawable):
    def __init__(self, x, y, color=default_color, canvas=None):
        super().__init__(color, canvas)
        self.x = x
        self.y = y

    def draw(self):
        x, y = self._adjust_coordinates()
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(point_size), fill=self.color)
       
    def _translate_towards(self, point, destination, scale_factor):
        # Calculate the direction vector from the point to the zoom point
        dx = destination.x - point.x * scale_factor
        dy = destination.y - point.y * scale_factor

        # Normalize the direction vector
        magnitude = math.sqrt(dx**2 + dy**2)
        dx /= magnitude
        dy /= magnitude

        # Update the coordinates by adding the displacement in the direction of the zoom point
        displacement = 10

        point.x += displacement * dx
        point.y += displacement * dy
        return point

    def _adjust_coordinates(self):
        # If a canvas is provided, use its zoom point and scale factor to adjust the coordinates
        if self.canvas:
            zoom_point = self.canvas.zoom_point
            scale_factor = self.canvas.scale_factor
            # x = (self.x - zoom_point.x) * scale_factor + zoom_point.x
            # y = (self.y - zoom_point.y) * scale_factor + zoom_point.y
            old_position = Point(self.x, self.y)
            new_position = self._translate_towards(old_position, zoom_point, scale_factor)
            x = new_position.x * scale_factor
            y = new_position.y * scale_factor
        else:
            x = self.x
            y = self.y
        return x, y

    def __str__(self):
        x, y = self._adjust_coordinates()
        return f'{x},{y}'
    

class Segment(Drawable):
    def __init__(self, point1, point2, color=default_color, canvas=None):
        super().__init__(color)
        self.point1 = Point(**point1, canvas=canvas)
        self.point2 = Point(**point2, canvas=canvas)
        self.canvas = canvas

    def draw(self):
        # If a canvas is provided, use its scale factor and zoom point to adjust the segment's coordinates
        if self.canvas:
            scale_factor = self.canvas.scale_factor
            zoom_point = self.canvas.zoom_point
            x1 = (self.point1.x - zoom_point.x) * scale_factor + zoom_point.x
            y1 = (self.point1.y - zoom_point.y) * scale_factor + zoom_point.y
            x2 = (self.point2.x - zoom_point.x) * scale_factor + zoom_point.x
            y2 = (self.point2.y - zoom_point.y) * scale_factor + zoom_point.y
        else:
            x1 = self.point1.x
            y1 = self.point1.y
            x2 = self.point2.x
            y2 = self.point2.y

        self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)


class Triangle(Drawable):
    def __init__(self, point1, point2, point3, color=default_color, canvas=None):
        super().__init__(color)
        self.point1 = Point(**point1, canvas=canvas)
        self.point2 = Point(**point2, canvas=canvas)
        self.point3 = Point(**point3, canvas=canvas)
        self.canvas = canvas

    def draw(self):
        # If a canvas is provided, use its zoom point and scale factor to adjust the coordinates
        if self.canvas:
            zoom_point = self.canvas.zoom_point
            scale_factor = self.canvas.scale_factor
            x1 = (self.point1.x - zoom_point.x) * scale_factor + zoom_point.x
            y1 = (self.point1.y - zoom_point.y) * scale_factor + zoom_point.y
            x2 = (self.point2.x - zoom_point.x) * scale_factor + zoom_point.x
            y2 = (self.point2.y - zoom_point.y) * scale_factor + zoom_point.y
            x3 = (self.point3.x - zoom_point.x) * scale_factor + zoom_point.x
            y3 = (self.point3.y - zoom_point.y) * scale_factor + zoom_point.y
        else:
            x1, y1 = self.point1.x, self.point1.y
            x2, y2 = self.point2.x, self.point2.y
            x3, y3 = self.point3.x, self.point3.y

        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill='none', stroke=self.color)


class Rectangle(Drawable):
    def __init__(self, top_left, bottom_right, color=default_color, canvas=None):
        super().__init__(color)
        self.top_left = Point(**top_left, canvas=canvas)
        self.bottom_right = Point(**bottom_right, canvas=canvas)
        self.canvas = canvas

    def draw(self):
        width = (self.bottom_right.x - self.top_left.x) * (1 if self.canvas is None else self.canvas.scale_factor)
        height = (self.bottom_right.y - self.top_left.y) * (1 if self.canvas is None else self.canvas.scale_factor)
        x = (self.top_left.x - (self.canvas.zoom_point.x if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.x if self.canvas else 0)
        y = (self.top_left.y - (self.canvas.zoom_point.y if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.y if self.canvas else 0)
        self.create_svg_element('rect', x=str(x), y=str(y), width=str(width), height=str(height), fill="none", stroke=self.color)


class Circle(Drawable):
    def __init__(self, center, radius, color=default_color, canvas=None):
        super().__init__(color)
        self.center = Point(**center, canvas=canvas)
        self.radius = radius
        self.canvas = canvas

    def draw(self):
        radius = self.radius * (1 if self.canvas is None else self.canvas.scale_factor)
        x = (self.center.x - (self.canvas.zoom_point.x if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.x if self.canvas else 0)
        y = (self.center.y - (self.canvas.zoom_point.y if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.y if self.canvas else 0)
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(radius), fill="none", stroke=self.color)


class Ellipse(Drawable):
    def __init__(self, center, rx, ry, color=default_color, canvas=None):
        super().__init__(color)
        self.center = Point(**center, canvas=canvas)
        self.rx = rx
        self.ry = ry
        self.canvas = canvas

    def draw(self):
        rx = self.rx * (1 if self.canvas is None else self.canvas.scale_factor)
        ry = self.ry * (1 if self.canvas is None else self.canvas.scale_factor)
        x = (self.center.x - (self.canvas.zoom_point.x if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.x if self.canvas else 0)
        y = (self.center.y - (self.canvas.zoom_point.y if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.y if self.canvas else 0)
        self.create_svg_element('ellipse', cx=str(x), cy=str(y), rx=str(rx), ry=str(ry), fill="none", stroke=self.color)


class Vector(Drawable):
    def __init__(self, origin, tip, color=default_color, canvas=None):
        super().__init__(color)
        self.origin = Point(**origin, canvas=canvas)
        self.tip = Point(**tip, canvas=canvas)
        self.canvas = canvas

    def draw(self):
        arrow_tip_radius = point_size * 2  # Adjust this value to change the size of the arrow
        # Adjust the coordinates based on the zoom point and scale factor
        x1 = (self.origin.x - (self.canvas.zoom_point.x if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.x if self.canvas else 0)
        y1 = (self.origin.y - (self.canvas.zoom_point.y if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.y if self.canvas else 0)
        x2 = (self.tip.x - (self.canvas.zoom_point.x if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.x if self.canvas else 0)
        y2 = (self.tip.y - (self.canvas.zoom_point.y if self.canvas else 0)) * (1 if self.canvas is None else self.canvas.scale_factor) + (self.canvas.zoom_point.y if self.canvas else 0)
        self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)
        self.create_svg_element('polygon', points=f'{x2},{y2-arrow_tip_radius} {x2-arrow_tip_radius},{y2+arrow_tip_radius} {x2+arrow_tip_radius},{y2+arrow_tip_radius}', fill=self.color)


class Label(Drawable):
    def __init__(self, position, text, color=default_color, canvas=None):
        super().__init__(color)
        self.position = Point(**position, canvas=canvas)
        self.text = text
        self.canvas = canvas

    def draw(self):
        # If a canvas is provided, use its zoom point to adjust the position
        if self.canvas:
            zoom_point = self.canvas.zoom_point
            scale_factor = self.canvas.scale_factor
            x = (self.position.x - zoom_point.x) * scale_factor + zoom_point.x
            y = (self.position.y - zoom_point.y) * scale_factor + zoom_point.y
        else:
            x = self.position.x
            y = self.position.y
        svg_text = svg.text(x=str(x), y=str(y), fill=self.color)
        svg_text.text = self.text  # Add the text as a child node
        document["math-svg"] <= svg_text  # Add the text element directly to the SVG container


# Map function names to functions
function_mapping = {
    'Point': Point,
    'Segment': Segment,
    'Triangle': Triangle,
    'Rectangle': Rectangle,
    'Circle': Circle,
    'Ellipse': Ellipse,
    'Vector': Vector,
    'Label': Label,
}

"""
[
    {"class": "Point", "args": {"x": 50, "y": 50}},
    {"class": "Segment", "args": {"point1": {"x": 70, "y": 20}, "point2": {"x": 100, "y": 200}}},
    {"class": "Rectangle", "args": {"top_left": {"x": 150, "y": 250}, "bottom_right": {"x": 400, "y": 300}}},
    {"class": "Triangle", "args": {"point1": {"x": 100, "y": 100}, "point2": {"x": 100, "y": 200}, "point3": {"x": 300, "y": 300}}},
    {"class": "Point", "args": {"x": 700, "y": 700}},
    {"class": "Circle", "args": {"center": {"x": 150, "y": 150}, "radius": 50}},
    {"class": "Ellipse", "args": {"center": {"x": 200, "y": 200}, "rx": 50, "ry": 25}},
    {"class": "Vector", "args": {"origin": {"x": 100, "y": 100}, "tip": {"x": 200, "y": 200}}},
    {"class": "Vector", "args": {"origin": {"x": 450, "y": 200}, "tip": {"x": 320, "y": 110}}},
    {"class": "Label", "args": {"position": {"x": 50, "y": 50}, "text": "Hello World!"}},
    {"class": "Label", "args": {"position": {"x": 350, "y": 350}, "text": "12345"}}
]
"""