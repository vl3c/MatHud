from math_util import MathUtil
from constants import successful_call_message
import re

class ProcessFunctionCalls:
    @staticmethod
    def evaluate_expression(expression, variables=None, canvas=None):
        def evaluate_numeric_expression(expression, variables):
            result = MathUtil.evaluate(expression, variables)
            print(f"Evaluated numeric expression: {expression} = {result}")   # DEBUG
            return result
        
        def evaluate_function(expression, canvas):
            print(f"Evaluating function with expression: {expression}")   # DEBUG
            if canvas is None:
                raise ValueError("Cannot evaluate function: no canvas available")
            functions = canvas.get_drawables_by_class_name('Function')
            # Split the expression into function name and argument
            match = re.match(r'(\w+)\((.+)\)', expression)
            if match:
                function_name, argument = match.groups()
                print(f"Function name: {function_name}, argument: {argument}")   # DEBUG
            else:
                raise ValueError(f"Invalid function expression: {expression}")
            for function in functions:
                if function.name.lower() == function_name.lower():
                    # If the function name matches, evaluate the function
                    print(f"Found function: {function.name} = {function.function_string}")   # DEBUG
                    try:
                        argument = float(argument)
                    except ValueError:
                        raise ValueError(f"Invalid argument for function: {argument}")
                    return function.function(argument)
        
        try:
            # First, try to evaluate the expression as a numeric expression
            result = evaluate_numeric_expression(expression, variables)
            if not result or (isinstance(result, str) and "Error" in result):
                raise ValueError(f"Error evaluating numeric expression")
            return result
        except Exception as e:
            bad_result_msg = "Sorry, that's not a supported mathematical expression."
            try:
                # If numeric evaluation fails and we have a canvas, try to evaluate as a function
                if canvas is not None:
                    result = evaluate_function(expression, canvas)
                    if not result:
                        return bad_result_msg
                    return result
                else:
                    # If no canvas is available, just return the numeric evaluation error
                    return f"{bad_result_msg} Error: {str(e)}"
            except Exception as e:
                exception_details = str(e).split(":", 1)[0]
                result = f"{bad_result_msg} Exception for ({expression}): {exception_details}."
                return result
    
    @staticmethod
    def get_results(calls, available_functions, undoable_functions, canvas):
        if not isinstance(calls, list):
            raise ValueError("Invalid input for calls.")
        if not isinstance(available_functions, dict):
            raise ValueError("Invalid input for available_functions.")
        if not isinstance(undoable_functions, tuple):
            raise ValueError("Invalid input for undoable_functions.")
        results = {}  # Use a dictionary for results
        unformattable_functions = undoable_functions + ('undo', 'redo', 'run_tests', 'save_workspace', 'load_workspace')
        non_computation_functions = unformattable_functions + ('list_workspaces',)  # Functions that shouldn't be added to computations
        multi_step_mode_enabled = False
        encountered_error = False
        only_multi_step = len(calls) == 1 and calls[0].get('function_name', '') == 'enable_multi_step_mode'
        
        # Archive once at the start and then suspend archiving while calling undoable functions
        contains_undoable_function = any(call.get('function_name', '') in undoable_functions for call in calls)
        if contains_undoable_function:
            canvas.archive()
        # Extract function name and arguments from the tool_call
        for call in calls:
            try:
                function_name = call.get('function_name', '')
                if function_name not in available_functions:
                    error_msg = f"Error: function {function_name} not found."
                    print(error_msg)
                    results[function_name] = error_msg
                    encountered_error = True
                    continue
                if function_name == 'enable_multi_step_mode':
                    multi_step_mode_enabled = True
                    if only_multi_step:
                        results["multi_step_mode"] = "Enabled multi-step mode to break down the problem into steps."
                    continue
                args = call.get('arguments', {})
                result = available_functions[function_name](**args)
                print(f"Called function {function_name} with args {args}. Result: {result}")   # DEBUG
                # Format the key uniformly for all functions
                formatted_args = ', '.join(f"{k}:{v}" for k, v in args.items() if k != 'canvas')
                key = f"{function_name}({formatted_args})"
                # Determine the value based on function type and execution success
                if function_name in unformattable_functions:
                    result = successful_call_message
                elif function_name == 'evaluate_expression' and 'expression' in args:
                    expression = args.get('expression').replace(' ', '')
                    if 'variables' in args:
                        variables_dict = args.get('variables', {})
                        if not isinstance(variables_dict, dict):
                            variables_dict = {}
                        variables = ', '.join(f"{k}:{v}" for k, v in variables_dict.items())
                        key = f"{expression} for {variables}"
                    else:
                        key = expression
                    # Save computation to canvas state if it's not a non-computation function
                    if (not isinstance(result, str) or not result.startswith("Error:")) and \
                       function_name not in non_computation_functions:
                        canvas.add_computation(
                            expression=expression,
                            result=result
                        )
                    elif result.startswith("Error:"):
                        encountered_error = True
                print(f"Appending result for {key}: {result}")  # DEBUG
                results[key] = result
                if isinstance(result, str) and result.startswith("Error:"):
                    encountered_error = True
            except Exception as e:
                error_message = f"Error calling function {function_name}: {e}"
                print(error_message)
                # Ensure key is a string and defined before using it
                if 'key' not in locals() or key is None:
                    key = function_name
                # Store the error message as the value with the uniform key format
                results[key] = f"Error: {str(e)}"
                encountered_error = True
        
        # Enable multi-step mode if we encountered any errors
        multi_step_mode_enabled = multi_step_mode_enabled or encountered_error
        return results, multi_step_mode_enabled
    
    @staticmethod
    def validate_results(results):
        """Validates that results have the correct structure, regardless of whether they contain errors."""
        allowed_types = (str, int, float, bool)
        if not isinstance(results, dict):
            return False
        print(f"Validating results: {results}")
        return all(
            k and isinstance(k, str) and 
            isinstance(v, allowed_types)
            for k, v in results.items()
        )
    
    @staticmethod
    def is_successful_result(value):
        """Checks if a result value represents a successful computation (not an error or empty)."""
        return not (isinstance(value, str) and 
                   (value in [successful_call_message, ""] or 
                    value.startswith("Error:")))