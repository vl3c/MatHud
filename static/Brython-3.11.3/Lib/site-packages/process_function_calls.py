import re
from math_util import MathUtil


class ProcessFunctionCalls:
    @staticmethod
    def evaluate_expression(expression, variables=None, canvas=None):
        def evaluate_numeric_expression(expression, variables):
            result = MathUtil.evaluate(expression, variables)
            print(f"Evaluated numeric expression: {expression} = {result}")   # DEBUG
            return result
        
        def evaluate_function(expression, canvas):
            print(f"Evaluating function with expression: {expression}")   # DEBUG
            functions = canvas.get_drawables_by_class_name('Function')
            # Split the expression into function name and argument
            match = re.match(r'(\w+)\((.+)\)', expression)
            if match:
                function_name, argument = match.groups()
                print(f"Function name: {function_name}, argument: {argument}")   # DEBUG
            else:
                raise ValueError(f"Invalid function expression: {expression}")
            for function in functions:
                if function.name.lower() == function_name.lower():
                    # If the function name matches, evaluate the function
                    print(f"Found function: {function.name} = {function.function_string}")   # DEBUG
                    try:
                        argument = float(argument)
                    except ValueError:
                        raise ValueError(f"Invalid argument for function: {argument}")
                    return function.function(argument)
        
        try:
            # First, try to evaluate the expression as a numeric expression
            result = evaluate_numeric_expression(expression, variables)
            if not result or (isinstance(result, str) and "Error" in result):
                raise ValueError(f"Error evaluating numeric expression. Trying to evaluate as a canvas function.")
            return result
        except Exception as e:
            bad_result_msg = "Sorry, that's not a supported mathematical expression."
            try:
                # If that fails, try to evaluate the expression as a function from the canvas
                result = evaluate_function(expression, canvas)
                if not result:
                    return bad_result_msg
                return result
            except Exception as e:
                exception_details = str(e).split(":", 1)[0]
                result = f"{bad_result_msg} Exception for ({expression}): {exception_details}."
                return result
    
    @staticmethod
    def get_results(calls, available_functions, undoable_functions, canvas):
        if not calls:
            return []
        if not isinstance(calls, list):
            raise ValueError(f"Invalid input: {calls}")
        if not isinstance(available_functions, dict):
            raise ValueError(f"Invalid input: {available_functions}")
        if not isinstance(undoable_functions, tuple):
            raise ValueError(f"Invalid input: {undoable_functions}")
        results = []
        unformattable_functions = undoable_functions + ('undo', 'redo', 'run_tests')
        # Archive once at the start and then suspend archiving while calling undoable functions
        contains_undoable_function = any(call.get('function_name', '') in undoable_functions for call in calls)
        if contains_undoable_function:
            canvas.archive()
        # Extract function name and arguments from the tool_call
        for call in calls:
            try:
                function_name = call.get('function_name', '')
                if function_name not in available_functions:
                    print(f"Error: function {function_name} not found.")
                    continue  # Skip this function call and proceed to the next
                args = call.get('arguments', {})
                # Execute the function with its arguments
                print(f"Calling function {function_name} with arguments {args}")
                # if the function is 'evaluate_expression', pass the canvas as an argument
                if function_name == 'evaluate_expression':
                    args['canvas'] = canvas
                result = available_functions[function_name](**args)
                print(f"Result for calling function {function_name}: {result}")
                # Format the result string differently for computable functions
                if function_name == 'evaluate_expression':
                    expression_and_result = f"{args['expression']} = {result}"
                elif function_name not in unformattable_functions:
                    arguments_string = {', '.join(f'{k}={v}' for k, v in args.items())}
                    expression_and_result = f"{function_name}({arguments_string}) = {result}"
                else:
                    expression_and_result = f"{function_name} call successful."
                print(f"Appending result: {expression_and_result}")
                results.append(expression_and_result)
            except Exception as e:
                error_message = f"Error calling function {function_name}: {e}"
                print(error_message)
                results.append(f"\n{error_message}")
        return results
    
    @staticmethod
    def validate_results(results):
        allowed_types = (str, int, float, bool)
        if not isinstance(results, list):
            return False
        print(f"Validating results: {results}")
        return all(isinstance(result, allowed_types) for result in results)