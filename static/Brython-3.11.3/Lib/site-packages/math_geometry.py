from config import default_color, default_point_size
import math
from drawable import Drawable
from math_util import Utilities
from point import Position, Point

class Segment(Drawable):
    def __init__(self, x1, y1, x2, y2, canvas, name="S", color=default_color):
        name = "S" if name == "" else name
        self._create_points(x1, y1, x2, y2, canvas, name, color)        
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()
    
    def _create_points(self, x1, y1, x2, y2, canvas, name, color):
        p1 = canvas.get_point(x1, y1)
        if p1:
            self.point1 = p1
        else:
            self.point1 = Point(x1, y1, canvas=canvas, name=f"{name}-A", color=color)
            canvas.add_drawable(self.point1)
        p2 = canvas.get_point(x2, y2)
        if p2:
            self.point2 = p2
        else:
            self.point2 = Point(x2, y2, canvas=canvas, name=f"{name}-B", color=color)
            canvas.add_drawable(self.point2)

    @classmethod
    def from_points(cls, p1, p2, canvas, name="", color=default_color):
        return cls(p1.x, p1.y, p2.x, p2.y, canvas=canvas, name=name, color=color)

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Segment'

    def draw(self):
        x1, y1 = self.point1.x, self.point1.y
        x2, y2 = self.point2.x, self.point2.y
        self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()

    def _translate(self, offset):
        self.point1._translate(offset)
        self.point2._translate(offset)

    def _scale(self, factor):
        center = Utilities.get_2D_midpoint(self.point1, self.point2)
        length = Utilities.get_2D_distance(self.point1, self.point2)
        new_length = factor * length
        # Calculate the direction vector from the center to point1
        dx = self.point1.x - center.x
        dy = self.point1.y - center.y
        direction1 = (dx / length, dy / length)
        # Calculate the direction vector from the center to point2
        dx = self.point2.x - center.x
        dy = self.point2.y - center.y
        direction2 = (dx / length, dy / length)
        # Calculate the new positions of the points
        new_point1_x = center.x + direction1[0] * new_length
        new_point1_y = center.y + direction1[1] * new_length
        new_point2_x = center.x + direction2[0] * new_length
        new_point2_y = center.y + direction2[1] * new_length
        # Set the points to their new positions
        self.point1.x = new_point1_x
        self.point1.y = new_point1_y
        self.point2.x = new_point2_x
        self.point2.y = new_point2_y
        # print(f"Segment length: {Utilities.get_2D_distance(self.point1, self.point2)}\nExpected length: {length * factor}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
        # self.point1.zoom()
        # self.point2.zoom()
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        # self._translate(self.canvas.offset)
        
    def get_state(self):
        p1 = self.point1.original_position
        p2 = self.point2.original_position
        state = {"class": self.get_class_name(), "args": {"point1": {"x": p1.x, "y": p1.y}, "point2": {"x": p2.x, "y": p2.y}, "name": self.name}}
        return state


class Triangle(Drawable):
    def __init__(self, x1, y1, x2, y2, x3, y3, canvas, name="T", color=default_color):
        name = "T" if name == "" else name
        self._create_segments(x1, y1, x2, y2, x3, y3, canvas, name, color)
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    def _create_segments(self, x1, y1, x2, y2, x3, y3, canvas, name, color):
        s1 = canvas.get_segment(x1, y1, x2, y2)
        if s1:
            self.segment1 = s1
        else:
            self.segment1 = Segment(x1, y1, x2, y2, name=f"{name}-S1", color=color, canvas=canvas)
            canvas.add_drawable(self.segment1)
        s2 = canvas.get_segment(x2, y2, x3, y3)
        if s2:
            self.segment2 = s2
        else:
            self.segment2 = Segment(x2, y2, x3, y3, name=f"{name}-S2", color=color, canvas=canvas)
            canvas.add_drawable(self.segment2)
        s3 = canvas.get_segment(x3, y3, x1, y1)
        if s3:
            self.segment3 = s3
        else:
            self.segment3 = Segment(x3, y3, x1, y1, name=f"{name}-S3", color=color, canvas=canvas)
            canvas.add_drawable(self.segment3)

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment1.canvas = value
        self.segment2.canvas = value
        self.segment3.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Triangle'

    def draw(self):
        self.segment1.draw()
        self.segment2.draw()
        self.segment3.draw()

    def _initialize(self):
        self.segment1._initialize()
        self.segment2._initialize()
        self.segment3._initialize()

    def _translate(self, offset):
        self.segment1._translate(offset)
        self.segment2._translate(offset)
        self.segment3._translate(offset)

    def _scale(self, factor):
        # initial_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # Compute the centroid of the triangle
        p1 = self.segment1.point1
        p2 = self.segment2.point1
        p3 = self.segment3.point1

        centroid = Position(
            (p1.x + p2.x + p3.x) / 3,
            (p1.y + p2.y + p3.y) / 3
        )
        # Translate points to origin
        self._translate(Position(-centroid.x, -centroid.y))
        # Scale
        p1._scale_coordinates(factor)
        p2._scale_coordinates(factor)
        p3._scale_coordinates(factor)
        # Translate back
        self._translate(Position(centroid.x, centroid.y))
        # actual_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # print(f"Actual triangle area: {actual_area}\nExpected triangle area: {initial_area * factor**2}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)
        self.point3._translate_towards(destination, displacement)

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
        # self.segment1.zoom()
        # self.segment2.zoom()
        # self.segment3.zoom()
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        # self._translate(self.canvas.offset)
        
    def get_state(self):
        p1 = self.segment1.point1.original_position
        p2 = self.segment2.point1.original_position
        p3 = self.segment3.point1.original_position
        state = {"class": self.get_class_name(), "args": {"point1": {"x": p1.x, "y": p1.y}, "point2": {"x": p2.x, "y": p2.y}, "point3": {"x": p3.x, "y": p3.y}, "name": self.name}}
        return state


class Rectangle(Drawable):
    def __init__(self, top_left, bottom_right, name="", color=default_color, canvas=None):
        self.name = name
        self.top_left = Point(top_left['x'], top_left['y'], color=color, canvas=canvas)
        self.bottom_right = Point(bottom_right['x'], bottom_right['y'], color=color, canvas=canvas)
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.top_left.canvas = value
        self.bottom_right.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Rectangle'

    def draw(self):
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        x = self.top_left.x
        y = self.top_left.y
        self.create_svg_element('rect', x=str(x), y=str(y), width=str(width), height=str(height), fill="none", stroke=self.color)

    def _initialize(self):
        self.top_left._initialize()
        self.bottom_right._initialize()

    def _translate(self, offset):
        self.top_left._translate(offset)
        self.bottom_right._translate(offset)

    def _scale(self, factor):
        #initial_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        center_x = (self.top_left.x + self.bottom_right.x) / 2
        center_y = (self.top_left.y + self.bottom_right.y) / 2
        self.top_left._translate(Position(-center_x, -center_y))
        self.top_left._scale_coordinates(factor)
        self.top_left._translate(Position(center_x, center_y))
        self.bottom_right._translate(Position(-center_x, -center_y))
        self.bottom_right._scale_coordinates(factor)
        self.bottom_right._translate(Position(center_x, center_y))
        #actual_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        #print(f"Actual rectangle area: {actual_area}\nExpected rectangle area: {initial_area * factor**2}")

    def zoom(self):
        if self.canvas:
            self.top_left.zoom()
            self.bottom_right.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        top_left = self.top_left
        bottom_right = self.bottom_right
        state = {"class": self.get_class_name(), "args": {"top_left": {"x": top_left.x, "y": top_left.y}, "bottom_right": {"x": bottom_right.x, "y": bottom_right.y}, "name": self.name}}
        return state


class Circle(Drawable):
    def __init__(self, center, radius, name="", color=default_color, canvas=None):
        self.name = name
        self.original_radius = radius
        self.center = Point(center['x'], center['y'], name=f"{name}-circle-center", color=color, canvas=canvas)
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Circle'

    def draw(self):
        radius = self.radius
        x, y = self.center.x, self.center.y
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(radius), fill="none", stroke=self.color)

    def _initialize(self):
        if self.canvas:
            self.radius = self.original_radius * self.canvas.scale_factor
        else:
            self.radius = self.original_radius
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.radius *= math.sqrt(factor)

    def zoom(self):
        if self.canvas:
            self.radius = self.original_radius * self.canvas.scale_factor
            self.center.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        radius = self.original_radius
        center = self.center.original_position
        state = {"class": self.get_class_name(), "args": {"center_point": {"x": center.x, "y": center.y}, "radius": radius}}
        return state


class Ellipse(Drawable):
    def __init__(self, center, rx, ry, name="", color=default_color, canvas=None):
        self.name = name
        self.original_rx = rx
        self.original_ry = ry
        self.center = Point(center['x'], center['y'], name=f"{name}-ellipse-center", color=color, canvas=canvas)
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Ellipse'

    def draw(self):
        rx = self.rx
        ry = self.ry
        x, y = self.center.x, self.center.y
        self.create_svg_element('ellipse', cx=str(x), cy=str(y), rx=str(rx), ry=str(ry), fill="none", stroke=self.color)

    def _initialize(self):
        if self.canvas:
            scale_factor = self.canvas.scale_factor
            self.rx = self.original_rx * scale_factor
            self.ry = self.original_ry * scale_factor
        else:
            self.rx = self.original_rx
            self.ry = self.original_ry
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.rx *= math.sqrt(factor)
        self.ry *= math.sqrt(factor)

    def zoom(self):
        if self.canvas:
            scale_factor = self.canvas.scale_factor
            self.rx = self.original_rx * scale_factor
            self.ry = self.original_ry * scale_factor
            self.center.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        rx = self.original_rx
        ry = self.original_ry
        center = self.center.original_position
        state = {"class": self.get_class_name(), "args": {"center_point": {"x": center.x, "y": center.y}, "radius_x": rx, "radius_y": ry, "name": self.name}}
        return state


class Vector(Drawable):
    def __init__(self, origin_x, origin_y, tip_x, tip_y, canvas, name="V", color=default_color):
        name = "V" if name == "" else name
        self.segment = Segment(origin_x, origin_y, tip_x, tip_y, canvas=canvas, name=name, color=color)
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Vector'

    def _initialize(self):
        self.segment._initialize()

    def _draw_tip_triangle(self):
        # Calculate the triangle points
        tip = self.segment.point2
        origin = self.segment.point1
        dx = tip.x - origin.x
        dy = tip.y - origin.y
        angle = math.atan2(dy, dx)
        side_length = default_point_size * 3  # Adjust to change the size of the tip
        half_base = side_length / 2
        height = math.sqrt(side_length**2 - half_base**2)
        # Calculate the triangle points
        x1, y1 = tip.x, tip.y
        x2, y2 = tip.x - height * math.cos(angle) - half_base * math.sin(angle), tip.y - height * math.sin(angle) + half_base * math.cos(angle)
        x3, y3 = tip.x - height * math.cos(angle) + half_base * math.sin(angle), tip.y - height * math.sin(angle) - half_base * math.cos(angle)
        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill=self.color, stroke=self.color)

    def draw(self):
        self.segment.draw()
        self._draw_tip_triangle()

    def _translate(self, offset):
        self.segment._translate(offset)

    def _scale(self, factor):
        self.segment._scale(factor)

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
        # self.segment.zoom()
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        # self._translate(self.canvas.offset)
        
    def get_state(self):
        origin = self.segment.point1.original_position
        tip = self.segment.point2.original_position
        state = {"class": self.get_class_name(), "args": {"origin": {"x": origin.x, "y": origin.y}, "tip": {"x": tip.x, "y": tip.y}, "name": self.name}}
        return state


class Function(Drawable):
    def __init__(self, canvas, name, function_string, start, end, step=default_point_size, color=default_color):
        self.name = name
        if start > end:
            start, end = end, start
        self.start = Point(start, self.function(start), name=f"{name}-start", canvas=canvas, color=color)
        self.end = Point(end, self.function(end), name=f"{name}-end", canvas=canvas, color=color)
        self.step = step
        self.function_string = function_string
        try:
            self.function = Utilities.parse_function_string(function_string)
        except Exception as e:
            raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Function'

    def _initialize(self):
        self.start._initialize()
        self.end._initialize()

    def _generate_values(self):
        # Ensure we don't have a step size of zero
        step = 1 if self.step == 0 else self.step
        # Get the function and scale factor
        f = self.function
        scale_factor = self.canvas.scale_factor
        # Calculate original and scaled start/end points
        start_original = self.start.original_position
        start_scaled = self.start
        end_original = self.end.original_position
        end_scaled = self.end
        # Calculate the number of steps
        steps = int((end_scaled.x + step - start_scaled.x) / step)
        # Calculate the scaled step size, checking for division by zero
        if steps != 0:
            scaled_step = (end_original.x - start_original.x) / steps
        else:
            scaled_step = 0
        # Calculate x and y values for each step
        x_orig_values = [start_original.x + i * scaled_step for i in range(steps + 1)]
        x_scaled_values = [(x - start_original.x) * scale_factor + start_scaled.x for x in x_orig_values]
        y_orig_values = [f(x) for x in x_orig_values]
        y_scaled_values = [-((y - start_original.y) * scale_factor) + start_scaled.y for y in y_orig_values]
        # Combine x and y values into positions and return
        values = [Position(x, y) for x, y in zip(x_scaled_values, y_scaled_values)]
        return values

    def draw(self):
        xy = self._generate_values()
        for i in range(len(xy) - 1):
            point1 = xy[i]
            point2 = xy[i + 1]
            self.create_svg_element('line', x1=str(point1.x), y1=str(point1.y), x2=str(point2.x), y2=str(point2.y), stroke=self.color)

    def _translate(self, offset):
        self.start._translate(offset)
        self.end._translate(offset)

    def _scale(self, factor):
        self.start._scale(factor)
        self.end._scale(factor)

    def zoom(self):
        self.start.zoom()
        self.end.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)

    def get_state(self):
        function_string = self.function_string
        start = self.start.original_position
        end = self.end.original_position
        state = {"class": self.get_class_name(), "args": {"function_string": function_string, "start": {"x": start.x, "y": start.y}, "end": {"x": end.x, "y": end.y}, "name": self.name}}
        return state