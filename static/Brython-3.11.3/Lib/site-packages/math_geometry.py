from config import default_color, default_point_size, point_label_font_size
from copy import deepcopy
from drawable import Drawable
from math_util import ExpressionValidator, MathUtil
from point import Position
import math


class Segment(Drawable):
    def __init__(self, p1, p2, canvas, color=default_color):
        self.point1 = p1
        self.point2 = p2
        self.line_formula = self._calculate_line_algebraic_formula()
        name = self.point1.name + self.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()
        self.children = []

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Segment'

    def _calculate_line_algebraic_formula(self):
        p1 = self.point1
        p2 = self.point2
        line_formula = MathUtil.get_line_formula(p1.original_position.x, p1.original_position.y, p2.original_position.x, p2.original_position.y)
        return line_formula

    def _any_segment_part_visible_in_canvas_area(self):
        p1 = self.point1
        p2 = self.point2
        return self.canvas.is_point_within_canvas_visible_area(p1.x, p1.y) or \
            self.canvas.is_point_within_canvas_visible_area(p2.x, p2.y) or \
            self.canvas.any_segment_part_visible_in_canvas_area(p1.x, p1.y, p2.x, p2.y)

    def is_visible(self):
        hidden_by_children = True if self.children else False
        return not hidden_by_children and self._any_segment_part_visible_in_canvas_area()

    def draw(self):
        if self.is_visible():
            x1, y1 = self.point1.x, self.point1.y
            x2, y2 = self.point2.x, self.point2.y
            self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()

    def _translate(self, offset):
        self.point1._translate(offset)
        self.point2._translate(offset)

    def _scale(self, factor):
        center = MathUtil.get_2D_midpoint(self.point1, self.point2)
        length = MathUtil.get_2D_distance(self.point1, self.point2)
        new_length = factor * length
        # Calculate the direction vector from the center to point1
        dx = self.point1.x - center.x
        dy = self.point1.y - center.y
        direction1 = (dx / length, dy / length)
        # Calculate the direction vector from the center to point2
        dx = self.point2.x - center.x
        dy = self.point2.y - center.y
        direction2 = (dx / length, dy / length)
        # Calculate the new positions of the points
        new_point1_x = center.x + direction1[0] * new_length
        new_point1_y = center.y + direction1[1] * new_length
        new_point2_x = center.x + direction2[0] * new_length
        new_point2_y = center.y + direction2[1] * new_length
        # Set the points to their new positions
        self.point1.x = new_point1_x
        self.point1.y = new_point1_y
        self.point2.x = new_point2_x
        self.point2.y = new_point2_y
        # print(f"Segment length: {Utilities.get_2D_distance(self.point1, self.point2)}\nExpected length: {length * factor}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
        # self.point1.zoom()
        # self.point2.zoom()
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        # self._translate(self.canvas.offset)
        
    def get_state(self):
        points_names = sorted([self.point1.name, self.point2.name])
        state = {"name": self.name, "args": {"p1": points_names[0], "p2": points_names[1], "line_formula": self.line_formula}}
        return state

    def __deepcopy__(self, memo):
        # Check if the segment has already been deep copied
        if id(self) in memo:
            return memo[id(self)]

        # Deepcopy points that define the segment
        new_p1 = deepcopy(self.point1, memo)
        new_p2 = deepcopy(self.point2, memo)
        # Create a new Segment instance with the copied points
        new_segment = Segment(new_p1, new_p2, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_segment

        # Handle children
        new_segment.children = []
        for child in self.children:
            # Check if the child segment has already been deep copied
            if id(child) in memo:
                new_segment.children.append(memo[id(child)])
            else:
                # If not already deep copied, deep copy and store in memo
                copied_child = deepcopy(child, memo)
                memo[id(child)] = copied_child
                new_segment.children.append(copied_child)

        return new_segment


class Triangle(Drawable):
    def __init__(self, segment1, segment2, segment3, canvas, color=default_color):
        self.segment1 = segment1
        self.segment2 = segment2
        self.segment3 = segment3
        name = segment1.point1.name + segment1.point2.name + segment2.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment1.canvas = value
        self.segment2.canvas = value
        self.segment3.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Triangle'

    def draw(self):
        pass   # Drawing is done by the canvas for the segments

    def _initialize(self):
        self.segment1._initialize()
        self.segment2._initialize()
        self.segment3._initialize()

    def _translate(self, offset):
        self.segment1._translate(offset)
        self.segment2._translate(offset)
        self.segment3._translate(offset)

    def _scale(self, factor):
        # initial_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # Compute the centroid of the triangle
        p1 = self.segment1.point1
        p2 = self.segment2.point1
        p3 = self.segment3.point1

        centroid = Position(
            (p1.x + p2.x + p3.x) / 3,
            (p1.y + p2.y + p3.y) / 3
        )
        # Translate points to origin
        self._translate(Position(-centroid.x, -centroid.y))
        # Scale
        p1._scale_coordinates(factor)
        p2._scale_coordinates(factor)
        p3._scale_coordinates(factor)
        # Translate back
        self._translate(Position(centroid.x, centroid.y))
        # actual_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # print(f"Actual triangle area: {actual_area}\nExpected triangle area: {initial_area * factor**2}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)
        self.point3._translate_towards(destination, displacement)

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        
    def get_state(self):
        # Collect all point names into a list
        point_names = [
            self.segment1.point1.name, self.segment1.point2.name,
            self.segment2.point1.name, self.segment2.point2.name,
            self.segment3.point1.name, self.segment3.point2.name
        ]
        # Find the most frequent point
        most_frequent_point = max(set(point_names), key=point_names.count)
        # Convert the list into a set to remove duplicates, then convert it back to a list and sort it
        point_names = sorted(list(set(point_names)))
        # Ensure that the list has at least 3 points by appending the most frequent point
        while len(point_names) < 3:
            point_names.append(most_frequent_point)
        state = {"name": self.name, "args": {"p1": point_names[0], "p2": point_names[1], "p3": point_names[2]}}
        return state

    def __deepcopy__(self, memo):
        # Check if the triangle has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        new_s1 = deepcopy(self.segment1, memo)
        new_s2 = deepcopy(self.segment2, memo)
        new_s3 = deepcopy(self.segment3, memo)
        new_triangle = Triangle(new_s1, new_s2, new_s3, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_triangle
        return new_triangle


class Rectangle(Drawable):
    def __init__(self, segment1, segment2, segment3, segment4, canvas, color=default_color):
        self.segment1 = segment1
        self.segment2 = segment2
        self.segment3 = segment3
        self.segment4 = segment4
        name = segment1.point1.name + segment1.point2.name + segment2.point2.name + segment3.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment1.canvas = value
        self.segment2.canvas = value
        self.segment3.canvas = value
        self.segment4.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Rectangle'

    def draw(self):
        pass  # Drawing is done by the canvas for the segments

    def _initialize(self):
        self.segment1._initialize()
        self.segment2._initialize()
        self.segment3._initialize()
        self.segment4._initialize()

    def _translate(self, offset):
        self.segment1._translate(offset)
        self.segment2._translate(offset)
        self.segment3._translate(offset)
        self.segment4._translate(offset)

    def _scale(self, factor):
        #initial_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        # Compute the centroid of the rectangle
        points = [self.segment1.point1, self.segment1.point2, self.segment2.point1, self.segment2.point2,
                self.segment3.point1, self.segment3.point2, self.segment4.point1, self.segment4.point2]
        centroid = Position(
            sum(point.x for point in points) / len(points),
            sum(point.y for point in points) / len(points)
        )
        # Translate points to origin
        self._translate(Position(-centroid.x, -centroid.y))
        # Scale
        for point in points:
            point._scale_coordinates(factor)
        # Translate back
        self._translate(Position(centroid.x, centroid.y))
        #actual_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        #print(f"Actual rectangle area: {actual_area}\nExpected rectangle area: {initial_area * factor**2}")

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points

    def get_state(self):
        # Collect all point names into a list
        point_names = [
            self.segment1.point1.name, self.segment1.point2.name,
            self.segment2.point1.name, self.segment2.point2.name,
            self.segment3.point1.name, self.segment3.point2.name,
            self.segment4.point1.name, self.segment4.point2.name
        ]
        # Convert the list into a set to remove duplicates, then convert it back to a list and sort it
        points_names = sorted(list(set(point_names)))
        state = {"name": self.name, "args": {"p1": points_names[0], "p2": points_names[1], "p3": points_names[2], "p4": points_names[3]}}
        return state

    def __deepcopy__(self, memo):
        # Check if the triangle has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        new_s1 = deepcopy(self.segment1, memo)
        new_s2 = deepcopy(self.segment2, memo)
        new_s3 = deepcopy(self.segment3, memo)
        new_s4 = deepcopy(self.segment4, memo)
        new_rectangle = Rectangle(new_s1, new_s2, new_s3, new_s4, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_rectangle
        return new_rectangle


class Circle(Drawable):
    def __init__(self, center_point, radius, canvas, color=default_color):
        self.center = center_point
        self.radius = radius
        self.circle_formula = self._calculate_circle_algebraic_formula()
        name = f"{self.center.name}({str(self.radius)})"
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Circle'

    def draw(self):
        radius = self.drawn_radius
        x, y = self.center.x, self.center.y
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(radius), fill="none", stroke=self.color)

    def _initialize(self):
        self.drawn_radius = self.radius * self.canvas.scale_factor
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.drawn_radius *= math.sqrt(factor)

    def _calculate_circle_algebraic_formula(self):
        x = self.center.original_position.x
        y = self.center.original_position.y
        r = self.radius
        circle_formula = MathUtil.get_circle_formula(x, y, r)
        return circle_formula

    def zoom(self):
        self.drawn_radius = self.radius * self.canvas.scale_factor
    
    def pan(self):
        pass   # Panning is done by the canvas for the center point 
        
    def get_state(self):
        radius = self.radius
        center = self.center.name
        state = {"name": self.name, "args": {"center": center, "radius": radius, "circle_formula": self.circle_formula}}
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        # Deep copy the center point
        new_center = deepcopy(self.center, memo)
        # Create a new Circle instance with the copied center point and other properties
        new_circle = Circle(new_center, self.radius, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_circle
        return new_circle


class Ellipse(Drawable):
    def __init__(self, center_point, radius_x, radius_y, canvas, color=default_color):
        self.center = center_point
        self.radius_x = radius_x
        self.radius_y = radius_y
        self.ellipse_formula = self._calculate_ellipse_algebraic_formula()
        name = f"{self.center.name}({str(self.radius_x)}, {str(self.radius_y)})"
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Ellipse'

    def draw(self):
        rx = self.drawn_radius_x
        ry = self.drawn_radius_y
        x, y = self.center.x, self.center.y
        self.create_svg_element('ellipse', cx=str(x), cy=str(y), rx=str(rx), ry=str(ry), fill="none", stroke=self.color)

    def _initialize(self):
        scale_factor = self.canvas.scale_factor
        self.drawn_radius_x = self.radius_x * scale_factor
        self.drawn_radius_y = self.radius_y * scale_factor
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.drawn_radius_x *= math.sqrt(factor)
        self.drawn_radius_y *= math.sqrt(factor)

    def _calculate_ellipse_algebraic_formula(self):
        x = self.center.original_position.x
        y = self.center.original_position.y
        rx = self.radius_x
        ry = self.radius_y
        ellipse_formula = MathUtil.get_ellipse_formula(x, y, rx, ry)
        return ellipse_formula

    def zoom(self):
        scale_factor = self.canvas.scale_factor
        self.drawn_radius_x = self.radius_x * scale_factor
        self.drawn_radius_y = self.radius_y * scale_factor
        # Zooming is done by the canvas for the center point
    
    def pan(self):
        pass   # Panning is done by the canvas for the center point        
        
    def get_state(self):
        rx = self.radius_x
        ry = self.radius_y
        center = self.center.name
        state = {"name": self.name, "args": {"center": center, "radius_x": rx, "radius_y": ry, "ellipse_formula": self.ellipse_formula}}
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        # Deep copy the center point
        new_center = deepcopy(self.center, memo)
        # Create a new Ellipse instance with the copied center point and other properties
        new_ellipse = Ellipse(new_center, self.radius_x, self.radius_y, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_ellipse
        return new_ellipse


class Vector(Drawable):
    def __init__(self, origin, tip, canvas, color=default_color):
        self.segment = Segment(origin, tip, canvas=canvas, color=color)
        name = self.segment.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Vector'

    def _initialize(self):
        self.segment._initialize()

    def _draw_tip_triangle(self):
        # Calculate the triangle points
        tip = self.segment.point2
        origin = self.segment.point1
        dx = tip.x - origin.x
        dy = tip.y - origin.y
        angle = math.atan2(dy, dx)
        side_length = default_point_size * 4  # Adjust to change the size of the tip
        half_base = side_length / 2
        height = math.sqrt(side_length**2 - half_base**2)
        # Calculate the triangle points
        x1, y1 = tip.x, tip.y
        x2, y2 = tip.x - height * math.cos(angle) - half_base * math.sin(angle), tip.y - height * math.sin(angle) + half_base * math.cos(angle)
        x3, y3 = tip.x - height * math.cos(angle) + half_base * math.sin(angle), tip.y - height * math.sin(angle) - half_base * math.cos(angle)
        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill=self.color, stroke=self.color)

    def draw(self):
        self.segment.draw()
        self._draw_tip_triangle()

    def _translate(self, offset):
        self.segment._translate(offset)

    def _scale(self, factor):
        self.segment._scale(factor)

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
      
    def get_state(self):
        origin = self.segment.point1.name
        tip = self.segment.point2.name
        state = {"name": self.name, "args": {"origin": origin, "tip": tip, "line_formula": self.segment.line_formula}}
        return state
    
    def __deepcopy__(self, memo):
        # Check if the vector has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        # Deepcopy the origin and tip points that define the vector
        new_origin = deepcopy(self.segment.point1, memo)
        new_tip = deepcopy(self.segment.point2, memo)
        # Create a new Vector instance with the deep-copied points
        new_vector = Vector(new_origin, new_tip, self.canvas, color=self.color)
        # Store the newly created vector in the memo dictionary
        memo[id(self)] = new_vector
        return new_vector


class Function(Drawable):
    def __init__(self, function_string, canvas, name, step=default_point_size, color=default_color, left_bound=None, right_bound=None):
        self.step = step
        self.function_string = ExpressionValidator.fix_math_expression(function_string)
        self.left_bound = left_bound
        self.right_bound = right_bound
        try:
            self.function = ExpressionValidator.parse_function_string(function_string)
        except Exception as e:
            raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Function'

    def _initialize(self):
        pass

    def _scaled_to_original(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        original_x = (x - origin.x) / scale_factor
        original_y = (y - origin.y) / -scale_factor
        return Position(original_x, original_y)
    
    def _original_to_scaled(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        scaled_x = origin.x + x * scale_factor
        scaled_y = origin.y - y * scale_factor
        return Position(scaled_x, scaled_y)

    def _generate_values(self):
        # Use provided bounds if they exist, otherwise default to the visible bounds of the canvas
        left_bound = self.left_bound if self.left_bound is not None else self.canvas.cartesian2axis.get_visible_left_bound()
        right_bound = self.right_bound if self.right_bound is not None else self.canvas.cartesian2axis.get_visible_right_bound()
        top_bound = self.canvas.cartesian2axis.get_visible_top_bound()
        bottom_bound = self.canvas.cartesian2axis.get_visible_bottom_bound()
        # Get the function and scale factor
        f = self.function
        scale_factor = self.canvas.scale_factor
        # Ensure we don't have a step size of zero
        step = max(1, self.step)
        # Calculate the number of steps to optimize performance according to zoom level
        num_steps = int((right_bound - left_bound) * scale_factor / step)
        # Calculate x values within the bounds with the specified step
        x_values = [left_bound + i * step / scale_factor for i in range(num_steps)]
        # Filter out x_values where f(x) is not within the vertical bounds
        filtered_values = [(x, f(x)) for x in x_values if bottom_bound <= f(x) <= top_bound]
        # Convert these original x, y values into scaled positions
        scaled_values = [self._original_to_scaled(x, y) for x, y in filtered_values]
        return scaled_values

    def draw(self):
        xy = self._generate_values()
        if len(xy) < 2:
            return
        # Construct SVG path data
        path_d = "M" + " ".join(f"{p.x},{p.y}" for p in xy)
        # Create SVG path element for the function
        self.create_svg_element('path', d=path_d, stroke=self.color, fill="none")
        # Draw function name label
        if len(xy) > 1:
            label_offset_x = (1 + len(self.name)) * point_label_font_size / 2
            label_x = xy[1].x - label_offset_x
            label_y = xy[1].y
            self.create_svg_element('text', x=str(label_x), y=str(label_y), fill=self.color,
                                    text_content=self.name, text_font_size=point_label_font_size)

    def zoom(self):
        pass   # Zooming is done by the canvas for the start and end points
    
    def pan(self):
        pass   # Panning is done by the canvas for the start and end points

    def get_state(self):
        function_string = self.function_string
        state = {"name": self.name, "args": {"function_string": function_string}}
        return state

    def __deepcopy__(self, memo):
        # Check if the function has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        # Create a new Function instance with the same properties, but do not deep copy the canvas
        new_function = Function(
            function_string=self.function_string,
            canvas=self.canvas,  # Keep the same canvas reference
            name=self.name,
            step=self.step,
            color=self.color,
            left_bound=self.left_bound,
            right_bound=self.right_bound
        )
        # Add the new object to the memo dictionary to avoid recursive deep copies
        memo[id(self)] = new_function
        return new_function