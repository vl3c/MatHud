from config import default_color, default_point_size, point_label_font_size
from copy import deepcopy
from drawable import Drawable
from expression_validator import ExpressionValidator
from math_util import MathUtil
from point import Position
import math


class Segment(Drawable):
    def __init__(self, p1, p2, canvas, color=default_color):
        self.point1 = p1
        self.point2 = p2
        self.line_formula = self._calculate_line_algebraic_formula()
        name = self.point1.name + self.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()
        self.children = set()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Segment'

    def _calculate_line_algebraic_formula(self):
        p1 = self.point1
        p2 = self.point2
        line_formula = MathUtil.get_line_formula(p1.original_position.x, p1.original_position.y, p2.original_position.x, p2.original_position.y)
        return line_formula

    def _any_segment_part_visible_in_canvas_area(self):
        p1 = self.point1
        p2 = self.point2
        return self.canvas.is_point_within_canvas_visible_area(p1.x, p1.y) or \
            self.canvas.is_point_within_canvas_visible_area(p2.x, p2.y) or \
            self.canvas.any_segment_part_visible_in_canvas_area(p1.x, p1.y, p2.x, p2.y)

    def is_visible(self):
        hidden_by_children = True if self.children else False
        return not hidden_by_children and self._any_segment_part_visible_in_canvas_area()

    def draw(self):
        if self.is_visible():
            x1, y1 = self.point1.x, self.point1.y
            x2, y2 = self.point2.x, self.point2.y
            self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
        # self.point1.zoom()
        # self.point2.zoom()
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        # self._translate(self.canvas.offset)
        
    def get_state(self):
        points_names = sorted([self.point1.name, self.point2.name])
        state = {"name": self.name, "args": {"p1": points_names[0], "p2": points_names[1], "line_formula": self.line_formula}}
        return state

    def __deepcopy__(self, memo):
        # Check if the segment has already been deep copied
        if id(self) in memo:
            return memo[id(self)]

        # Deepcopy points that define the segment
        new_p1 = deepcopy(self.point1, memo)
        new_p2 = deepcopy(self.point2, memo)
        # Create a new Segment instance with the copied points
        new_segment = Segment(new_p1, new_p2, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_segment

        # Handle children
        new_segment.children = set()
        for child in self.children:
            # Check if the child segment has already been deep copied
            if id(child) in memo:
                new_segment.children.add(memo[id(child)])
            else:
                # If not already deep copied, deep copy and store in memo
                copied_child = deepcopy(child, memo)
                memo[id(child)] = copied_child
                new_segment.children.add(copied_child)

        return new_segment

    def translate(self, x_offset, y_offset):
        self.point1.original_position.x += x_offset
        self.point1.original_position.y += y_offset
        self.point2.original_position.x += x_offset
        self.point2.original_position.y += y_offset
        self._initialize()

    def _get_midpoint(self):
        """Calculate the midpoint of the segment"""
        x = (self.point1.original_position.x + self.point2.original_position.x) / 2
        y = (self.point1.original_position.y + self.point2.original_position.y) / 2
        return (x, y)

    def _rotate_point_around_center(self, point, center_x, center_y, angle_rad):
        """Rotate a single point around a center by given angle in radians"""
        dx = point.original_position.x - center_x
        dy = point.original_position.y - center_y
        
        point.original_position.x = center_x + (dx * math.cos(angle_rad) - dy * math.sin(angle_rad))
        point.original_position.y = center_y + (dx * math.sin(angle_rad) + dy * math.cos(angle_rad))

    def rotate(self, angle):
        """Rotate the segment around its midpoint by the given angle in degrees"""
        # Get midpoint
        center_x, center_y = self._get_midpoint()
        
        # Convert angle to radians
        angle_rad = math.radians(angle)
        
        # Rotate both endpoints
        self._rotate_point_around_center(self.point1, center_x, center_y, angle_rad)
        self._rotate_point_around_center(self.point2, center_x, center_y, angle_rad)
        
        # Update line formula and initialize
        self.line_formula = self._calculate_line_algebraic_formula()
        self._initialize()


class Vector(Drawable):
    def __init__(self, origin, tip, canvas, color=default_color):
        self.segment = Segment(origin, tip, canvas=canvas, color=color)
        name = self.segment.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Vector'

    def _initialize(self):
        self.segment._initialize()

    def _draw_tip_triangle(self):
        # Calculate the triangle points
        tip = self.segment.point2
        origin = self.segment.point1
        dx = tip.x - origin.x
        dy = tip.y - origin.y
        angle = math.atan2(dy, dx)
        side_length = default_point_size * 4  # Adjust to change the size of the tip
        half_base = side_length / 2
        height = math.sqrt(side_length**2 - half_base**2)
        # Calculate the triangle points
        x1, y1 = tip.x, tip.y
        x2, y2 = tip.x - height * math.cos(angle) - half_base * math.sin(angle), tip.y - height * math.sin(angle) + half_base * math.cos(angle)
        x3, y3 = tip.x - height * math.cos(angle) + half_base * math.sin(angle), tip.y - height * math.sin(angle) - half_base * math.cos(angle)
        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill=self.color, stroke=self.color)

    def draw(self):
        self.segment.draw()
        self._draw_tip_triangle()

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
      
    def get_state(self):
        origin = self.segment.point1.name
        tip = self.segment.point2.name
        state = {"name": self.name, "args": {"origin": origin, "tip": tip, "line_formula": self.segment.line_formula}}
        return state
    
    def __deepcopy__(self, memo):
        # Check if the vector has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        # Deepcopy the origin and tip points that define the vector
        new_origin = deepcopy(self.segment.point1, memo)
        new_tip = deepcopy(self.segment.point2, memo)
        # Create a new Vector instance with the deep-copied points
        new_vector = Vector(new_origin, new_tip, self.canvas, color=self.color)
        # Store the newly created vector in the memo dictionary
        memo[id(self)] = new_vector
        return new_vector

    def translate(self, x_offset, y_offset):
        self.segment.translate(x_offset, y_offset)
        self._initialize()

    def rotate(self, angle):
        """Rotate the vector around its origin by the given angle in degrees"""
        # Use segment's rotation method to rotate the line portion
        self.segment.rotate(angle)
        # Initialize to update any dependent properties (like the tip triangle)
        self._initialize()


class RotatablePolygon(Drawable):
    """Base class for polygons that can be rotated around their center"""
    
    def _get_shape_center(self, points):
        """Calculate center point of a shape given its vertices"""
        x_coords = [p.original_position.x for p in points]
        y_coords = [p.original_position.y for p in points]
        return (sum(x_coords) / len(x_coords), 
                sum(y_coords) / len(y_coords))

    def _rotate_point_around_center(self, point, center_x, center_y, angle_rad):
        """Rotate a single point around a center by given angle in radians"""
        dx = point.original_position.x - center_x
        dy = point.original_position.y - center_y
        
        point.original_position.x = center_x + (dx * math.cos(angle_rad) - dy * math.sin(angle_rad))
        point.original_position.y = center_y + (dx * math.sin(angle_rad) + dy * math.cos(angle_rad))

    def get_vertices(self):
        """Abstract method to be implemented by subclasses to return their vertices"""
        raise NotImplementedError("Subclasses must implement get_vertices()")

    def rotate(self, angle):
        """Rotate the polygon around its center by the given angle in degrees"""
        points_to_rotate = self.get_vertices()
        center_x, center_y = self._get_shape_center(points_to_rotate)
        angle_rad = math.radians(angle)
        
        for point in points_to_rotate:
            self._rotate_point_around_center(point, center_x, center_y, angle_rad)
            
        self._initialize()


class Triangle(RotatablePolygon):
    def __init__(self, segment1, segment2, segment3, canvas, color=default_color):
        if not self._segments_form_triangle(segment1, segment2, segment3):
            raise ValueError("The segments do not form a triangle")
        self.segment1 = segment1
        self.segment2 = segment2
        self.segment3 = segment3
        name = segment1.point1.name + segment1.point2.name + segment2.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment1.canvas = value
        self.segment2.canvas = value
        self.segment3.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Triangle'

    def draw(self):
        pass   # Drawing is done by the canvas for the segments

    def _initialize(self):
        self.segment1._initialize()
        self.segment2._initialize()
        self.segment3._initialize()

    def _segments_form_triangle(self, s1, s2, s3):
        points = [s1.point1, s1.point2, s2.point1, s2.point2, s3.point1, s3.point2]
        for point in points:
            if points.count(point) != 2:
                return False
        return True
    
    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points
        
    def get_state(self):
        # Collect all point names into a list
        point_names = [
            self.segment1.point1.name, self.segment1.point2.name,
            self.segment2.point1.name, self.segment2.point2.name,
            self.segment3.point1.name, self.segment3.point2.name
        ]
        # Find the most frequent point
        most_frequent_point = max(set(point_names), key=point_names.count)
        # Convert the list into a set to remove duplicates, then convert it back to a list and sort it
        point_names = sorted(list(set(point_names)))
        # Ensure that the list has at least 3 points by appending the most frequent point
        while len(point_names) < 3:
            point_names.append(most_frequent_point)
        state = {"name": self.name, "args": {"p1": point_names[0], "p2": point_names[1], "p3": point_names[2]}}
        return state

    def __deepcopy__(self, memo):
        # Check if the triangle has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        new_s1 = deepcopy(self.segment1, memo)
        new_s2 = deepcopy(self.segment2, memo)
        new_s3 = deepcopy(self.segment3, memo)
        new_triangle = Triangle(new_s1, new_s2, new_s3, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_triangle
        return new_triangle

    def translate(self, x_offset, y_offset):
        # Translate each unique point only once
        unique_points = {self.segment1.point1, self.segment1.point2, self.segment2.point2}
        
        for point in unique_points:
            point.translate(x_offset, y_offset)
        
        self._initialize()

    def get_vertices(self):
        """Return the set of unique vertices of the triangle"""
        return {
            self.segment1.point1, self.segment1.point2,
            self.segment2.point1, self.segment2.point2,
            self.segment3.point1, self.segment3.point2
        }


class Rectangle(RotatablePolygon):
    def __init__(self, segment1, segment2, segment3, segment4, canvas, color=default_color):
        if not self._segments_form_rectangle(segment1, segment2, segment3, segment4):
            raise ValueError("The segments do not form a rectangle")
        if not MathUtil.is_rectangle(segment1.point1.original_position.x, segment1.point1.original_position.y, 
                                 segment2.point1.original_position.x, segment2.point1.original_position.y,
                                 segment3.point1.original_position.x, segment3.point1.original_position.y, 
                                 segment4.point1.original_position.x, segment4.point1.original_position.y):
            raise ValueError("The quadrilateral formed by the segments is not a rectangle")
        self.segment1 = segment1
        self.segment2 = segment2
        self.segment3 = segment3
        self.segment4 = segment4
        name = segment1.point1.name + segment1.point2.name + segment2.point2.name + segment3.point2.name
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment1.canvas = value
        self.segment2.canvas = value
        self.segment3.canvas = value
        self.segment4.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Rectangle'

    def draw(self):
        pass  # Drawing is done by the canvas for the segments

    def _initialize(self):
        self.segment1._initialize()
        self.segment2._initialize()
        self.segment3._initialize()
        self.segment4._initialize()

    def _segments_form_rectangle(self, s1, s2, s3, s4):
        # Check if the end point of one segment is the start point of the next
        correct_connections = (
            s1.point2 == s2.point1 and
            s2.point2 == s3.point1 and
            s3.point2 == s4.point1 and
            s4.point2 == s1.point1
        )
        return correct_connections

    def zoom(self):
        pass   # Zooming is done by the canvas for the segment points
    
    def pan(self):
        pass   # Panning is done by the canvas for the segment points

    def get_state(self):
        # Collect all point names into a list
        point_names = [
            self.segment1.point1.name, self.segment1.point2.name,
            self.segment2.point1.name, self.segment2.point2.name,
            self.segment3.point1.name, self.segment3.point2.name,
            self.segment4.point1.name, self.segment4.point2.name
        ]
        # Convert the list into a set to remove duplicates, then convert it back to a list and sort it
        points_names = sorted(list(set(point_names)))
        state = {"name": self.name, "args": {"p1": points_names[0], "p2": points_names[1], "p3": points_names[2], "p4": points_names[3]}}
        return state

    def __deepcopy__(self, memo):
        # Check if the triangle has already been deep copied
        if id(self) in memo:
            return memo[id(self)]
        new_s1 = deepcopy(self.segment1, memo)
        new_s2 = deepcopy(self.segment2, memo)
        new_s3 = deepcopy(self.segment3, memo)
        new_s4 = deepcopy(self.segment4, memo)
        new_rectangle = Rectangle(new_s1, new_s2, new_s3, new_s4, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_rectangle
        return new_rectangle

    def translate(self, x_offset, y_offset):
        self.segment1.translate(x_offset, y_offset)
        self.segment2.translate(x_offset, y_offset)
        self.segment3.translate(x_offset, y_offset)
        self.segment4.translate(x_offset, y_offset)
        self._initialize()

    def get_vertices(self):
        """Return the set of unique vertices of the rectangle"""
        return {
            self.segment1.point1, self.segment1.point2,
            self.segment2.point1, self.segment2.point2,
            self.segment3.point1, self.segment3.point2,
            self.segment4.point1, self.segment4.point2
        }


class Circle(Drawable):
    def __init__(self, center_point, radius, canvas, color=default_color):
        self.center = center_point
        self.radius = radius
        self.circle_formula = self._calculate_circle_algebraic_formula()
        name = f"{self.center.name}({str(self.radius)})"
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Circle'

    def draw(self):
        radius = self.drawn_radius
        x, y = self.center.x, self.center.y
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(radius), fill="none", stroke=self.color)

    def _initialize(self):
        self.drawn_radius = self.radius * self.canvas.scale_factor
        self.center._initialize()

    def _calculate_circle_algebraic_formula(self):
        x = self.center.original_position.x
        y = self.center.original_position.y
        r = self.radius
        circle_formula = MathUtil.get_circle_formula(x, y, r)
        return circle_formula

    def zoom(self):
        self.drawn_radius = self.radius * self.canvas.scale_factor
    
    def pan(self):
        pass   # Panning is done by the canvas for the center point 
        
    def get_state(self):
        radius = self.radius
        center = self.center.name
        state = {"name": self.name, "args": {"center": center, "radius": radius, "circle_formula": self.circle_formula}}
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        # Deep copy the center point
        new_center = deepcopy(self.center, memo)
        # Create a new Circle instance with the copied center point and other properties
        new_circle = Circle(new_center, self.radius, canvas=self.canvas, color=self.color)
        memo[id(self)] = new_circle
        return new_circle

    def translate(self, x_offset, y_offset):
        self.center.original_position.x += x_offset
        self.center.original_position.y += y_offset
        self._initialize()

    def rotate(self, angle):
        pass


class Ellipse(Drawable):
    def __init__(self, center_point, radius_x, radius_y, canvas, rotation_angle=0, color=default_color):
        self.center = center_point
        self.radius_x = radius_x
        self.radius_y = radius_y
        self.rotation_angle = rotation_angle  # Initialize with provided angle
        self.ellipse_formula = self._calculate_ellipse_algebraic_formula()
        name = f"{self.center.name}({str(self.radius_x)}, {str(self.radius_y)})"
        super().__init__(name=name, color=color, canvas=canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Ellipse'

    def draw(self):
        rx = self.drawn_radius_x
        ry = self.drawn_radius_y
        x, y = self.center.x, self.center.y
        
        # Create transform attribute for rotation
        transform = f"rotate({-self.rotation_angle} {x} {y})" if self.rotation_angle != 0 else None
        
        # Add transform to SVG element if rotation exists
        if transform:
            self.create_svg_element('ellipse', 
                                  cx=str(x), cy=str(y), 
                                  rx=str(rx), ry=str(ry), 
                                  fill="none", stroke=self.color,
                                  transform=transform)
        else:
            self.create_svg_element('ellipse', 
                                  cx=str(x), cy=str(y), 
                                  rx=str(rx), ry=str(ry), 
                                  fill="none", stroke=self.color)

    def _initialize(self):
        scale_factor = self.canvas.scale_factor
        self.drawn_radius_x = self.radius_x * scale_factor
        self.drawn_radius_y = self.radius_y * scale_factor
        self.center._initialize()

    def _calculate_ellipse_algebraic_formula(self):
        x = self.center.original_position.x
        y = self.center.original_position.y
        return MathUtil.get_ellipse_formula(x, y, self.radius_x, self.radius_y, self.rotation_angle)

    def zoom(self):
        scale_factor = self.canvas.scale_factor
        self.drawn_radius_x = self.radius_x * scale_factor
        self.drawn_radius_y = self.radius_y * scale_factor
        # Zooming is done by the canvas for the center point
    
    def pan(self):
        pass   # Panning is done by the canvas for the center point        
        
    def get_state(self):
        """Return the state of the ellipse including rotation"""
        state = {
            "name": self.name, 
            "args": {
                "center": self.center.name, 
                "radius_x": self.radius_x, 
                "radius_y": self.radius_y, 
                "rotation_angle": self.rotation_angle,
                "ellipse_formula": self.ellipse_formula
            }
        }
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        # Deep copy the center point
        new_center = deepcopy(self.center, memo)
        # Create a new Ellipse instance with the copied center point and other properties
        new_ellipse = Ellipse(new_center, self.radius_x, self.radius_y, 
                             canvas=self.canvas, color=self.color, 
                             rotation_angle=self.rotation_angle)
        memo[id(self)] = new_ellipse
        return new_ellipse

    def translate(self, x_offset, y_offset):
        self.center.original_position.x += x_offset
        self.center.original_position.y += y_offset
        self._initialize()

    def rotate(self, angle):
        """Rotate the ellipse around its center by the given angle in degrees"""
        # Update rotation angle (keep it between 0 and 360 degrees)
        self.rotation_angle = (self.rotation_angle + angle) % 360
        
        # Update ellipse formula if needed
        self.ellipse_formula = self._calculate_ellipse_algebraic_formula()
        self._initialize()


class Function(Drawable):
    def __init__(self, function_string, canvas, name, step=default_point_size, color=default_color, left_bound=None, right_bound=None):
        self.step = step
        self.left_bound = left_bound
        self.right_bound = right_bound
        try:
            self.function_string = ExpressionValidator.fix_math_expression(function_string)
            self.function = ExpressionValidator.parse_function_string(function_string)
        except Exception as e:
            raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
        self._cached_points = None
        self._cache_valid = False
        self._last_scale = None
        self._last_bounds = None
        super().__init__(name=name, color=color, canvas=canvas)

    def _initialize(self):
        self._cached_points = None
        self._cache_valid = False
        self._last_scale = None
        self._last_bounds = None

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Function'

    def _scaled_to_original(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        original_x = (x - origin.x) / scale_factor
        original_y = (y - origin.y) / -scale_factor
        return Position(original_x, original_y)
    
    def _original_to_scaled(self, x, y):
        scale_factor = self.canvas.scale_factor
        origin = self.canvas.cartesian2axis.origin
        scaled_x = origin.x + x * scale_factor
        scaled_y = origin.y - y * scale_factor
        return Position(scaled_x, scaled_y)

    def _should_regenerate_points(self):
        current_scale = self.canvas.scale_factor
        current_bounds = (
            self.canvas.cartesian2axis.get_visible_left_bound(),
            self.canvas.cartesian2axis.get_visible_right_bound(),
            self.canvas.cartesian2axis.get_visible_top_bound(),
            self.canvas.cartesian2axis.get_visible_bottom_bound()
        )
        
        # First draw or bounds changed (panning)
        if (self._cached_points is None or 
            not self._cache_valid or 
            self._last_bounds != current_bounds):
            self._last_scale = current_scale
            self._last_bounds = current_bounds
            return True

        # Check if zoom change is significant enough
        if self._last_scale is not None:
            zoom_ratio = current_scale / self._last_scale
            # Only regenerate if zoom changed by more than 20% in either direction
            if zoom_ratio < 0.8 or zoom_ratio > 1.2:
                self._last_scale = current_scale
                self._last_bounds = current_bounds
                return True

        return False

    def _generate_values(self):
        visible_left = self.canvas.cartesian2axis.get_visible_left_bound()
        visible_right = self.canvas.cartesian2axis.get_visible_right_bound()
        
        # Clamp the bounds to visible area
        left_bound = max(visible_left, self.left_bound) if self.left_bound is not None else visible_left
        right_bound = min(visible_right, self.right_bound) if self.right_bound is not None else visible_right
        
        top_bound = self.canvas.cartesian2axis.get_visible_top_bound()
        bottom_bound = self.canvas.cartesian2axis.get_visible_bottom_bound()
        
        f = self.function
        points = []

        def evaluate_point(x, points, step):
            try:
                y = f(x)
                scaled_point = self._original_to_scaled(x, y)
                
                # If this is the first point, always include it
                if not points:
                    return scaled_point
                    
                # Get previous y value (use original, not scaled)
                prev_y = f(x - 2 *step)
                
                # Include points within bounds
                if bottom_bound <= y <= top_bound:
                    return scaled_point
                # Include the point if we just crossed a bound
                elif (prev_y <= top_bound and y > top_bound) or \
                    (prev_y >= bottom_bound and y < bottom_bound):
                    return scaled_point
                
                return None
            except (ZeroDivisionError, ValueError):
                return None

        def calculate_step_size():
            import re
            # Base step size depends on the visible range
            range_width = right_bound - left_bound
            base_step = range_width / 200  # Base 200 points across visible range
            
            # For trigonometric functions
            if 'sin' in self.function_string or 'cos' in self.function_string:
                # Extract frequency multiplier
                matches = re.findall(r'(?:sin|cos)\((\d+(?:\.\d+)?)\*?x\)', self.function_string)
                freq_multiplier = float(matches[0]) if matches else 1
                # Calculate period
                period = 2 * math.pi / freq_multiplier
                # Calculate how many periods are visible in the current range
                visible_periods = range_width / period
                
                if visible_periods <= 1:
                    # When zoomed into one period or less, use base_step for detail
                    return base_step
                else:
                    # Start with 200 points distributed across all visible periods
                    points_per_period = 400 / visible_periods
                    # Cap points per period to 200
                    points_per_period = min(200, points_per_period)
                    period_step = period / points_per_period
                    return period_step
                
            # For rapidly changing functions, adjust step size based on function type
            if any(pattern in self.function_string for pattern in ['x**2', 'x^2']):
                # Quadratic functions grow faster at the edges
                return base_step * 2  # Much smaller step size for quadratics
            
            return base_step

        step = calculate_step_size()
        x = left_bound
        last_point = None
        
        while x <= right_bound:
            point = evaluate_point(x, points, step)
            if point:
                # Add point if visibly different at current resolution
                pixel_diff = 0.5  # Reduced minimum pixel difference
                if not last_point or \
                   abs(point.x - last_point.x) > pixel_diff or \
                   abs(point.y - last_point.y) > pixel_diff:
                    points.append(point)
                    last_point = point
            x += step

        return points

    def draw(self):
        if self._should_regenerate_points():
            self._cached_points = self._generate_values()
            self._cache_valid = True
        
        points = self._cached_points
        if not points or len(points) < 2:
            return

        # Construct SVG path data with proper line connections
        path_d = "M" + " L".join(f"{p.x},{p.y}" for p in points)
        
        # Create SVG path element for the function
        self.create_svg_element('path', d=path_d, stroke=self.color, fill="none")
        
        # Draw function name label at first point
        label_offset_x = (1 + len(self.name)) * point_label_font_size / 2
        label_x = points[0].x - label_offset_x
        label_y = points[0].y
        self.create_svg_element('text', x=str(label_x), y=str(label_y), 
                              fill=self.color, text_content=self.name, 
                              text_font_size=point_label_font_size)

    def zoom(self):
        self._cache_valid = False
    
    def pan(self):
        self._cache_valid = False

    def get_state(self):
        function_string = self.function_string
        state = {"name": self.name, "args": {"function_string": function_string,"left_bound": self.left_bound, "right_bound": self.right_bound}}
        return state

    def __deepcopy__(self, memo):
        if id(self) in memo:
            return memo[id(self)]
        new_function = Function(
            function_string=self.function_string,
            canvas=self.canvas,
            name=self.name,
            step=self.step,
            color=self.color,
            left_bound=self.left_bound,
            right_bound=self.right_bound
        )
        new_function._cached_points = None
        new_function._cache_valid = False
        new_function._last_scale = None
        new_function._last_bounds = None
        memo[id(self)] = new_function
        return new_function

    def translate(self, x_offset, y_offset):
        if x_offset == 0 and y_offset == 0:
            return

        # Translate bounds if they exist
        if self.left_bound is not None:
            self.left_bound += x_offset
        if self.right_bound is not None:
            self.right_bound += x_offset

        try:
            # First handle horizontal translation by replacing x with (x - x_offset)
            if x_offset != 0:
                import re
                # Use all allowed functions from ExpressionValidator
                protected_funcs = sorted(ExpressionValidator.ALLOWED_FUNCTIONS, key=len, reverse=True)
                
                # Create a regex pattern that matches standalone x while protecting function names
                func_pattern = '|'.join(map(re.escape, protected_funcs))
                # Use word boundaries to match standalone 'x'
                pattern = rf'\b(x)\b|({func_pattern})'
                
                def replace_match(match):
                    if match.group(1):  # If it's a standalone 'x'
                        return f'(x - {x_offset})'
                    elif match.group(2):  # If it's a function name
                        return match.group(2)  # Return the function name unchanged
                    return match.group(0)
                    
                new_function_string = re.sub(pattern, replace_match, self.function_string)
            else:
                new_function_string = self.function_string

            # Then handle vertical translation by adding y_offset
            if y_offset != 0:
                new_function_string = f"({new_function_string}) + {y_offset}"

            # Update function string and parse new function
            self.function_string = ExpressionValidator.fix_math_expression(new_function_string)
            self.function = ExpressionValidator.parse_function_string(new_function_string)
            
            # Reset caches to force regeneration
            self._initialize()
            
        except Exception as e:
            print(f"Warning: Could not translate function: {str(e)}")
            # If translation fails, revert bounds
            if self.left_bound is not None:
                self.left_bound -= x_offset
            if self.right_bound is not None:
                self.right_bound -= x_offset

    def rotate(self, angle):
        pass
