from config import default_color, default_point_size
import math
from drawable import Drawable
from math_util import Utilities
from point import Position, Point

class Segment(Drawable):
    def __init__(self, point1, point2, color=default_color, canvas=None):
        self.point1 = Point(point1['x'], point1['y'], color=color, canvas=canvas)
        self.point2 = Point(point2['x'], point2['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()
    
    @classmethod
    def from_points(cls, point1, point2, color=default_color, canvas=None):
        dict_point1 = {"x": point1.x, "y": point1.y}
        dict_point2 = {"x": point2.x, "y": point2.y}
        return cls(dict_point1, dict_point2, color, canvas)
    
    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def name(self):
        return 'Segment'

    def draw(self):
        x1, y1 = self.point1.x, self.point1.y
        x2, y2 = self.point2.x, self.point2.y
        self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()

    def _translate(self, offset):
        self.point1._translate(offset)
        self.point2._translate(offset)

    def _scale(self, factor):
        print(f"self.point1: {self.point1}")
        print(f"self.point2: {self.point2}")
        center = Utilities.get_2D_midpoint(self.point1, self.point2)
        length = Utilities.get_2D_distance(self.point1, self.point2)
        new_length = factor * length
        # Calculate the direction vector from the center to point1
        dx = self.point1.x - center.x
        dy = self.point1.y - center.y
        direction1 = (dx / length, dy / length)
        # Calculate the direction vector from the center to point2
        dx = self.point2.x - center.x
        dy = self.point2.y - center.y
        direction2 = (dx / length, dy / length)
        # Calculate the new positions of the points
        new_point1_x = center.x + direction1[0] * new_length
        new_point1_y = center.y + direction1[1] * new_length
        new_point2_x = center.x + direction2[0] * new_length
        new_point2_y = center.y + direction2[1] * new_length
        # Set the points to their new positions
        self.point1.x = new_point1_x
        self.point1.y = new_point1_y
        self.point2.x = new_point2_x
        self.point2.y = new_point2_y
        # print(f"Segment length: {Utilities.get_2D_distance(self.point1, self.point2)}\nExpected length: {length * factor}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)

    def zoom(self):
        if self.canvas:
            self.point1.zoom()
            self.point2.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)


class Triangle(Drawable):
    def __init__(self, point1, point2, point3, color=default_color, canvas=None):
        self.point1 = Point(point1['x'], point1['y'], color=color, canvas=canvas)
        self.point2 = Point(point2['x'], point2['y'], color=color, canvas=canvas)
        self.point3 = Point(point3['x'], point3['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value
        self.point3.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def name(self):
        return 'Triangle'

    def draw(self):
        x1, y1 = self.point1.x, self.point1.y
        x2, y2 = self.point2.x, self.point2.y
        x3, y3 = self.point3.x, self.point3.y
        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill='none', stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()
        self.point3._initialize()

    def _translate(self, offset):
        self.point1._translate(offset)
        self.point2._translate(offset)
        self.point3._translate(offset)

    def _scale(self, factor):
        # initial_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # Compute the centroid of the triangle
        centroid = Position(
            (self.point1.x + self.point2.x + self.point3.x) / 3,
            (self.point1.y + self.point2.y + self.point3.y) / 3
        )
        # Translate points to origin
        self._translate(Position(-centroid.x, -centroid.y))
        # Scale
        self.point1._scale_coordinates(factor)
        self.point2._scale_coordinates(factor)
        self.point3._scale_coordinates(factor)
        # Translate back
        self._translate(Position(centroid.x, centroid.y))
        # actual_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # print(f"Actual triangle area: {actual_area}\nExpected triangle area: {initial_area * factor**2}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)
        self.point3._translate_towards(destination, displacement)

    def zoom(self):
        if self.canvas:
            self.point1.zoom()
            self.point2.zoom()
            self.point3.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)


class Rectangle(Drawable):
    def __init__(self, top_left, bottom_right, color=default_color, canvas=None):
        self.top_left = Point(top_left['x'], top_left['y'], color=color, canvas=canvas)
        self.bottom_right = Point(bottom_right['x'], bottom_right['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.top_left.canvas = value
        self.bottom_right.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def name(self):
        return 'Rectangle'

    def draw(self):
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        x = self.top_left.x
        y = self.top_left.y
        self.create_svg_element('rect', x=str(x), y=str(y), width=str(width), height=str(height), fill="none", stroke=self.color)

    def _initialize(self):
        self.top_left._initialize()
        self.bottom_right._initialize()

    def _translate(self, offset):
        self.top_left._translate(offset)
        self.bottom_right._translate(offset)

    def _scale(self, factor):
        #initial_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        center_x = (self.top_left.x + self.bottom_right.x) / 2
        center_y = (self.top_left.y + self.bottom_right.y) / 2
        self.top_left._translate(Position(-center_x, -center_y))
        self.top_left._scale_coordinates(factor)
        self.top_left._translate(Position(center_x, center_y))
        self.bottom_right._translate(Position(-center_x, -center_y))
        self.bottom_right._scale_coordinates(factor)
        self.bottom_right._translate(Position(center_x, center_y))
        #actual_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        #print(f"Actual rectangle area: {actual_area}\nExpected rectangle area: {initial_area * factor**2}")

    def zoom(self):
        if self.canvas:
            self.top_left.zoom()
            self.bottom_right.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)


class Circle(Drawable):
    def __init__(self, center, radius, color=default_color, canvas=None):
        self.original_radius = radius
        self.center = Point(center['x'], center['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def name(self):
        return 'Circle'

    def draw(self):
        radius = self.radius
        x, y = self.center.x, self.center.y
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(radius), fill="none", stroke=self.color)

    def _initialize(self):
        if self.canvas:
            self.radius = self.original_radius * self.canvas.scale_factor
        else:
            self.radius = self.original_radius
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.radius *= math.sqrt(factor)

    def zoom(self):
        if self.canvas:
            self.radius = self.original_radius * self.canvas.scale_factor
            self.center.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)


class Ellipse(Drawable):
    def __init__(self, center, rx, ry, color=default_color, canvas=None):
        self.original_rx = rx
        self.original_ry = ry
        self.center = Point(center['x'], center['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def name(self):
        return 'Ellipse'

    def draw(self):
        rx = self.rx
        ry = self.ry
        x, y = self.center.x, self.center.y
        self.create_svg_element('ellipse', cx=str(x), cy=str(y), rx=str(rx), ry=str(ry), fill="none", stroke=self.color)

    def _initialize(self):
        if self.canvas:
            scale_factor = self.canvas.scale_factor
            self.rx = self.original_rx * scale_factor
            self.ry = self.original_ry * scale_factor
        else:
            self.rx = self.original_rx
            self.ry = self.original_ry
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.rx *= math.sqrt(factor)
        self.ry *= math.sqrt(factor)

    def zoom(self):
        if self.canvas:
            scale_factor = self.canvas.scale_factor
            self.rx = self.original_rx * scale_factor
            self.ry = self.original_ry * scale_factor
            self.center.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)


class Vector(Drawable):
    def __init__(self, origin, tip, color=default_color, canvas=None):
        self.segment = Segment(origin, tip, color, canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def name(self):
        return 'Vector'

    def _initialize(self):
        self.segment._initialize()

    def _draw_tip_triangle(self):
        # Calculate the triangle points
        tip = self.segment.point2
        origin = self.segment.point1
        dx = tip.x - origin.x
        dy = tip.y - origin.y
        angle = math.atan2(dy, dx)
        side_length = default_point_size * 3  # Adjust to change the size of the tip
        half_base = side_length / 2
        height = math.sqrt(side_length**2 - half_base**2)
        # Calculate the triangle points
        x1, y1 = tip.x, tip.y
        x2, y2 = tip.x - height * math.cos(angle) - half_base * math.sin(angle), tip.y - height * math.sin(angle) + half_base * math.cos(angle)
        x3, y3 = tip.x - height * math.cos(angle) + half_base * math.sin(angle), tip.y - height * math.sin(angle) - half_base * math.cos(angle)
        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill=self.color, stroke=self.color)

    def draw(self):
        self.segment.draw()
        self._draw_tip_triangle()

    def _translate(self, offset):
        self.segment._translate(offset)

    def _scale(self, factor):
        self.segment._scale(factor)

    def zoom(self):
        if self.canvas:
            self.segment.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)


class Function(Drawable):
    def __init__(self, function_string, start, end, step=default_point_size, color=default_color, canvas=None):
        if start > end:
            start, end = end, start
        self.points = self._generate_points(function_string, start, end+step, step, color, canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        for point in self.points:
            point.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def name(self):
        return 'Function'

    def _initialize(self):
        for point in self.points:
            point._initialize()

    def _generate_points(self, function_string, start, end, step, color, canvas):
        step = 1 if step == 0 else step
        f = Utilities.parse_function_string(function_string)
        x_values = [start + i * step for i in range(int((end - start) / step))]
        y_values = [f(x) for x in x_values]
        points = [Point(x, y, canvas, color) for x, y in zip(x_values, y_values)]
        return points

    def draw(self):
        for i in range(len(self.points) - 1):
            point1 = self.points[i]
            point2 = self.points[i + 1]
            segment = Segment.from_points(point1, point2, self.color, self.canvas)
            print(f"segment: {segment.point1.x}, {segment.point1.y}, {segment.point2.x}, {segment.point2.y}")
            segment.draw()

    def _translate(self, offset):
        for point in self.points:
            point._translate(offset)

    def _scale(self, factor):
        for point in self.points:
            point._scale(factor)

    def zoom(self):
        for point in self.points:
            point.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)