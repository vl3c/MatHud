from config import default_color, default_point_size
import math
from drawable import Drawable
from math_util import Utilities
from point import Position, Point

class Segment(Drawable):
    def __init__(self, point1, point2, color=default_color, canvas=None):
        self.point1 = Point(point1['x'], point1['y'], color=color, canvas=canvas)
        self.point2 = Point(point2['x'], point2['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()
    
    @classmethod
    def from_points(cls, point1, point2, color=default_color, canvas=None):
        dict_point1 = {"x": point1.x, "y": point1.y}
        dict_point2 = {"x": point2.x, "y": point2.y}
        return cls(dict_point1, dict_point2, color, canvas)
    
    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Segment'

    def draw(self):
        x1, y1 = self.point1.x, self.point1.y
        x2, y2 = self.point2.x, self.point2.y
        self.create_svg_element('line', x1=str(x1), y1=str(y1), x2=str(x2), y2=str(y2), stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()

    def _translate(self, offset):
        self.point1._translate(offset)
        self.point2._translate(offset)

    def _scale(self, factor):
        print(f"self.point1: {self.point1}")
        print(f"self.point2: {self.point2}")
        center = Utilities.get_2D_midpoint(self.point1, self.point2)
        length = Utilities.get_2D_distance(self.point1, self.point2)
        new_length = factor * length
        # Calculate the direction vector from the center to point1
        dx = self.point1.x - center.x
        dy = self.point1.y - center.y
        direction1 = (dx / length, dy / length)
        # Calculate the direction vector from the center to point2
        dx = self.point2.x - center.x
        dy = self.point2.y - center.y
        direction2 = (dx / length, dy / length)
        # Calculate the new positions of the points
        new_point1_x = center.x + direction1[0] * new_length
        new_point1_y = center.y + direction1[1] * new_length
        new_point2_x = center.x + direction2[0] * new_length
        new_point2_y = center.y + direction2[1] * new_length
        # Set the points to their new positions
        self.point1.x = new_point1_x
        self.point1.y = new_point1_y
        self.point2.x = new_point2_x
        self.point2.y = new_point2_y
        # print(f"Segment length: {Utilities.get_2D_distance(self.point1, self.point2)}\nExpected length: {length * factor}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)

    def zoom(self):
        if self.canvas:
            self.point1.zoom()
            self.point2.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        p1 = self.point1.original_position
        p2 = self.point2.original_position
        state = {"class": self.get_class_name(), "args": {"point1": {"x": p1.x, "y": p1.y}, "point2": {"x": p2.x, "y": p2.y}}}
        return state


class Triangle(Drawable):
    def __init__(self, point1, point2, point3, color=default_color, canvas=None):
        self.point1 = Point(point1['x'], point1['y'], color=color, canvas=canvas)
        self.point2 = Point(point2['x'], point2['y'], color=color, canvas=canvas)
        self.point3 = Point(point3['x'], point3['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.point1.canvas = value
        self.point2.canvas = value
        self.point3.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Triangle'

    def draw(self):
        x1, y1 = self.point1.x, self.point1.y
        x2, y2 = self.point2.x, self.point2.y
        x3, y3 = self.point3.x, self.point3.y
        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill='none', stroke=self.color)

    def _initialize(self):
        self.point1._initialize()
        self.point2._initialize()
        self.point3._initialize()

    def _translate(self, offset):
        self.point1._translate(offset)
        self.point2._translate(offset)
        self.point3._translate(offset)

    def _scale(self, factor):
        # initial_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # Compute the centroid of the triangle
        centroid = Position(
            (self.point1.x + self.point2.x + self.point3.x) / 3,
            (self.point1.y + self.point2.y + self.point3.y) / 3
        )
        # Translate points to origin
        self._translate(Position(-centroid.x, -centroid.y))
        # Scale
        self.point1._scale_coordinates(factor)
        self.point2._scale_coordinates(factor)
        self.point3._scale_coordinates(factor)
        # Translate back
        self._translate(Position(centroid.x, centroid.y))
        # actual_area = Utilities.get_triangle_area(self.point1, self.point2, self.point3)
        # print(f"Actual triangle area: {actual_area}\nExpected triangle area: {initial_area * factor**2}")

    def _translate_towards(self, destination, displacement):
        self.point1._translate_towards(destination, displacement)
        self.point2._translate_towards(destination, displacement)
        self.point3._translate_towards(destination, displacement)

    def zoom(self):
        if self.canvas:
            self.point1.zoom()
            self.point2.zoom()
            self.point3.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        p1 = self.point1.original_position
        p2 = self.point2.original_position
        p3 = self.point3.original_position
        state = {"class": self.get_class_name(), "args": {"point1": {"x": p1.x, "y": p1.y}, "point2": {"x": p2.x, "y": p2.y}, "point3": {"x": p3.x, "y": p3.y}}}
        return state


class Rectangle(Drawable):
    def __init__(self, top_left, bottom_right, color=default_color, canvas=None):
        self.top_left = Point(top_left['x'], top_left['y'], color=color, canvas=canvas)
        self.bottom_right = Point(bottom_right['x'], bottom_right['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.top_left.canvas = value
        self.bottom_right.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Rectangle'

    def draw(self):
        width = self.bottom_right.x - self.top_left.x
        height = self.bottom_right.y - self.top_left.y
        x = self.top_left.x
        y = self.top_left.y
        self.create_svg_element('rect', x=str(x), y=str(y), width=str(width), height=str(height), fill="none", stroke=self.color)

    def _initialize(self):
        self.top_left._initialize()
        self.bottom_right._initialize()

    def _translate(self, offset):
        self.top_left._translate(offset)
        self.bottom_right._translate(offset)

    def _scale(self, factor):
        #initial_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        center_x = (self.top_left.x + self.bottom_right.x) / 2
        center_y = (self.top_left.y + self.bottom_right.y) / 2
        self.top_left._translate(Position(-center_x, -center_y))
        self.top_left._scale_coordinates(factor)
        self.top_left._translate(Position(center_x, center_y))
        self.bottom_right._translate(Position(-center_x, -center_y))
        self.bottom_right._scale_coordinates(factor)
        self.bottom_right._translate(Position(center_x, center_y))
        #actual_area = Utilities.get_rectangle_area(self.top_left, self.bottom_right)
        #print(f"Actual rectangle area: {actual_area}\nExpected rectangle area: {initial_area * factor**2}")

    def zoom(self):
        if self.canvas:
            self.top_left.zoom()
            self.bottom_right.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        top_left = self.top_left
        bottom_right = self.bottom_right
        state = {"class": self.get_class_name(), "args": {"top_left": {"x": top_left.x, "y": top_left.y}, "bottom_right": {"x": bottom_right.x, "y": bottom_right.y}}}
        return state


class Circle(Drawable):
    def __init__(self, center, radius, color=default_color, canvas=None):
        self.original_radius = radius
        self.center = Point(center['x'], center['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Circle'

    def draw(self):
        radius = self.radius
        x, y = self.center.x, self.center.y
        self.create_svg_element('circle', cx=str(x), cy=str(y), r=str(radius), fill="none", stroke=self.color)

    def _initialize(self):
        if self.canvas:
            self.radius = self.original_radius * self.canvas.scale_factor
        else:
            self.radius = self.original_radius
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.radius *= math.sqrt(factor)

    def zoom(self):
        if self.canvas:
            self.radius = self.original_radius * self.canvas.scale_factor
            self.center.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        radius = self.original_radius
        center = self.center.original_position
        state = {"class": self.get_class_name(), "args": {"center_point": {"x": center.x, "y": center.y}, "radius": radius}}
        return state


class Ellipse(Drawable):
    def __init__(self, center, rx, ry, color=default_color, canvas=None):
        self.original_rx = rx
        self.original_ry = ry
        self.center = Point(center['x'], center['y'], color=color, canvas=canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.center.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas

    def get_class_name(self):
        return 'Ellipse'

    def draw(self):
        rx = self.rx
        ry = self.ry
        x, y = self.center.x, self.center.y
        self.create_svg_element('ellipse', cx=str(x), cy=str(y), rx=str(rx), ry=str(ry), fill="none", stroke=self.color)

    def _initialize(self):
        if self.canvas:
            scale_factor = self.canvas.scale_factor
            self.rx = self.original_rx * scale_factor
            self.ry = self.original_ry * scale_factor
        else:
            self.rx = self.original_rx
            self.ry = self.original_ry
        self.center._initialize()

    def _translate(self, offset):
        self.center._translate(offset)

    def _scale(self, factor):
        self.rx *= math.sqrt(factor)
        self.ry *= math.sqrt(factor)

    def zoom(self):
        if self.canvas:
            scale_factor = self.canvas.scale_factor
            self.rx = self.original_rx * scale_factor
            self.ry = self.original_ry * scale_factor
            self.center.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        rx = self.original_rx
        ry = self.original_ry
        center = self.center.original_position
        state = {"class": self.get_class_name(), "args": {"center_point": {"x": center.x, "y": center.y}, "radius_x": rx, "radius_y": ry}}
        return state


class Vector(Drawable):
    def __init__(self, origin, tip, color=default_color, canvas=None):
        self.segment = Segment(origin, tip, color, canvas)
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value
        self.segment.canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Vector'

    def _initialize(self):
        self.segment._initialize()

    def _draw_tip_triangle(self):
        # Calculate the triangle points
        tip = self.segment.point2
        origin = self.segment.point1
        dx = tip.x - origin.x
        dy = tip.y - origin.y
        angle = math.atan2(dy, dx)
        side_length = default_point_size * 3  # Adjust to change the size of the tip
        half_base = side_length / 2
        height = math.sqrt(side_length**2 - half_base**2)
        # Calculate the triangle points
        x1, y1 = tip.x, tip.y
        x2, y2 = tip.x - height * math.cos(angle) - half_base * math.sin(angle), tip.y - height * math.sin(angle) + half_base * math.cos(angle)
        x3, y3 = tip.x - height * math.cos(angle) + half_base * math.sin(angle), tip.y - height * math.sin(angle) - half_base * math.cos(angle)
        points = f'{x1},{y1} {x2},{y2} {x3},{y3}'
        self.create_svg_element('polygon', points=points, fill=self.color, stroke=self.color)

    def draw(self):
        self.segment.draw()
        self._draw_tip_triangle()

    def _translate(self, offset):
        self.segment._translate(offset)

    def _scale(self, factor):
        self.segment._scale(factor)

    def zoom(self):
        if self.canvas:
            self.segment.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)
        
    def get_state(self):
        origin = self.segment.point1.original_position
        tip = self.segment.point2.original_position
        state = {"class": self.get_class_name(), "args": {"origin": {"x": origin.x, "y": origin.y}, "tip": {"x": tip.x, "y": tip.y}}}
        return state


class Function(Drawable):
    def __init__(self, canvas, function_string, start, end, step=default_point_size, color=default_color):
        if start > end:
            start, end = end, start
        self.start = Point(start, self.function(start), canvas, color=color)
        self.end = Point(end, self.function(end), canvas, color=color)
        self.step = step
        self.function_string = function_string
        try:
            self.function = Utilities.parse_function_string(function_string)
        except Exception as e:
            raise ValueError(f"Failed to parse function string '{function_string}': {str(e)}")
        super().__init__(color, canvas)
        self._initialize()

    @Drawable.canvas.setter
    def canvas(self, value):
        self._canvas = value

    @canvas.getter
    def canvas(self):
        return self._canvas
    
    def get_class_name(self):
        return 'Function'

    def _initialize(self):
        self.start._initialize()
        self.end._initialize()

    def _generate_values(self):
        # Ensure we don't have a step size of zero
        step = 1 if self.step == 0 else self.step
        # Get the function and scale factor
        f = self.function
        scale_factor = self.canvas.scale_factor
        # Calculate original and scaled start/end points
        start_original = self.start.original_position
        start_scaled = self.start
        end_original = self.end.original_position
        end_scaled = self.end
        # Calculate the number of steps
        steps = int((end_scaled.x + step - start_scaled.x) / step)
        # Calculate the scaled step size, checking for division by zero
        if steps != 0:
            scaled_step = (end_original.x - start_original.x) / steps
        else:
            scaled_step = 0
        # Calculate x and y values for each step
        x_orig_values = [start_original.x + i * scaled_step for i in range(steps + 1)]
        x_scaled_values = [(x - start_original.x) * scale_factor + start_scaled.x for x in x_orig_values]
        y_orig_values = [f(x) for x in x_orig_values]
        y_scaled_values = [-((y - start_original.y) * scale_factor) + start_scaled.y for y in y_orig_values]
        # Combine x and y values into positions and return
        values = [Position(x, y) for x, y in zip(x_scaled_values, y_scaled_values)]
        return values

    def draw(self):
        xy = self._generate_values()
        for i in range(len(xy) - 1):
            point1 = xy[i]
            point2 = xy[i + 1]
            self.create_svg_element('line', x1=str(point1.x), y1=str(point1.y), x2=str(point2.x), y2=str(point2.y), stroke=self.color)

    def _translate(self, offset):
        self.start._translate(offset)
        self.end._translate(offset)

    def _scale(self, factor):
        self.start._scale(factor)
        self.end._scale(factor)

    def zoom(self):
        self.start.zoom()
        self.end.zoom()
    
    def pan(self):
        self._translate(self.canvas.offset)

    def get_state(self):
        function_string = self.function_string
        start = self.start.original_position
        end = self.end.original_position
        state = {"class": self.get_class_name(), "args": {"function_string": function_string, "start": {"x": start.x, "y": start.y}, "end": {"x": end.x, "y": end.y}}}
        return state